
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 08 f0 00 00       	call   80f039 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
  800033:	66 90                	xchg   %ax,%ax
  800035:	66 90                	xchg   %ax,%ax
  800037:	66 90                	xchg   %ax,%ax
  800039:	66 90                	xchg   %ax,%ax
  80003b:	66 90                	xchg   %ax,%ax
  80003d:	66 90                	xchg   %ax,%ax
  80003f:	90                   	nop

00800040 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
  800043:	83 ec 18             	sub    $0x18,%esp
  800046:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800049:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  80004f:	89 04 24             	mov    %eax,(%esp)
  800052:	e8 88 ae 00 00       	call   80aedf <thread_wakeup>
}
  800057:	c9                   	leave  
  800058:	c3                   	ret    

00800059 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800059:	55                   	push   %ebp
  80005a:	89 e5                	mov    %esp,%ebp
  80005c:	53                   	push   %ebx
  80005d:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  800060:	8b 5d 08             	mov    0x8(%ebp),%ebx
  800063:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800065:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800068:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  80006b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80006f:	c7 44 24 08 b9 00 80 	movl   $0x8000b9,0x8(%esp)
  800076:	00 
  800077:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80007b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800082:	e8 c6 ae 00 00       	call   80af4d <thread_create>
	if (r < 0)
  800087:	85 c0                	test   %eax,%eax
  800089:	79 28                	jns    8000b3 <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  80008b:	89 04 24             	mov    %eax,(%esp)
  80008e:	e8 1d b2 00 00       	call   80b2b0 <e2s>
  800093:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800097:	c7 44 24 08 80 1d 81 	movl   $0x811d80,0x8(%esp)
  80009e:	00 
  80009f:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8000a6:	00 
  8000a7:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  8000ae:	e8 e7 ef 00 00       	call   80f09a <_panic>
}
  8000b3:	83 c4 14             	add    $0x14,%esp
  8000b6:	5b                   	pop    %ebx
  8000b7:	5d                   	pop    %ebp
  8000b8:	c3                   	ret    

008000b9 <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8000b9:	55                   	push   %ebp
  8000ba:	89 e5                	mov    %esp,%ebp
  8000bc:	56                   	push   %esi
  8000bd:	53                   	push   %ebx
  8000be:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8000c1:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8000c4:	e8 72 fd 00 00       	call   80fe3b <sys_time_msec>
  8000c9:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8000cb:	e8 c7 ad 00 00       	call   80ae97 <lwip_core_lock>
		t->func();
  8000d0:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  8000d3:	e8 c4 ad 00 00       	call   80ae9c <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  8000d8:	03 33                	add    (%ebx),%esi
  8000da:	89 74 24 08          	mov    %esi,0x8(%esp)
  8000de:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8000e5:	00 
  8000e6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8000ed:	e8 27 b0 00 00       	call   80b119 <thread_wait>
  8000f2:	eb d0                	jmp    8000c4 <net_timer+0xb>

008000f4 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8000f4:	55                   	push   %ebp
  8000f5:	89 e5                	mov    %esp,%ebp
  8000f7:	57                   	push   %edi
  8000f8:	56                   	push   %esi
  8000f9:	53                   	push   %ebx
  8000fa:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
  800100:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  800103:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  800106:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800109:	0f 87 3a 01 00 00    	ja     800249 <serve_thread+0x155>
  80010f:	8b 03                	mov    (%ebx),%eax
  800111:	ff 24 85 60 1f 81 00 	jmp    *0x811f60(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		ret.ret_addrlen = req->accept.req_addrlen;
  800118:	8b 46 04             	mov    0x4(%esi),%eax
  80011b:	89 45 94             	mov    %eax,-0x6c(%ebp)
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80011e:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800121:	89 44 24 08          	mov    %eax,0x8(%esp)
  800125:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800128:	89 44 24 04          	mov    %eax,0x4(%esp)
  80012c:	8b 06                	mov    (%esi),%eax
  80012e:	89 04 24             	mov    %eax,(%esp)
  800131:	e8 5c 0f 00 00       	call   801092 <lwip_accept>
  800136:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800138:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80013f:	00 
  800140:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800143:	89 44 24 04          	mov    %eax,0x4(%esp)
  800147:	89 34 24             	mov    %esi,(%esp)
  80014a:	e8 05 f8 00 00       	call   80f954 <memmove>
  80014f:	e9 13 01 00 00       	jmp    800267 <serve_thread+0x173>
		break;
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800154:	8b 46 14             	mov    0x14(%esi),%eax
  800157:	89 44 24 08          	mov    %eax,0x8(%esp)
  80015b:	8d 46 04             	lea    0x4(%esi),%eax
  80015e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800162:	8b 06                	mov    (%esi),%eax
  800164:	89 04 24             	mov    %eax,(%esp)
  800167:	e8 ec 10 00 00       	call   801258 <lwip_bind>
  80016c:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80016e:	e9 f4 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800173:	8b 46 04             	mov    0x4(%esi),%eax
  800176:	89 44 24 04          	mov    %eax,0x4(%esp)
  80017a:	8b 06                	mov    (%esi),%eax
  80017c:	89 04 24             	mov    %eax,(%esp)
  80017f:	e8 cc 1c 00 00       	call   801e50 <lwip_shutdown>
  800184:	89 c7                	mov    %eax,%edi
		break;
  800186:	e9 dc 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80018b:	8b 06                	mov    (%esi),%eax
  80018d:	89 04 24             	mov    %eax,(%esp)
  800190:	e8 80 11 00 00       	call   801315 <lwip_close>
  800195:	89 c7                	mov    %eax,%edi
		break;
  800197:	e9 cb 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80019c:	8b 46 14             	mov    0x14(%esi),%eax
  80019f:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001a3:	8d 46 04             	lea    0x4(%esi),%eax
  8001a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001aa:	8b 06                	mov    (%esi),%eax
  8001ac:	89 04 24             	mov    %eax,(%esp)
  8001af:	e8 df 11 00 00       	call   801393 <lwip_connect>
  8001b4:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8001b6:	e9 ac 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8001bb:	8b 46 04             	mov    0x4(%esi),%eax
  8001be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001c2:	8b 06                	mov    (%esi),%eax
  8001c4:	89 04 24             	mov    %eax,(%esp)
  8001c7:	e8 84 12 00 00       	call   801450 <lwip_listen>
  8001cc:	89 c7                	mov    %eax,%edi
		break;
  8001ce:	e9 94 00 00 00       	jmp    800267 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8001d3:	8b 46 08             	mov    0x8(%esi),%eax
  8001d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001da:	8b 46 04             	mov    0x4(%esi),%eax
  8001dd:	89 44 24 08          	mov    %eax,0x8(%esp)
  8001e1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8001e5:	8b 06                	mov    (%esi),%eax
  8001e7:	89 04 24             	mov    %eax,(%esp)
  8001ea:	e8 66 15 00 00       	call   801755 <lwip_recv>
  8001ef:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8001f1:	eb 74                	jmp    800267 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8001f3:	8b 46 08             	mov    0x8(%esi),%eax
  8001f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001fa:	8b 46 04             	mov    0x4(%esi),%eax
  8001fd:	89 44 24 08          	mov    %eax,0x8(%esp)
  800201:	8d 46 0c             	lea    0xc(%esi),%eax
  800204:	89 44 24 04          	mov    %eax,0x4(%esp)
  800208:	8b 06                	mov    (%esi),%eax
  80020a:	89 04 24             	mov    %eax,(%esp)
  80020d:	e8 db 16 00 00       	call   8018ed <lwip_send>
  800212:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800214:	eb 51                	jmp    800267 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800216:	8b 46 08             	mov    0x8(%esi),%eax
  800219:	89 44 24 08          	mov    %eax,0x8(%esp)
  80021d:	8b 46 04             	mov    0x4(%esi),%eax
  800220:	89 44 24 04          	mov    %eax,0x4(%esp)
  800224:	8b 06                	mov    (%esi),%eax
  800226:	89 04 24             	mov    %eax,(%esp)
  800229:	e8 72 17 00 00       	call   8019a0 <lwip_socket>
  80022e:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800230:	eb 35                	jmp    800267 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800232:	89 74 24 04          	mov    %esi,0x4(%esp)
  800236:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  80023d:	e8 a4 b1 00 00       	call   80b3e6 <jif_input>
		r = 0;
  800242:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  800247:	eb 4c                	jmp    800295 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  800249:	89 74 24 08          	mov    %esi,0x8(%esp)
  80024d:	8b 43 04             	mov    0x4(%ebx),%eax
  800250:	89 44 24 04          	mov    %eax,0x4(%esp)
  800254:	c7 04 24 a0 1d 81 00 	movl   $0x811da0,(%esp)
  80025b:	e8 33 ef 00 00       	call   80f193 <cprintf>
		r = -E_INVAL;
  800260:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
		break;
  800265:	eb 2e                	jmp    800295 <serve_thread+0x1a1>
	}

	if (r == -1) {
  800267:	83 ff ff             	cmp    $0xffffffff,%edi
  80026a:	75 29                	jne    800295 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80026c:	8b 03                	mov    (%ebx),%eax
  80026e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800272:	c7 44 24 08 c0 1e 81 	movl   $0x811ec0,0x8(%esp)
  800279:	00 
  80027a:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800281:	00 
  800282:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800285:	89 34 24             	mov    %esi,(%esp)
  800288:	e8 bd f4 00 00       	call   80f74a <snprintf>
		perror(buf);
  80028d:	89 34 24             	mov    %esi,(%esp)
  800290:	e8 f0 af 00 00       	call   80b285 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800295:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800298:	74 1f                	je     8002b9 <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80029a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8002a1:	00 
  8002a2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8002a9:	00 
  8002aa:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8002ae:	8b 43 04             	mov    0x4(%ebx),%eax
  8002b1:	89 04 24             	mov    %eax,(%esp)
  8002b4:	e8 cf 00 01 00       	call   810388 <ipc_send>

	put_buffer(args->req);
  8002b9:	8b 43 08             	mov    0x8(%ebx),%eax
	return va;
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  8002bc:	8d 90 00 50 01 f0    	lea    -0xffeb000(%eax),%edx
  8002c2:	c1 ea 0c             	shr    $0xc,%edx
	buse[i] = 0;
  8002c5:	c6 82 00 60 81 00 00 	movb   $0x0,0x816000(%edx)

	if (args->reqno != NSREQ_INPUT)
		ipc_send(args->whom, r, 0, 0);

	put_buffer(args->req);
	sys_page_unmap(0, (void*) args->req);
  8002cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8002d0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002d7:	e8 9e f9 00 00       	call   80fc7a <sys_page_unmap>
	free(args);
  8002dc:	89 1c 24             	mov    %ebx,(%esp)
  8002df:	e8 5c 0f 01 00       	call   811240 <free>
}
  8002e4:	81 c4 8c 00 00 00    	add    $0x8c,%esp
  8002ea:	5b                   	pop    %ebx
  8002eb:	5e                   	pop    %esi
  8002ec:	5f                   	pop    %edi
  8002ed:	5d                   	pop    %ebp
  8002ee:	c3                   	ret    

008002ef <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8002ef:	55                   	push   %ebp
  8002f0:	89 e5                	mov    %esp,%ebp
  8002f2:	56                   	push   %esi
  8002f3:	53                   	push   %ebx
  8002f4:	83 ec 30             	sub    $0x30,%esp
  8002f7:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  8002fa:	e8 98 ab 00 00       	call   80ae97 <lwip_core_lock>

	uint32_t done = 0;
  8002ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800306:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800309:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80030d:	c7 04 24 40 00 80 00 	movl   $0x800040,(%esp)
  800314:	e8 97 24 00 00       	call   8027b0 <tcpip_init>
	lwip_core_unlock();
  800319:	e8 7e ab 00 00       	call   80ae9c <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  80031e:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  800325:	ff 
  800326:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80032d:	00 
  80032e:	89 1c 24             	mov    %ebx,(%esp)
  800331:	e8 e3 ad 00 00       	call   80b119 <thread_wait>
	lwip_core_lock();
  800336:	e8 5c ab 00 00       	call   80ae97 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  80033b:	89 75 e8             	mov    %esi,-0x18(%ebp)
	netmask.addr = init_mask;
  80033e:	8b 45 0c             	mov    0xc(%ebp),%eax
  800341:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  800344:	8b 45 10             	mov    0x10(%ebp),%eax
  800347:	89 45 f0             	mov    %eax,-0x10(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  80034a:	c7 44 24 18 70 6b 80 	movl   $0x806b70,0x18(%esp)
  800351:	00 
  800352:	c7 44 24 14 ee b4 80 	movl   $0x80b4ee,0x14(%esp)
  800359:	00 
  80035a:	c7 44 24 10 14 60 81 	movl   $0x816014,0x10(%esp)
  800361:	00 
  800362:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800365:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800369:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80036c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800370:	8d 45 e8             	lea    -0x18(%ebp),%eax
  800373:	89 44 24 04          	mov    %eax,0x4(%esp)
  800377:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  80037e:	e8 8e 48 00 00       	call   804c11 <netif_add>
  800383:	85 c0                	test   %eax,%eax
  800385:	75 1c                	jne    8003a3 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800387:	c7 44 24 08 c4 1d 81 	movl   $0x811dc4,0x8(%esp)
  80038e:	00 
  80038f:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  800396:	00 
  800397:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  80039e:	e8 f7 ec 00 00       	call   80f09a <_panic>

	netif_set_default(nif);
  8003a3:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  8003aa:	e8 24 49 00 00       	call   804cd3 <netif_set_default>
	netif_set_up(nif);
  8003af:	c7 04 24 20 c2 b3 00 	movl   $0xb3c220,(%esp)
  8003b6:	e8 25 49 00 00       	call   804ce0 <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  8003bb:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8003c2:	b9 cf 1e 81 00       	mov    $0x811ecf,%ecx
  8003c7:	ba 10 9d 80 00       	mov    $0x809d10,%edx
  8003cc:	b8 38 60 81 00       	mov    $0x816038,%eax
  8003d1:	e8 83 fc ff ff       	call   800059 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  8003d6:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8003dd:	b9 d9 1e 81 00       	mov    $0x811ed9,%ecx
  8003e2:	ba 7f 5d 80 00       	mov    $0x805d7f,%edx
  8003e7:	b8 2c 60 81 00       	mov    $0x81602c,%eax
  8003ec:	e8 68 fc ff ff       	call   800059 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  8003f1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8003f8:	b9 e5 1e 81 00       	mov    $0x811ee5,%ecx
  8003fd:	ba 1d 63 80 00       	mov    $0x80631d,%edx
  800402:	b8 20 60 81 00       	mov    $0x816020,%eax
  800407:	e8 4d fc ff ff       	call   800059 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
  80040c:	89 34 24             	mov    %esi,(%esp)
  80040f:	e8 dc 78 00 00       	call   807cf0 <inet_ntoa>
  800414:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  800418:	0f b6 05 4a c2 b3 00 	movzbl 0xb3c24a,%eax
  80041f:	89 44 24 18          	mov    %eax,0x18(%esp)
  800423:	0f b6 05 49 c2 b3 00 	movzbl 0xb3c249,%eax
  80042a:	89 44 24 14          	mov    %eax,0x14(%esp)
  80042e:	0f b6 05 48 c2 b3 00 	movzbl 0xb3c248,%eax
  800435:	89 44 24 10          	mov    %eax,0x10(%esp)
  800439:	0f b6 05 47 c2 b3 00 	movzbl 0xb3c247,%eax
  800440:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800444:	0f b6 05 46 c2 b3 00 	movzbl 0xb3c246,%eax
  80044b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80044f:	0f b6 05 45 c2 b3 00 	movzbl 0xb3c245,%eax
  800456:	89 44 24 04          	mov    %eax,0x4(%esp)
  80045a:	c7 04 24 e4 1d 81 00 	movl   $0x811de4,(%esp)
  800461:	e8 2d ed 00 00       	call   80f193 <cprintf>
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  800466:	e8 31 aa 00 00       	call   80ae9c <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  80046b:	c7 04 24 f1 1e 81 00 	movl   $0x811ef1,(%esp)
  800472:	e8 1c ed 00 00       	call   80f193 <cprintf>
}
  800477:	83 c4 30             	add    $0x30,%esp
  80047a:	5b                   	pop    %ebx
  80047b:	5e                   	pop    %esi
  80047c:	5d                   	pop    %ebp
  80047d:	c3                   	ret    

0080047e <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80047e:	55                   	push   %ebp
  80047f:	89 e5                	mov    %esp,%ebp
  800481:	57                   	push   %edi
  800482:	56                   	push   %esi
  800483:	53                   	push   %ebx
  800484:	83 ec 3c             	sub    $0x3c,%esp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800487:	bb 00 00 00 00       	mov    $0x0,%ebx
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80048c:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80048f:	eb 08                	jmp    800499 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  800491:	e8 03 ac 00 00       	call   80b099 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800496:	83 c3 01             	add    $0x1,%ebx
  800499:	e8 60 aa 00 00       	call   80aefe <thread_wakeups_pending>
  80049e:	85 c0                	test   %eax,%eax
  8004a0:	74 05                	je     8004a7 <serve+0x29>
  8004a2:	83 fb 1f             	cmp    $0x1f,%ebx
  8004a5:	7e ea                	jle    800491 <serve+0x13>
			thread_yield();

		perm = 0;
  8004a7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004ae:	b8 00 00 00 00       	mov    $0x0,%eax
		if (!buse[i]) break;
  8004b3:	80 b8 00 60 81 00 00 	cmpb   $0x0,0x816000(%eax)
  8004ba:	74 0a                	je     8004c6 <serve+0x48>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004bc:	83 c0 01             	add    $0x1,%eax
  8004bf:	83 f8 14             	cmp    $0x14,%eax
  8004c2:	75 ef                	jne    8004b3 <serve+0x35>
  8004c4:	eb 05                	jmp    8004cb <serve+0x4d>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8004c6:	83 f8 14             	cmp    $0x14,%eax
  8004c9:	75 1c                	jne    8004e7 <serve+0x69>
		panic("NS: buffer overflow");
  8004cb:	c7 44 24 08 0a 1f 81 	movl   $0x811f0a,0x8(%esp)
  8004d2:	00 
  8004d3:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8004da:	00 
  8004db:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  8004e2:	e8 b3 eb 00 00       	call   80f09a <_panic>
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8004e7:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8004ed:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8004f0:	c6 80 00 60 81 00 01 	movb   $0x1,0x816000(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8004f7:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8004fb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8004ff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800502:	89 04 24             	mov    %eax,(%esp)
  800505:	e8 16 fe 00 00       	call   810320 <ipc_recv>
  80050a:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  80050c:	83 f8 0c             	cmp    $0xc,%eax
  80050f:	75 70                	jne    800581 <serve+0x103>
			process_timer(whom);
  800511:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800514:	3b 35 1c 60 81 00    	cmp    0x81601c,%esi
  80051a:	74 12                	je     80052e <serve+0xb0>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80051c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800520:	c7 04 24 20 1e 81 00 	movl   $0x811e20,(%esp)
  800527:	e8 67 ec 00 00       	call   80f193 <cprintf>
  80052c:	eb 39                	jmp    800567 <serve+0xe9>
		return;
	}

	start = sys_time_msec();
  80052e:	e8 08 f9 00 00       	call   80fe3b <sys_time_msec>
  800533:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800536:	e8 5e ab 00 00       	call   80b099 <thread_yield>
	now = sys_time_msec();
  80053b:	e8 fb f8 00 00       	call   80fe3b <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800540:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800547:	00 
  800548:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80054f:	00 

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  800550:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800553:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800559:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80055b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80055f:	89 34 24             	mov    %esi,(%esp)
  800562:	e8 21 fe 00 00       	call   810388 <ipc_send>
	return va;
}

static void
put_buffer(void *va) {
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800567:	81 eb 00 b0 fe 0f    	sub    $0xffeb000,%ebx
  80056d:	c1 eb 0c             	shr    $0xc,%ebx
	buse[i] = 0;
  800570:	c6 83 00 60 81 00 00 	movb   $0x0,0x816000(%ebx)

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800577:	bb 00 00 00 00       	mov    $0x0,%ebx

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  80057c:	e9 18 ff ff ff       	jmp    800499 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800581:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  800585:	75 1d                	jne    8005a4 <serve+0x126>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800587:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80058a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80058e:	c7 04 24 5c 1e 81 00 	movl   $0x811e5c,(%esp)
  800595:	e8 f9 eb 00 00       	call   80f193 <cprintf>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80059a:	bb 00 00 00 00       	mov    $0x0,%ebx
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
			cprintf("Invalid request from %08x: no argument page\n", whom);
			continue; // just leave it hanging...
  80059f:	e9 f5 fe ff ff       	jmp    800499 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  8005a4:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8005ab:	e8 62 0d 01 00       	call   811312 <malloc>
		if (!args)
  8005b0:	85 c0                	test   %eax,%eax
  8005b2:	75 1c                	jne    8005d0 <serve+0x152>
			panic("could not allocate thread args structure");
  8005b4:	c7 44 24 08 8c 1e 81 	movl   $0x811e8c,0x8(%esp)
  8005bb:	00 
  8005bc:	c7 44 24 04 27 01 00 	movl   $0x127,0x4(%esp)
  8005c3:	00 
  8005c4:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  8005cb:	e8 ca ea 00 00       	call   80f09a <_panic>

		args->reqno = reqno;
  8005d0:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8005d2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8005d5:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8005d8:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8005db:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005df:	c7 44 24 08 f4 00 80 	movl   $0x8000f4,0x8(%esp)
  8005e6:	00 
  8005e7:	c7 44 24 04 1e 1f 81 	movl   $0x811f1e,0x4(%esp)
  8005ee:	00 
  8005ef:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8005f6:	e8 52 a9 00 00       	call   80af4d <thread_create>
		thread_yield(); // let the thread created run
  8005fb:	e8 99 aa 00 00       	call   80b099 <thread_yield>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800600:	bb 00 00 00 00       	mov    $0x0,%ebx
  800605:	e9 8f fe ff ff       	jmp    800499 <serve+0x1b>

0080060a <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  80060a:	55                   	push   %ebp
  80060b:	89 e5                	mov    %esp,%ebp
  80060d:	56                   	push   %esi
  80060e:	53                   	push   %ebx
  80060f:	83 ec 10             	sub    $0x10,%esp
	serve_init(inet_addr(IP),
  800612:	c7 04 24 2b 1f 81 00 	movl   $0x811f2b,(%esp)
  800619:	e8 b7 79 00 00       	call   807fd5 <inet_addr>
  80061e:	89 c6                	mov    %eax,%esi
  800620:	c7 04 24 34 1f 81 00 	movl   $0x811f34,(%esp)
  800627:	e8 a9 79 00 00       	call   807fd5 <inet_addr>
  80062c:	89 c3                	mov    %eax,%ebx
  80062e:	c7 04 24 42 1f 81 00 	movl   $0x811f42,(%esp)
  800635:	e8 9b 79 00 00       	call   807fd5 <inet_addr>
  80063a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80063e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800642:	89 04 24             	mov    %eax,(%esp)
  800645:	e8 a5 fc ff ff       	call   8002ef <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  80064a:	e8 2f fe ff ff       	call   80047e <serve>

0080064f <umain>:
}

void
umain(int argc, char **argv)
{
  80064f:	55                   	push   %ebp
  800650:	89 e5                	mov    %esp,%ebp
  800652:	53                   	push   %ebx
  800653:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  800656:	e8 3a f5 00 00       	call   80fb95 <sys_getenvid>
  80065b:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  80065d:	c7 05 e8 52 81 00 9f 	movl   $0x81499f,0x8152e8
  800664:	49 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800667:	e8 b4 f9 00 00       	call   810020 <fork>
  80066c:	a3 1c 60 81 00       	mov    %eax,0x81601c
	if (timer_envid < 0)
  800671:	85 c0                	test   %eax,%eax
  800673:	79 1c                	jns    800691 <umain+0x42>
		panic("error forking");
  800675:	c7 44 24 08 4c 1f 81 	movl   $0x811f4c,0x8(%esp)
  80067c:	00 
  80067d:	c7 44 24 04 44 01 00 	movl   $0x144,0x4(%esp)
  800684:	00 
  800685:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  80068c:	e8 09 ea 00 00       	call   80f09a <_panic>
	else if (timer_envid == 0) {
  800691:	85 c0                	test   %eax,%eax
  800693:	75 15                	jne    8006aa <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  800695:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80069c:	00 
  80069d:	89 1c 24             	mov    %ebx,(%esp)
  8006a0:	e8 ab 00 00 00       	call   800750 <timer>
		return;
  8006a5:	e9 9e 00 00 00       	jmp    800748 <umain+0xf9>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8006aa:	e8 71 f9 00 00       	call   810020 <fork>
  8006af:	a3 18 60 81 00       	mov    %eax,0x816018
	if (input_envid < 0)
  8006b4:	85 c0                	test   %eax,%eax
  8006b6:	79 1c                	jns    8006d4 <umain+0x85>
		panic("error forking");
  8006b8:	c7 44 24 08 4c 1f 81 	movl   $0x811f4c,0x8(%esp)
  8006bf:	00 
  8006c0:	c7 44 24 04 4e 01 00 	movl   $0x14e,0x4(%esp)
  8006c7:	00 
  8006c8:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  8006cf:	e8 c6 e9 00 00       	call   80f09a <_panic>
	else if (input_envid == 0) {
  8006d4:	85 c0                	test   %eax,%eax
  8006d6:	75 0a                	jne    8006e2 <umain+0x93>
		input(ns_envid);
  8006d8:	89 1c 24             	mov    %ebx,(%esp)
  8006db:	e8 35 01 00 00       	call   800815 <input>
		return;
  8006e0:	eb 66                	jmp    800748 <umain+0xf9>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8006e2:	e8 39 f9 00 00       	call   810020 <fork>
  8006e7:	a3 14 60 81 00       	mov    %eax,0x816014
	if (output_envid < 0)
  8006ec:	85 c0                	test   %eax,%eax
  8006ee:	79 1c                	jns    80070c <umain+0xbd>
		panic("error forking");
  8006f0:	c7 44 24 08 4c 1f 81 	movl   $0x811f4c,0x8(%esp)
  8006f7:	00 
  8006f8:	c7 44 24 04 58 01 00 	movl   $0x158,0x4(%esp)
  8006ff:	00 
  800700:	c7 04 24 b5 1e 81 00 	movl   $0x811eb5,(%esp)
  800707:	e8 8e e9 00 00       	call   80f09a <_panic>
	else if (output_envid == 0) {
  80070c:	85 c0                	test   %eax,%eax
  80070e:	75 0a                	jne    80071a <umain+0xcb>
		output(ns_envid);
  800710:	89 1c 24             	mov    %ebx,(%esp)
  800713:	e8 b4 01 00 00       	call   8008cc <output>
		return;
  800718:	eb 2e                	jmp    800748 <umain+0xf9>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  80071a:	e8 91 a7 00 00       	call   80aeb0 <thread_init>
	thread_create(0, "main", tmain, 0);
  80071f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800726:	00 
  800727:	c7 44 24 08 0a 06 80 	movl   $0x80060a,0x8(%esp)
  80072e:	00 
  80072f:	c7 44 24 04 5a 1f 81 	movl   $0x811f5a,0x4(%esp)
  800736:	00 
  800737:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80073e:	e8 0a a8 00 00       	call   80af4d <thread_create>
	thread_yield();
  800743:	e8 51 a9 00 00       	call   80b099 <thread_yield>
	// never coming here!
}
  800748:	83 c4 14             	add    $0x14,%esp
  80074b:	5b                   	pop    %ebx
  80074c:	5d                   	pop    %ebp
  80074d:	c3                   	ret    
  80074e:	66 90                	xchg   %ax,%ax

00800750 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800750:	55                   	push   %ebp
  800751:	89 e5                	mov    %esp,%ebp
  800753:	57                   	push   %edi
  800754:	56                   	push   %esi
  800755:	53                   	push   %ebx
  800756:	83 ec 2c             	sub    $0x2c,%esp
  800759:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80075c:	e8 da f6 00 00       	call   80fe3b <sys_time_msec>
  800761:	03 45 0c             	add    0xc(%ebp),%eax
  800764:	89 c6                	mov    %eax,%esi

	binaryname = "ns_timer";
  800766:	c7 05 e8 52 81 00 8c 	movl   $0x811f8c,0x8152e8
  80076d:	1f 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  800770:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  800773:	eb 05                	jmp    80077a <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
  800775:	e8 3a f4 00 00       	call   80fbb4 <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  80077a:	e8 bc f6 00 00       	call   80fe3b <sys_time_msec>
  80077f:	39 c6                	cmp    %eax,%esi
  800781:	76 06                	jbe    800789 <timer+0x39>
  800783:	85 c0                	test   %eax,%eax
  800785:	79 ee                	jns    800775 <timer+0x25>
  800787:	eb 09                	jmp    800792 <timer+0x42>
			sys_yield();
		}
		if (r < 0)
  800789:	85 c0                	test   %eax,%eax
  80078b:	90                   	nop
  80078c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800790:	79 20                	jns    8007b2 <timer+0x62>
			panic("sys_time_msec: %e", r);
  800792:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800796:	c7 44 24 08 95 1f 81 	movl   $0x811f95,0x8(%esp)
  80079d:	00 
  80079e:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007a5:	00 
  8007a6:	c7 04 24 a7 1f 81 00 	movl   $0x811fa7,(%esp)
  8007ad:	e8 e8 e8 00 00       	call   80f09a <_panic>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007b2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007b9:	00 
  8007ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c1:	00 
  8007c2:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007c9:	00 
  8007ca:	89 1c 24             	mov    %ebx,(%esp)
  8007cd:	e8 b6 fb 00 00       	call   810388 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007d2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007d9:	00 
  8007da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007e1:	00 
  8007e2:	89 3c 24             	mov    %edi,(%esp)
  8007e5:	e8 36 fb 00 00       	call   810320 <ipc_recv>
  8007ea:	89 c6                	mov    %eax,%esi

			if (whom != ns_envid) {
  8007ec:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007ef:	39 c3                	cmp    %eax,%ebx
  8007f1:	74 12                	je     800805 <timer+0xb5>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007f7:	c7 04 24 b4 1f 81 00 	movl   $0x811fb4,(%esp)
  8007fe:	e8 90 e9 00 00       	call   80f193 <cprintf>
  800803:	eb cd                	jmp    8007d2 <timer+0x82>
				continue;
			}

			stop = sys_time_msec() + to;
  800805:	e8 31 f6 00 00       	call   80fe3b <sys_time_msec>
  80080a:	01 c6                	add    %eax,%esi
  80080c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800810:	e9 65 ff ff ff       	jmp    80077a <timer+0x2a>

00800815 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800815:	55                   	push   %ebp
  800816:	89 e5                	mov    %esp,%ebp
  800818:	57                   	push   %edi
  800819:	56                   	push   %esi
  80081a:	53                   	push   %ebx
  80081b:	81 ec 2c 08 00 00    	sub    $0x82c,%esp
  800821:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_input";
  800824:	c7 05 e8 52 81 00 ef 	movl   $0x811fef,0x8152e8
  80082b:	1f 81 00 
	int perm = PTE_P | PTE_W | PTE_U;
	size_t length;
	char pkt[PKT_BUF_SIZE];

	while (1) {
		while (sys_e1000_receive(pkt, &length) == -E_E1000_RXBUF_EMPTY);
  80082e:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  800831:	8d 9d e4 f7 ff ff    	lea    -0x81c(%ebp),%ebx
  800837:	89 74 24 04          	mov    %esi,0x4(%esp)
  80083b:	89 1c 24             	mov    %ebx,(%esp)
  80083e:	e8 38 f6 00 00       	call   80fe7b <sys_e1000_receive>
  800843:	83 f8 ef             	cmp    $0xffffffef,%eax
  800846:	74 ef                	je     800837 <input+0x22>

		int r;
		if ((r = sys_page_alloc(0, &nsipcbuf, perm)) < 0)
  800848:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80084f:	00 
  800850:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  800857:	00 
  800858:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80085f:	e8 6f f3 00 00       	call   80fbd3 <sys_page_alloc>
  800864:	85 c0                	test   %eax,%eax
  800866:	79 20                	jns    800888 <input+0x73>
			panic("input: unable to allocate new page, error %e\n", r);
  800868:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80086c:	c7 44 24 08 04 20 81 	movl   $0x812004,0x8(%esp)
  800873:	00 
  800874:	c7 44 24 04 19 00 00 	movl   $0x19,0x4(%esp)
  80087b:	00 
  80087c:	c7 04 24 f8 1f 81 00 	movl   $0x811ff8,(%esp)
  800883:	e8 12 e8 00 00       	call   80f09a <_panic>

		memmove(nsipcbuf.pkt.jp_data, pkt, length);
  800888:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80088b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80088f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800893:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  80089a:	e8 b5 f0 00 00       	call   80f954 <memmove>
		nsipcbuf.pkt.jp_len = length;
  80089f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8008a2:	a3 00 e0 b3 00       	mov    %eax,0xb3e000

		ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, perm);
  8008a7:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8008ae:	00 
  8008af:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  8008b6:	00 
  8008b7:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008be:	00 
  8008bf:	89 3c 24             	mov    %edi,(%esp)
  8008c2:	e8 c1 fa 00 00       	call   810388 <ipc_send>
	}
  8008c7:	e9 6b ff ff ff       	jmp    800837 <input+0x22>

008008cc <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008cc:	55                   	push   %ebp
  8008cd:	89 e5                	mov    %esp,%ebp
  8008cf:	57                   	push   %edi
  8008d0:	56                   	push   %esi
  8008d1:	53                   	push   %ebx
  8008d2:	83 ec 2c             	sub    $0x2c,%esp
  8008d5:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_output";
  8008d8:	c7 05 e8 52 81 00 32 	movl   $0x812032,0x8152e8
  8008df:	20 81 00 
	uint32_t req;
	int perm;

	while(1) {
		perm = 0;
		req = ipc_recv(&sender_envid, &nsipcbuf, &perm);
  8008e2:	8d 75 e0             	lea    -0x20(%ebp),%esi
  8008e5:	8d 5d e4             	lea    -0x1c(%ebp),%ebx
	envid_t sender_envid;
	uint32_t req;
	int perm;

	while(1) {
		perm = 0;
  8008e8:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		req = ipc_recv(&sender_envid, &nsipcbuf, &perm);
  8008ef:	89 74 24 08          	mov    %esi,0x8(%esp)
  8008f3:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  8008fa:	00 
  8008fb:	89 1c 24             	mov    %ebx,(%esp)
  8008fe:	e8 1d fa 00 00       	call   810320 <ipc_recv>

		if (((uint32_t *) sender_envid == 0) || (perm == 0)) {
  800903:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800906:	85 d2                	test   %edx,%edx
  800908:	74 06                	je     800910 <output+0x44>
  80090a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80090e:	75 12                	jne    800922 <output+0x56>
			cprintf("Invalid request; ipc_recv encountered an error %e\n", req);
  800910:	89 44 24 04          	mov    %eax,0x4(%esp)
  800914:	c7 04 24 3c 20 81 00 	movl   $0x81203c,(%esp)
  80091b:	e8 73 e8 00 00       	call   80f193 <cprintf>
			continue;
  800920:	eb c6                	jmp    8008e8 <output+0x1c>
		}

		if (sender_envid != ns_envid) {
  800922:	39 fa                	cmp    %edi,%edx
  800924:	74 16                	je     80093c <output+0x70>
			cprintf("Received IPC from envid %08x, expected to receive from %08x\n",
  800926:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80092a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80092e:	c7 04 24 70 20 81 00 	movl   $0x812070,(%esp)
  800935:	e8 59 e8 00 00       	call   80f193 <cprintf>
				sender_envid, ns_envid);
			continue;
  80093a:	eb ac                	jmp    8008e8 <output+0x1c>
		}

		if (sys_e1000_transmit(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len) == -E_E1000_TXBUF_FULL)
  80093c:	a1 00 e0 b3 00       	mov    0xb3e000,%eax
  800941:	89 44 24 04          	mov    %eax,0x4(%esp)
  800945:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  80094c:	e8 09 f5 00 00       	call   80fe5a <sys_e1000_transmit>
  800951:	83 f8 f0             	cmp    $0xfffffff0,%eax
  800954:	75 92                	jne    8008e8 <output+0x1c>
			cprintf("Dropping packet, after 20 tries cannot transmit");
  800956:	c7 04 24 b0 20 81 00 	movl   $0x8120b0,(%esp)
  80095d:	e8 31 e8 00 00       	call   80f193 <cprintf>
  800962:	eb 84                	jmp    8008e8 <output+0x1c>
  800964:	66 90                	xchg   %ax,%ax
  800966:	66 90                	xchg   %ax,%ax
  800968:	66 90                	xchg   %ax,%ax
  80096a:	66 90                	xchg   %ax,%ax
  80096c:	66 90                	xchg   %ax,%ax
  80096e:	66 90                	xchg   %ax,%ax

00800970 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  800970:	55                   	push   %ebp
  800971:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  800973:	83 f8 1f             	cmp    $0x1f,%eax
  800976:	76 11                	jbe    800989 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  800978:	c7 05 00 c2 b3 00 09 	movl   $0x9,0xb3c200
  80097f:	00 00 00 
    return NULL;
  800982:	b8 00 00 00 00       	mov    $0x0,%eax
  800987:	eb 24                	jmp    8009ad <get_socket+0x3d>
  }

  sock = &sockets[s];
  800989:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80098c:	c1 e2 02             	shl    $0x2,%edx
  80098f:	8d 82 80 60 81 00    	lea    0x816080(%edx),%eax

  if (!sock->conn) {
  800995:	83 ba 80 60 81 00 00 	cmpl   $0x0,0x816080(%edx)
  80099c:	75 0f                	jne    8009ad <get_socket+0x3d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  80099e:	c7 05 00 c2 b3 00 09 	movl   $0x9,0xb3c200
  8009a5:	00 00 00 
    return NULL;
  8009a8:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  return sock;
}
  8009ad:	5d                   	pop    %ebp
  8009ae:	c3                   	ret    

008009af <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  8009af:	55                   	push   %ebp
  8009b0:	89 e5                	mov    %esp,%ebp
  8009b2:	57                   	push   %edi
  8009b3:	56                   	push   %esi
  8009b4:	53                   	push   %ebx
  8009b5:	83 ec 3c             	sub    $0x3c,%esp
  8009b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
  8009bb:	89 55 cc             	mov    %edx,-0x34(%ebp)
  8009be:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  8009c1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8009c8:	00 
  8009c9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8009d0:	00 
  8009d1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8009d4:	89 04 24             	mov    %eax,(%esp)
  8009d7:	e8 2b ef 00 00       	call   80f907 <memset>
  FD_ZERO(&lwriteset);
  8009dc:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8009e3:	00 
  8009e4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8009eb:	00 
  8009ec:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8009ef:	89 04 24             	mov    %eax,(%esp)
  8009f2:	e8 10 ef 00 00       	call   80f907 <memset>
  FD_ZERO(&lexceptset);
  8009f7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8009fe:	00 
  8009ff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800a06:	00 
  800a07:	8d 45 dc             	lea    -0x24(%ebp),%eax
  800a0a:	89 04 24             	mov    %eax,(%esp)
  800a0d:	e8 f5 ee 00 00       	call   80f907 <memset>
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  800a12:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800a19:	bf 00 00 00 00       	mov    $0x0,%edi
  800a1e:	e9 80 00 00 00       	jmp    800aa3 <lwip_selscan+0xf4>
    if (FD_ISSET(i, readset)) {
  800a23:	8d 5f 07             	lea    0x7(%edi),%ebx
  800a26:	85 ff                	test   %edi,%edi
  800a28:	0f 49 df             	cmovns %edi,%ebx
  800a2b:	c1 fb 03             	sar    $0x3,%ebx
  800a2e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800a31:	89 fe                	mov    %edi,%esi
  800a33:	83 e6 07             	and    $0x7,%esi
  800a36:	8b 45 cc             	mov    -0x34(%ebp),%eax
  800a39:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800a3d:	0f a3 f0             	bt     %esi,%eax
  800a40:	73 2c                	jae    800a6e <lwip_selscan+0xbf>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  800a42:	89 f8                	mov    %edi,%eax
  800a44:	e8 27 ff ff ff       	call   800970 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  800a49:	85 c0                	test   %eax,%eax
  800a4b:	74 21                	je     800a6e <lwip_selscan+0xbf>
  800a4d:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  800a51:	75 07                	jne    800a5a <lwip_selscan+0xab>
  800a53:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800a58:	74 14                	je     800a6e <lwip_selscan+0xbf>
        FD_SET(i, &lreadset);
  800a5a:	b8 01 00 00 00       	mov    $0x1,%eax
  800a5f:	89 f1                	mov    %esi,%ecx
  800a61:	d3 e0                	shl    %cl,%eax
  800a63:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a66:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  800a6a:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  800a6e:	8b 45 c8             	mov    -0x38(%ebp),%eax
  800a71:	0f b6 04 18          	movzbl (%eax,%ebx,1),%eax
  800a75:	0f a3 f0             	bt     %esi,%eax
  800a78:	73 26                	jae    800aa0 <lwip_selscan+0xf1>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  800a7a:	89 f8                	mov    %edi,%eax
  800a7c:	e8 ef fe ff ff       	call   800970 <get_socket>
      if (p_sock && p_sock->sendevent) {
  800a81:	85 c0                	test   %eax,%eax
  800a83:	74 1b                	je     800aa0 <lwip_selscan+0xf1>
  800a85:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800a8a:	74 14                	je     800aa0 <lwip_selscan+0xf1>
        FD_SET(i, &lwriteset);
  800a8c:	b8 01 00 00 00       	mov    $0x1,%eax
  800a91:	89 f1                	mov    %esi,%ecx
  800a93:	d3 e0                	shl    %cl,%eax
  800a95:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800a98:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  800a9c:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  800aa0:	83 c7 01             	add    $0x1,%edi
  800aa3:	3b 7d d0             	cmp    -0x30(%ebp),%edi
  800aa6:	0f 8c 77 ff ff ff    	jl     800a23 <lwip_selscan+0x74>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  800aac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800aaf:	8b 55 cc             	mov    -0x34(%ebp),%edx
  800ab2:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  800ab4:	8b 45 e0             	mov    -0x20(%ebp),%eax
  800ab7:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  800aba:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  800abc:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  800ac3:	00 
  800ac4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800acb:	00 
  800acc:	8b 45 08             	mov    0x8(%ebp),%eax
  800acf:	89 04 24             	mov    %eax,(%esp)
  800ad2:	e8 30 ee 00 00       	call   80f907 <memset>
  
  return nready;
}
  800ad7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  800ada:	83 c4 3c             	add    $0x3c,%esp
  800add:	5b                   	pop    %ebx
  800ade:	5e                   	pop    %esi
  800adf:	5f                   	pop    %edi
  800ae0:	5d                   	pop    %ebp
  800ae1:	c3                   	ret    

00800ae2 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  800ae2:	55                   	push   %ebp
  800ae3:	89 e5                	mov    %esp,%ebp
  800ae5:	57                   	push   %edi
  800ae6:	56                   	push   %esi
  800ae7:	53                   	push   %ebx
  800ae8:	83 ec 4c             	sub    $0x4c,%esp
  800aeb:	89 d7                	mov    %edx,%edi
  800aed:	89 ce                	mov    %ecx,%esi
  800aef:	8b 55 08             	mov    0x8(%ebp),%edx
  800af2:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  800af5:	e8 76 fe ff ff       	call   800970 <get_socket>
  800afa:	89 c3                	mov    %eax,%ebx
  if (!sock)
  800afc:	85 c0                	test   %eax,%eax
  800afe:	0f 84 91 00 00 00    	je     800b95 <lwip_getaddrname+0xb3>
    return -1;

  memset(&sin, 0, sizeof(sin));
  800b04:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  800b0b:	00 
  800b0c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800b13:	00 
  800b14:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800b17:	89 04 24             	mov    %eax,(%esp)
  800b1a:	e8 e8 ed 00 00       	call   80f907 <memset>
  sin.sin_len = sizeof(sin);
  800b1f:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  800b23:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  800b27:	0f b6 45 c4          	movzbl -0x3c(%ebp),%eax
  800b2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800b2f:	8d 45 da             	lea    -0x26(%ebp),%eax
  800b32:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b36:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  800b39:	89 44 24 04          	mov    %eax,0x4(%esp)
  800b3d:	8b 03                	mov    (%ebx),%eax
  800b3f:	89 04 24             	mov    %eax,(%esp)
  800b42:	e8 c2 ab 00 00       	call   80b709 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  800b47:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  800b4b:	89 04 24             	mov    %eax,(%esp)
  800b4e:	e8 53 72 00 00       	call   807da6 <htons>
  800b53:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  800b57:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800b5a:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  800b5d:	83 3e 10             	cmpl   $0x10,(%esi)
  800b60:	76 06                	jbe    800b68 <lwip_getaddrname+0x86>
    *namelen = sizeof(sin);
  800b62:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  800b68:	8b 06                	mov    (%esi),%eax
  800b6a:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b6e:	8d 45 d8             	lea    -0x28(%ebp),%eax
  800b71:	89 44 24 04          	mov    %eax,0x4(%esp)
  800b75:	89 3c 24             	mov    %edi,(%esp)
  800b78:	e8 3f ee 00 00       	call   80f9bc <memcpy>
  sock_set_errno(sock, 0);
  800b7d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  800b84:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  800b8b:	00 00 00 
  return 0;
  800b8e:	b8 00 00 00 00       	mov    $0x0,%eax
  800b93:	eb 05                	jmp    800b9a <lwip_getaddrname+0xb8>
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
    return -1;
  800b95:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    *namelen = sizeof(sin);

  SMEMCPY(name, &sin, *namelen);
  sock_set_errno(sock, 0);
  return 0;
}
  800b9a:	83 c4 4c             	add    $0x4c,%esp
  800b9d:	5b                   	pop    %ebx
  800b9e:	5e                   	pop    %esi
  800b9f:	5f                   	pop    %edi
  800ba0:	5d                   	pop    %ebp
  800ba1:	c3                   	ret    

00800ba2 <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  800ba2:	55                   	push   %ebp
  800ba3:	89 e5                	mov    %esp,%ebp
  800ba5:	57                   	push   %edi
  800ba6:	56                   	push   %esi
  800ba7:	53                   	push   %ebx
  800ba8:	83 ec 1c             	sub    $0x1c,%esp
  800bab:	8b 7d 08             	mov    0x8(%ebp),%edi
  800bae:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  800bb1:	85 ff                	test   %edi,%edi
  800bb3:	0f 84 6a 01 00 00    	je     800d23 <event_callback+0x181>
    s = conn->socket;
  800bb9:	8b 5f 1c             	mov    0x1c(%edi),%ebx
    if (s < 0) {
  800bbc:	85 db                	test   %ebx,%ebx
  800bbe:	79 3d                	jns    800bfd <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  800bc0:	a1 64 60 81 00       	mov    0x816064,%eax
  800bc5:	89 04 24             	mov    %eax,(%esp)
  800bc8:	e8 8b 4b 00 00       	call   805758 <sys_sem_wait>
      if (conn->socket < 0) {
  800bcd:	8b 47 1c             	mov    0x1c(%edi),%eax
  800bd0:	85 c0                	test   %eax,%eax
  800bd2:	79 1c                	jns    800bf0 <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  800bd4:	85 f6                	test   %esi,%esi
  800bd6:	75 06                	jne    800bde <event_callback+0x3c>
          conn->socket--;
  800bd8:	83 e8 01             	sub    $0x1,%eax
  800bdb:	89 47 1c             	mov    %eax,0x1c(%edi)
        }
        sys_sem_signal(socksem);
  800bde:	a1 64 60 81 00       	mov    0x816064,%eax
  800be3:	89 04 24             	mov    %eax,(%esp)
  800be6:	e8 45 9d 00 00       	call   80a930 <sys_sem_signal>
        return;
  800beb:	e9 33 01 00 00       	jmp    800d23 <event_callback+0x181>
      }
      sys_sem_signal(socksem);
  800bf0:	a1 64 60 81 00       	mov    0x816064,%eax
  800bf5:	89 04 24             	mov    %eax,(%esp)
  800bf8:	e8 33 9d 00 00       	call   80a930 <sys_sem_signal>
    }

    sock = get_socket(s);
  800bfd:	89 d8                	mov    %ebx,%eax
  800bff:	e8 6c fd ff ff       	call   800970 <get_socket>
  800c04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  800c07:	85 c0                	test   %eax,%eax
  800c09:	0f 84 14 01 00 00    	je     800d23 <event_callback+0x181>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  800c0f:	a1 60 60 81 00       	mov    0x816060,%eax
  800c14:	89 04 24             	mov    %eax,(%esp)
  800c17:	e8 3c 4b 00 00       	call   805758 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  800c1c:	83 fe 01             	cmp    $0x1,%esi
  800c1f:	74 1d                	je     800c3e <event_callback+0x9c>
  800c21:	83 fe 01             	cmp    $0x1,%esi
  800c24:	72 0e                	jb     800c34 <event_callback+0x92>
  800c26:	83 fe 02             	cmp    $0x2,%esi
  800c29:	74 1d                	je     800c48 <event_callback+0xa6>
  800c2b:	83 fe 03             	cmp    $0x3,%esi
  800c2e:	66 90                	xchg   %ax,%ax
  800c30:	74 21                	je     800c53 <event_callback+0xb1>
  800c32:	eb 2a                	jmp    800c5e <event_callback+0xbc>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  800c34:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c37:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  800c3c:	eb 3c                	jmp    800c7a <event_callback+0xd8>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  800c3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c41:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  800c46:	eb 32                	jmp    800c7a <event_callback+0xd8>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  800c48:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c4b:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  800c51:	eb 27                	jmp    800c7a <event_callback+0xd8>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  800c53:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800c56:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  800c5c:	eb 1c                	jmp    800c7a <event_callback+0xd8>
    default:
      LWIP_ASSERT("unknown event", 0);
  800c5e:	c7 44 24 08 e0 20 81 	movl   $0x8120e0,0x8(%esp)
  800c65:	00 
  800c66:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  800c6d:	00 
  800c6e:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  800c75:	e8 20 e4 00 00       	call   80f09a <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  800c7a:	a1 60 60 81 00       	mov    0x816060,%eax
  800c7f:	89 04 24             	mov    %eax,(%esp)
  800c82:	e8 a9 9c 00 00       	call   80a930 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800c87:	8d 7b 07             	lea    0x7(%ebx),%edi
  800c8a:	85 db                	test   %ebx,%ebx
  800c8c:	0f 49 fb             	cmovns %ebx,%edi
  800c8f:	c1 ff 03             	sar    $0x3,%edi
  800c92:	89 d9                	mov    %ebx,%ecx
  800c94:	83 e1 07             	and    $0x7,%ecx
  800c97:	b8 01 00 00 00       	mov    $0x1,%eax
  800c9c:	d3 e0                	shl    %cl,%eax
  800c9e:	89 c6                	mov    %eax,%esi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  800ca0:	a1 60 60 81 00       	mov    0x816060,%eax
  800ca5:	89 04 24             	mov    %eax,(%esp)
  800ca8:	e8 ab 4a 00 00       	call   805758 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  800cad:	8b 1d 68 60 81 00    	mov    0x816068,%ebx
  800cb3:	eb 3a                	jmp    800cef <event_callback+0x14d>
      if (scb->sem_signalled == 0) {
  800cb5:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  800cb9:	75 32                	jne    800ced <event_callback+0x14b>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  800cbb:	8b 43 04             	mov    0x4(%ebx),%eax
  800cbe:	85 c0                	test   %eax,%eax
  800cc0:	74 12                	je     800cd4 <event_callback+0x132>
  800cc2:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
  800cc6:	85 f0                	test   %esi,%eax
  800cc8:	74 0a                	je     800cd4 <event_callback+0x132>
          if (sock->rcvevent)
  800cca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ccd:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  800cd2:	75 21                	jne    800cf5 <event_callback+0x153>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  800cd4:	8b 43 08             	mov    0x8(%ebx),%eax
  800cd7:	85 c0                	test   %eax,%eax
  800cd9:	74 12                	je     800ced <event_callback+0x14b>
  800cdb:	0f b6 04 38          	movzbl (%eax,%edi,1),%eax
  800cdf:	85 f0                	test   %esi,%eax
  800ce1:	74 0a                	je     800ced <event_callback+0x14b>
          if (sock->sendevent)
  800ce3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ce6:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  800ceb:	75 08                	jne    800cf5 <event_callback+0x153>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  800ced:	8b 1b                	mov    (%ebx),%ebx
  800cef:	85 db                	test   %ebx,%ebx
  800cf1:	75 c2                	jne    800cb5 <event_callback+0x113>
  800cf3:	eb 21                	jmp    800d16 <event_callback+0x174>
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
      scb->sem_signalled = 1;
  800cf5:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  800cfc:	a1 60 60 81 00       	mov    0x816060,%eax
  800d01:	89 04 24             	mov    %eax,(%esp)
  800d04:	e8 27 9c 00 00       	call   80a930 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  800d09:	8b 43 14             	mov    0x14(%ebx),%eax
  800d0c:	89 04 24             	mov    %eax,(%esp)
  800d0f:	e8 1c 9c 00 00       	call   80a930 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  800d14:	eb 8a                	jmp    800ca0 <event_callback+0xfe>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  800d16:	a1 60 60 81 00       	mov    0x816060,%eax
  800d1b:	89 04 24             	mov    %eax,(%esp)
  800d1e:	e8 0d 9c 00 00       	call   80a930 <sys_sem_signal>
      break;
    }
  }
}
  800d23:	83 c4 1c             	add    $0x1c,%esp
  800d26:	5b                   	pop    %ebx
  800d27:	5e                   	pop    %esi
  800d28:	5f                   	pop    %edi
  800d29:	5d                   	pop    %ebp
  800d2a:	c3                   	ret    

00800d2b <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  800d2b:	55                   	push   %ebp
  800d2c:	89 e5                	mov    %esp,%ebp
  800d2e:	56                   	push   %esi
  800d2f:	53                   	push   %ebx
  800d30:	83 ec 10             	sub    $0x10,%esp
  800d33:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  800d35:	a1 64 60 81 00       	mov    0x816064,%eax
  800d3a:	89 04 24             	mov    %eax,(%esp)
  800d3d:	e8 16 4a 00 00       	call   805758 <sys_sem_wait>
  800d42:	ba 80 60 81 00       	mov    $0x816080,%edx

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800d47:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
  800d4c:	83 3a 00             	cmpl   $0x0,(%edx)
  800d4f:	75 5f                	jne    800db0 <alloc_socket+0x85>
      sockets[i].conn       = newconn;
  800d51:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  800d58:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  800d5b:	c1 e1 02             	shl    $0x2,%ecx
  800d5e:	89 b1 80 60 81 00    	mov    %esi,0x816080(%ecx)
      sockets[i].lastdata   = NULL;
  800d64:	c7 81 84 60 81 00 00 	movl   $0x0,0x816084(%ecx)
  800d6b:	00 00 00 
      sockets[i].lastoffset = 0;
  800d6e:	66 c7 81 88 60 81 00 	movw   $0x0,0x816088(%ecx)
  800d75:	00 00 
      sockets[i].rcvevent   = 0;
  800d77:	66 c7 81 8a 60 81 00 	movw   $0x0,0x81608a(%ecx)
  800d7e:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  800d80:	66 c7 81 8c 60 81 00 	movw   $0x1,0x81608c(%ecx)
  800d87:	01 00 
      sockets[i].flags      = 0;
  800d89:	66 c7 81 8e 60 81 00 	movw   $0x0,0x81608e(%ecx)
  800d90:	00 00 
      sockets[i].err        = 0;
  800d92:	01 da                	add    %ebx,%edx
  800d94:	c7 04 95 90 60 81 00 	movl   $0x0,0x816090(,%edx,4)
  800d9b:	00 00 00 00 
      sys_sem_signal(socksem);
  800d9f:	a1 64 60 81 00       	mov    0x816064,%eax
  800da4:	89 04 24             	mov    %eax,(%esp)
  800da7:	e8 84 9b 00 00       	call   80a930 <sys_sem_signal>
      return i;
  800dac:	89 d8                	mov    %ebx,%eax
  800dae:	eb 1d                	jmp    800dcd <alloc_socket+0xa2>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  800db0:	83 c3 01             	add    $0x1,%ebx
  800db3:	83 c2 14             	add    $0x14,%edx
  800db6:	83 fb 20             	cmp    $0x20,%ebx
  800db9:	75 91                	jne    800d4c <alloc_socket+0x21>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  800dbb:	a1 64 60 81 00       	mov    0x816064,%eax
  800dc0:	89 04 24             	mov    %eax,(%esp)
  800dc3:	e8 68 9b 00 00       	call   80a930 <sys_sem_signal>
  return -1;
  800dc8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  800dcd:	83 c4 10             	add    $0x10,%esp
  800dd0:	5b                   	pop    %ebx
  800dd1:	5e                   	pop    %esi
  800dd2:	5d                   	pop    %ebp
  800dd3:	c3                   	ret    

00800dd4 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  800dd4:	55                   	push   %ebp
  800dd5:	89 e5                	mov    %esp,%ebp
  800dd7:	53                   	push   %ebx
  800dd8:	83 ec 14             	sub    $0x14,%esp
  800ddb:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800dde:	85 c0                	test   %eax,%eax
  800de0:	75 1c                	jne    800dfe <lwip_getsockopt_internal+0x2a>
  800de2:	c7 44 24 08 05 21 81 	movl   $0x812105,0x8(%esp)
  800de9:	00 
  800dea:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  800df1:	00 
  800df2:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  800df9:	e8 9c e2 00 00       	call   80f09a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800dfe:	8b 08                	mov    (%eax),%ecx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800e00:	8b 50 0c             	mov    0xc(%eax),%edx
  optval = data->optval;
  800e03:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800e06:	8b 40 08             	mov    0x8(%eax),%eax
  800e09:	83 f8 06             	cmp    $0x6,%eax
  800e0c:	0f 84 0a 01 00 00    	je     800f1c <lwip_getsockopt_internal+0x148>
  800e12:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800e17:	74 0d                	je     800e26 <lwip_getsockopt_internal+0x52>
  800e19:	85 c0                	test   %eax,%eax
  800e1b:	0f 85 27 01 00 00    	jne    800f48 <lwip_getsockopt_internal+0x174>
  800e21:	e9 d2 00 00 00       	jmp    800ef8 <lwip_getsockopt_internal+0x124>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800e26:	83 fa 20             	cmp    $0x20,%edx
  800e29:	74 39                	je     800e64 <lwip_getsockopt_internal+0x90>
  800e2b:	83 fa 20             	cmp    $0x20,%edx
  800e2e:	66 90                	xchg   %ax,%ax
  800e30:	7f 10                	jg     800e42 <lwip_getsockopt_internal+0x6e>
  800e32:	83 fa 02             	cmp    $0x2,%edx
  800e35:	74 2d                	je     800e64 <lwip_getsockopt_internal+0x90>
  800e37:	83 fa 08             	cmp    $0x8,%edx
  800e3a:	0f 85 08 01 00 00    	jne    800f48 <lwip_getsockopt_internal+0x174>
  800e40:	eb 22                	jmp    800e64 <lwip_getsockopt_internal+0x90>
  800e42:	81 fa 08 10 00 00    	cmp    $0x1008,%edx
  800e48:	74 2c                	je     800e76 <lwip_getsockopt_internal+0xa2>
  800e4a:	81 fa 0a 10 00 00    	cmp    $0x100a,%edx
  800e50:	0f 84 92 00 00 00    	je     800ee8 <lwip_getsockopt_internal+0x114>
  800e56:	81 fa 07 10 00 00    	cmp    $0x1007,%edx
  800e5c:	0f 85 e6 00 00 00    	jne    800f48 <lwip_getsockopt_internal+0x174>
  800e62:	eb 4f                	jmp    800eb3 <lwip_getsockopt_internal+0xdf>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  800e64:	8b 01                	mov    (%ecx),%eax
  800e66:	8b 40 08             	mov    0x8(%eax),%eax
  800e69:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  800e6d:	21 c2                	and    %eax,%edx
  800e6f:	89 13                	mov    %edx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  800e71:	e9 d2 00 00 00       	jmp    800f48 <lwip_getsockopt_internal+0x174>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  800e76:	8b 01                	mov    (%ecx),%eax
  800e78:	8b 10                	mov    (%eax),%edx
  800e7a:	89 d0                	mov    %edx,%eax
  800e7c:	25 f0 00 00 00       	and    $0xf0,%eax
  800e81:	83 f8 20             	cmp    $0x20,%eax
  800e84:	74 22                	je     800ea8 <lwip_getsockopt_internal+0xd4>
  800e86:	83 f8 40             	cmp    $0x40,%eax
  800e89:	74 12                	je     800e9d <lwip_getsockopt_internal+0xc9>
  800e8b:	83 f8 10             	cmp    $0x10,%eax
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  800e8e:	b8 01 00 00 00       	mov    $0x1,%eax
  800e93:	0f 44 d0             	cmove  %eax,%edx
  800e96:	89 13                	mov    %edx,(%ebx)
  800e98:	e9 ab 00 00 00       	jmp    800f48 <lwip_getsockopt_internal+0x174>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  800e9d:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  800ea3:	e9 a0 00 00 00       	jmp    800f48 <lwip_getsockopt_internal+0x174>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  800ea8:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  800eae:	e9 95 00 00 00       	jmp    800f48 <lwip_getsockopt_internal+0x174>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  800eb3:	83 79 10 00          	cmpl   $0x0,0x10(%ecx)
  800eb7:	75 21                	jne    800eda <lwip_getsockopt_internal+0x106>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  800eb9:	8b 01                	mov    (%ecx),%eax
  800ebb:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  800ebf:	f7 da                	neg    %edx
  800ec1:	b8 05 00 00 00       	mov    $0x5,%eax
  800ec6:	83 fa 0e             	cmp    $0xe,%edx
  800ec9:	77 07                	ja     800ed2 <lwip_getsockopt_internal+0xfe>
  800ecb:	8b 04 95 a0 21 81 00 	mov    0x8121a0(,%edx,4),%eax
  800ed2:	89 41 10             	mov    %eax,0x10(%ecx)
  800ed5:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
      } 
      *(int *)optval = sock->err;
  800eda:	8b 41 10             	mov    0x10(%ecx),%eax
  800edd:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  800edf:	c7 41 10 00 00 00 00 	movl   $0x0,0x10(%ecx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  800ee6:	eb 60                	jmp    800f48 <lwip_getsockopt_internal+0x174>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  800ee8:	8b 01                	mov    (%ecx),%eax
  800eea:	8b 40 08             	mov    0x8(%eax),%eax
  800eed:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  800ef1:	83 e0 01             	and    $0x1,%eax
  800ef4:	89 03                	mov    %eax,(%ebx)
      break;
  800ef6:	eb 50                	jmp    800f48 <lwip_getsockopt_internal+0x174>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800ef8:	83 fa 01             	cmp    $0x1,%edx
  800efb:	74 12                	je     800f0f <lwip_getsockopt_internal+0x13b>
  800efd:	83 fa 02             	cmp    $0x2,%edx
  800f00:	75 46                	jne    800f48 <lwip_getsockopt_internal+0x174>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  800f02:	8b 01                	mov    (%ecx),%eax
  800f04:	8b 40 08             	mov    0x8(%eax),%eax
  800f07:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  800f0b:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  800f0d:	eb 39                	jmp    800f48 <lwip_getsockopt_internal+0x174>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  800f0f:	8b 01                	mov    (%ecx),%eax
  800f11:	8b 40 08             	mov    0x8(%eax),%eax
  800f14:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  800f18:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  800f1a:	eb 2c                	jmp    800f48 <lwip_getsockopt_internal+0x174>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  800f1c:	83 fa 01             	cmp    $0x1,%edx
  800f1f:	74 07                	je     800f28 <lwip_getsockopt_internal+0x154>
  800f21:	83 fa 02             	cmp    $0x2,%edx
  800f24:	74 15                	je     800f3b <lwip_getsockopt_internal+0x167>
  800f26:	eb 20                	jmp    800f48 <lwip_getsockopt_internal+0x174>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  800f28:	8b 01                	mov    (%ecx),%eax
  800f2a:	8b 40 08             	mov    0x8(%eax),%eax
  800f2d:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  800f31:	83 e0 40             	and    $0x40,%eax
  800f34:	0f b6 c0             	movzbl %al,%eax
  800f37:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  800f39:	eb 0d                	jmp    800f48 <lwip_getsockopt_internal+0x174>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  800f3b:	8b 01                	mov    (%ecx),%eax
  800f3d:	8b 40 08             	mov    0x8(%eax),%eax
  800f40:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  800f46:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  800f48:	8b 01                	mov    (%ecx),%eax
  800f4a:	8b 40 10             	mov    0x10(%eax),%eax
  800f4d:	89 04 24             	mov    %eax,(%esp)
  800f50:	e8 db 99 00 00       	call   80a930 <sys_sem_signal>
}
  800f55:	83 c4 14             	add    $0x14,%esp
  800f58:	5b                   	pop    %ebx
  800f59:	5d                   	pop    %ebp
  800f5a:	c3                   	ret    

00800f5b <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  800f5b:	55                   	push   %ebp
  800f5c:	89 e5                	mov    %esp,%ebp
  800f5e:	53                   	push   %ebx
  800f5f:	83 ec 14             	sub    $0x14,%esp
  800f62:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  800f65:	85 c0                	test   %eax,%eax
  800f67:	75 1c                	jne    800f85 <lwip_setsockopt_internal+0x2a>
  800f69:	c7 44 24 08 05 21 81 	movl   $0x812105,0x8(%esp)
  800f70:	00 
  800f71:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  800f78:	00 
  800f79:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  800f80:	e8 15 e1 00 00       	call   80f09a <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  800f85:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  800f87:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  800f8a:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  800f8d:	8b 40 08             	mov    0x8(%eax),%eax
  800f90:	83 f8 06             	cmp    $0x6,%eax
  800f93:	0f 84 87 00 00 00    	je     801020 <lwip_setsockopt_internal+0xc5>
  800f99:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  800f9e:	74 0a                	je     800faa <lwip_setsockopt_internal+0x4f>
  800fa0:	85 c0                	test   %eax,%eax
  800fa2:	0f 85 ad 00 00 00    	jne    801055 <lwip_setsockopt_internal+0xfa>
  800fa8:	eb 54                	jmp    800ffe <lwip_setsockopt_internal+0xa3>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  800faa:	83 f9 20             	cmp    $0x20,%ecx
  800fad:	8d 76 00             	lea    0x0(%esi),%esi
  800fb0:	74 11                	je     800fc3 <lwip_setsockopt_internal+0x68>
  800fb2:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  800fb8:	74 29                	je     800fe3 <lwip_setsockopt_internal+0x88>
  800fba:	83 f9 08             	cmp    $0x8,%ecx
  800fbd:	0f 85 92 00 00 00    	jne    801055 <lwip_setsockopt_internal+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  800fc3:	83 3b 00             	cmpl   $0x0,(%ebx)
  800fc6:	74 0e                	je     800fd6 <lwip_setsockopt_internal+0x7b>
        sock->conn->pcb.ip->so_options |= optname;
  800fc8:	8b 02                	mov    (%edx),%eax
  800fca:	8b 40 08             	mov    0x8(%eax),%eax
  800fcd:	66 09 48 08          	or     %cx,0x8(%eax)
  800fd1:	e9 7f 00 00 00       	jmp    801055 <lwip_setsockopt_internal+0xfa>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  800fd6:	8b 02                	mov    (%edx),%eax
  800fd8:	8b 40 08             	mov    0x8(%eax),%eax
  800fdb:	f7 d1                	not    %ecx
  800fdd:	66 21 48 08          	and    %cx,0x8(%eax)
  800fe1:	eb 72                	jmp    801055 <lwip_setsockopt_internal+0xfa>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  800fe3:	83 3b 00             	cmpl   $0x0,(%ebx)
  800fe6:	74 0b                	je     800ff3 <lwip_setsockopt_internal+0x98>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  800fe8:	8b 02                	mov    (%edx),%eax
  800fea:	8b 40 08             	mov    0x8(%eax),%eax
  800fed:	80 48 10 01          	orb    $0x1,0x10(%eax)
  800ff1:	eb 62                	jmp    801055 <lwip_setsockopt_internal+0xfa>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  800ff3:	8b 02                	mov    (%edx),%eax
  800ff5:	8b 40 08             	mov    0x8(%eax),%eax
  800ff8:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  800ffc:	eb 57                	jmp    801055 <lwip_setsockopt_internal+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  800ffe:	83 f9 01             	cmp    $0x1,%ecx
  801001:	74 11                	je     801014 <lwip_setsockopt_internal+0xb9>
  801003:	83 f9 02             	cmp    $0x2,%ecx
  801006:	75 4d                	jne    801055 <lwip_setsockopt_internal+0xfa>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  801008:	8b 02                	mov    (%edx),%eax
  80100a:	8b 40 08             	mov    0x8(%eax),%eax
  80100d:	8b 0b                	mov    (%ebx),%ecx
  80100f:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  801012:	eb 41                	jmp    801055 <lwip_setsockopt_internal+0xfa>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  801014:	8b 02                	mov    (%edx),%eax
  801016:	8b 40 08             	mov    0x8(%eax),%eax
  801019:	8b 0b                	mov    (%ebx),%ecx
  80101b:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  80101e:	eb 35                	jmp    801055 <lwip_setsockopt_internal+0xfa>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  801020:	83 f9 01             	cmp    $0x1,%ecx
  801023:	74 07                	je     80102c <lwip_setsockopt_internal+0xd1>
  801025:	83 f9 02             	cmp    $0x2,%ecx
  801028:	74 1e                	je     801048 <lwip_setsockopt_internal+0xed>
  80102a:	eb 29                	jmp    801055 <lwip_setsockopt_internal+0xfa>
    case TCP_NODELAY:
      if (*(int*)optval) {
  80102c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80102f:	90                   	nop
  801030:	74 0b                	je     80103d <lwip_setsockopt_internal+0xe2>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  801032:	8b 02                	mov    (%edx),%eax
  801034:	8b 40 08             	mov    0x8(%eax),%eax
  801037:	80 48 20 40          	orb    $0x40,0x20(%eax)
  80103b:	eb 18                	jmp    801055 <lwip_setsockopt_internal+0xfa>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  80103d:	8b 02                	mov    (%edx),%eax
  80103f:	8b 40 08             	mov    0x8(%eax),%eax
  801042:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  801046:	eb 0d                	jmp    801055 <lwip_setsockopt_internal+0xfa>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  801048:	8b 02                	mov    (%edx),%eax
  80104a:	8b 40 08             	mov    0x8(%eax),%eax
  80104d:	8b 0b                	mov    (%ebx),%ecx
  80104f:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  801055:	8b 02                	mov    (%edx),%eax
  801057:	8b 40 10             	mov    0x10(%eax),%eax
  80105a:	89 04 24             	mov    %eax,(%esp)
  80105d:	e8 ce 98 00 00       	call   80a930 <sys_sem_signal>
}
  801062:	83 c4 14             	add    $0x14,%esp
  801065:	5b                   	pop    %ebx
  801066:	5d                   	pop    %ebp
  801067:	c3                   	ret    

00801068 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  801068:	55                   	push   %ebp
  801069:	89 e5                	mov    %esp,%ebp
  80106b:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  80106e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801075:	e8 d4 95 00 00       	call   80a64e <sys_sem_new>
  80107a:	a3 64 60 81 00       	mov    %eax,0x816064
  selectsem = sys_sem_new(1);
  80107f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801086:	e8 c3 95 00 00       	call   80a64e <sys_sem_new>
  80108b:	a3 60 60 81 00       	mov    %eax,0x816060
}
  801090:	c9                   	leave  
  801091:	c3                   	ret    

00801092 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  801092:	55                   	push   %ebp
  801093:	89 e5                	mov    %esp,%ebp
  801095:	57                   	push   %edi
  801096:	56                   	push   %esi
  801097:	53                   	push   %ebx
  801098:	83 ec 4c             	sub    $0x4c,%esp
  80109b:	8b 75 10             	mov    0x10(%ebp),%esi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  80109e:	8b 45 08             	mov    0x8(%ebp),%eax
  8010a1:	e8 ca f8 ff ff       	call   800970 <get_socket>
  8010a6:	89 c7                	mov    %eax,%edi
  if (!sock)
  8010a8:	85 c0                	test   %eax,%eax
  8010aa:	0f 84 9b 01 00 00    	je     80124b <lwip_accept+0x1b9>
    return -1;

  newconn = netconn_accept(sock->conn);
  8010b0:	8b 00                	mov    (%eax),%eax
  8010b2:	89 04 24             	mov    %eax,(%esp)
  8010b5:	e8 28 a8 00 00       	call   80b8e2 <netconn_accept>
  8010ba:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  8010bc:	85 c0                	test   %eax,%eax
  8010be:	75 2b                	jne    8010eb <lwip_accept+0x59>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  8010c0:	8b 07                	mov    (%edi),%eax
  8010c2:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  8010c6:	f7 da                	neg    %edx
  8010c8:	b8 05 00 00 00       	mov    $0x5,%eax
  8010cd:	83 fa 0e             	cmp    $0xe,%edx
  8010d0:	77 07                	ja     8010d9 <lwip_accept+0x47>
  8010d2:	8b 04 95 a0 21 81 00 	mov    0x8121a0(,%edx,4),%eax
  8010d9:	89 47 10             	mov    %eax,0x10(%edi)
  8010dc:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  8010e1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8010e6:	e9 65 01 00 00       	jmp    801250 <lwip_accept+0x1be>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  8010eb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8010f2:	00 
  8010f3:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  8010f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8010fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  801101:	89 1c 24             	mov    %ebx,(%esp)
  801104:	e8 00 a6 00 00       	call   80b709 <netconn_getaddr>
  801109:	88 45 c4             	mov    %al,-0x3c(%ebp)
  if (err != ERR_OK) {
  80110c:	84 c0                	test   %al,%al
  80110e:	74 31                	je     801141 <lwip_accept+0xaf>
    netconn_delete(newconn);
  801110:	89 1c 24             	mov    %ebx,(%esp)
  801113:	e8 87 a5 00 00       	call   80b69f <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  801118:	0f be 55 c4          	movsbl -0x3c(%ebp),%edx
  80111c:	f7 da                	neg    %edx
  80111e:	b8 05 00 00 00       	mov    $0x5,%eax
  801123:	83 fa 0e             	cmp    $0xe,%edx
  801126:	77 07                	ja     80112f <lwip_accept+0x9d>
  801128:	8b 04 95 a0 21 81 00 	mov    0x8121a0(,%edx,4),%eax
  80112f:	89 47 10             	mov    %eax,0x10(%edi)
  801132:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  801137:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80113c:	e9 0f 01 00 00       	jmp    801250 <lwip_accept+0x1be>
  }

  memset(&sin, 0, sizeof(sin));
  801141:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  801148:	00 
  801149:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801150:	00 
  801151:	8d 45 d0             	lea    -0x30(%ebp),%eax
  801154:	89 04 24             	mov    %eax,(%esp)
  801157:	e8 ab e7 00 00       	call   80f907 <memset>
  sin.sin_len = sizeof(sin);
  80115c:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  801160:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  801164:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  801168:	89 04 24             	mov    %eax,(%esp)
  80116b:	e8 36 6c 00 00       	call   807da6 <htons>
  801170:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  801174:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801177:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  80117a:	83 3e 10             	cmpl   $0x10,(%esi)
  80117d:	76 06                	jbe    801185 <lwip_accept+0xf3>
    *addrlen = sizeof(sin);
  80117f:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(addr, &sin, *addrlen);
  801185:	8b 06                	mov    (%esi),%eax
  801187:	89 44 24 08          	mov    %eax,0x8(%esp)
  80118b:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80118e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801192:	8b 45 0c             	mov    0xc(%ebp),%eax
  801195:	89 04 24             	mov    %eax,(%esp)
  801198:	e8 1f e8 00 00       	call   80f9bc <memcpy>

  newsock = alloc_socket(newconn);
  80119d:	89 d8                	mov    %ebx,%eax
  80119f:	e8 87 fb ff ff       	call   800d2b <alloc_socket>
  8011a4:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  8011a6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8011a9:	75 23                	jne    8011ce <lwip_accept+0x13c>
    netconn_delete(newconn);
  8011ab:	89 1c 24             	mov    %ebx,(%esp)
  8011ae:	e8 ec a4 00 00       	call   80b69f <netconn_delete>
    sock_set_errno(sock, ENFILE);
  8011b3:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  8011ba:	c7 05 00 c2 b3 00 17 	movl   $0x17,0xb3c200
  8011c1:	00 00 00 
    return -1;
  8011c4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8011c9:	e9 82 00 00 00       	jmp    801250 <lwip_accept+0x1be>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8011ce:	83 f8 1f             	cmp    $0x1f,%eax
  8011d1:	76 1c                	jbe    8011ef <lwip_accept+0x15d>
  8011d3:	c7 44 24 08 11 21 81 	movl   $0x812111,0x8(%esp)
  8011da:	00 
  8011db:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8011e2:	00 
  8011e3:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  8011ea:	e8 ab de 00 00       	call   80f09a <_panic>
  newconn->callback = event_callback;
  8011ef:	c7 43 2c a2 0b 80 00 	movl   $0x800ba2,0x2c(%ebx)
  nsock = &sockets[newsock];
  8011f6:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8011f9:	8d 04 85 80 60 81 00 	lea    0x816080(,%eax,4),%eax
  801200:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  801203:	a1 64 60 81 00       	mov    0x816064,%eax
  801208:	89 04 24             	mov    %eax,(%esp)
  80120b:	e8 48 45 00 00       	call   805758 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  801210:	8b 4d c4             	mov    -0x3c(%ebp),%ecx
  801213:	0f b7 41 0a          	movzwl 0xa(%ecx),%eax
  801217:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
  80121b:	83 e8 01             	sub    $0x1,%eax
  80121e:	66 2b 43 1c          	sub    0x1c(%ebx),%ax
  801222:	66 89 41 0a          	mov    %ax,0xa(%ecx)
  newconn->socket = newsock;
  801226:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  801229:	a1 64 60 81 00       	mov    0x816064,%eax
  80122e:	89 04 24             	mov    %eax,(%esp)
  801231:	e8 fa 96 00 00       	call   80a930 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  801236:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  80123d:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801244:	00 00 00 
  return newsock;
  801247:	89 f0                	mov    %esi,%eax
  801249:	eb 05                	jmp    801250 <lwip_accept+0x1be>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  80124b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  801250:	83 c4 4c             	add    $0x4c,%esp
  801253:	5b                   	pop    %ebx
  801254:	5e                   	pop    %esi
  801255:	5f                   	pop    %edi
  801256:	5d                   	pop    %ebp
  801257:	c3                   	ret    

00801258 <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  801258:	55                   	push   %ebp
  801259:	89 e5                	mov    %esp,%ebp
  80125b:	56                   	push   %esi
  80125c:	53                   	push   %ebx
  80125d:	83 ec 20             	sub    $0x20,%esp
  801260:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  801263:	8b 45 08             	mov    0x8(%ebp),%eax
  801266:	e8 05 f7 ff ff       	call   800970 <get_socket>
  80126b:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80126d:	85 c0                	test   %eax,%eax
  80126f:	0f 84 94 00 00 00    	je     801309 <lwip_bind+0xb1>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  801275:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  801279:	75 06                	jne    801281 <lwip_bind+0x29>
  80127b:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80127f:	74 1c                	je     80129d <lwip_bind+0x45>
  801281:	c7 44 24 08 26 21 81 	movl   $0x812126,0x8(%esp)
  801288:	00 
  801289:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  801290:	00 
  801291:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  801298:	e8 fd dd 00 00       	call   80f09a <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  80129d:	8b 46 04             	mov    0x4(%esi),%eax
  8012a0:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  8012a3:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8012a7:	89 04 24             	mov    %eax,(%esp)
  8012aa:	e8 04 6b 00 00       	call   807db3 <ntohs>
  8012af:	0f b7 c0             	movzwl %ax,%eax
  8012b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8012b6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8012b9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8012bd:	8b 03                	mov    (%ebx),%eax
  8012bf:	89 04 24             	mov    %eax,(%esp)
  8012c2:	e8 dd a4 00 00       	call   80b7a4 <netconn_bind>

  if (err != ERR_OK) {
  8012c7:	84 c0                	test   %al,%al
  8012c9:	74 26                	je     8012f1 <lwip_bind+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8012cb:	0f be c0             	movsbl %al,%eax
  8012ce:	f7 d8                	neg    %eax
  8012d0:	ba 05 00 00 00       	mov    $0x5,%edx
  8012d5:	83 f8 0e             	cmp    $0xe,%eax
  8012d8:	77 07                	ja     8012e1 <lwip_bind+0x89>
  8012da:	8b 14 85 a0 21 81 00 	mov    0x8121a0(,%eax,4),%edx
  8012e1:	89 53 10             	mov    %edx,0x10(%ebx)
  8012e4:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  8012ea:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8012ef:	eb 1d                	jmp    80130e <lwip_bind+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8012f1:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8012f8:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8012ff:	00 00 00 
  return 0;
  801302:	b8 00 00 00 00       	mov    $0x0,%eax
  801307:	eb 05                	jmp    80130e <lwip_bind+0xb6>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801309:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80130e:	83 c4 20             	add    $0x20,%esp
  801311:	5b                   	pop    %ebx
  801312:	5e                   	pop    %esi
  801313:	5d                   	pop    %ebp
  801314:	c3                   	ret    

00801315 <lwip_close>:

int
lwip_close(int s)
{
  801315:	55                   	push   %ebp
  801316:	89 e5                	mov    %esp,%ebp
  801318:	53                   	push   %ebx
  801319:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  80131c:	8b 45 08             	mov    0x8(%ebp),%eax
  80131f:	e8 4c f6 ff ff       	call   800970 <get_socket>
  801324:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  801326:	85 c0                	test   %eax,%eax
  801328:	74 5e                	je     801388 <lwip_close+0x73>
    return -1;
  }

  netconn_delete(sock->conn);
  80132a:	8b 00                	mov    (%eax),%eax
  80132c:	89 04 24             	mov    %eax,(%esp)
  80132f:	e8 6b a3 00 00       	call   80b69f <netconn_delete>

  sys_sem_wait(socksem);
  801334:	a1 64 60 81 00       	mov    0x816064,%eax
  801339:	89 04 24             	mov    %eax,(%esp)
  80133c:	e8 17 44 00 00       	call   805758 <sys_sem_wait>
  if (sock->lastdata) {
  801341:	8b 43 04             	mov    0x4(%ebx),%eax
  801344:	85 c0                	test   %eax,%eax
  801346:	74 08                	je     801350 <lwip_close+0x3b>
    netbuf_delete(sock->lastdata);
  801348:	89 04 24             	mov    %eax,(%esp)
  80134b:	e8 2c 15 00 00       	call   80287c <netbuf_delete>
  }
  sock->lastdata   = NULL;
  801350:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  801357:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  80135d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  801363:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  80136a:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801371:	00 00 00 
  sys_sem_signal(socksem);
  801374:	a1 64 60 81 00       	mov    0x816064,%eax
  801379:	89 04 24             	mov    %eax,(%esp)
  80137c:	e8 af 95 00 00       	call   80a930 <sys_sem_signal>
  return 0;
  801381:	b8 00 00 00 00       	mov    $0x0,%eax
  801386:	eb 05                	jmp    80138d <lwip_close+0x78>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
    return -1;
  801388:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  sock->lastoffset = 0;
  sock->conn       = NULL;
  sock_set_errno(sock, 0);
  sys_sem_signal(socksem);
  return 0;
}
  80138d:	83 c4 14             	add    $0x14,%esp
  801390:	5b                   	pop    %ebx
  801391:	5d                   	pop    %ebp
  801392:	c3                   	ret    

00801393 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  801393:	55                   	push   %ebp
  801394:	89 e5                	mov    %esp,%ebp
  801396:	56                   	push   %esi
  801397:	53                   	push   %ebx
  801398:	83 ec 20             	sub    $0x20,%esp
  80139b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  80139e:	8b 45 08             	mov    0x8(%ebp),%eax
  8013a1:	e8 ca f5 ff ff       	call   800970 <get_socket>
  8013a6:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8013a8:	85 c0                	test   %eax,%eax
  8013aa:	0f 84 94 00 00 00    	je     801444 <lwip_connect+0xb1>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  8013b0:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  8013b4:	75 06                	jne    8013bc <lwip_connect+0x29>
  8013b6:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  8013ba:	74 1c                	je     8013d8 <lwip_connect+0x45>
  8013bc:	c7 44 24 08 41 21 81 	movl   $0x812141,0x8(%esp)
  8013c3:	00 
  8013c4:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  8013cb:	00 
  8013cc:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  8013d3:	e8 c2 dc 00 00       	call   80f09a <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8013d8:	8b 46 04             	mov    0x4(%esi),%eax
  8013db:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8013de:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8013e2:	89 04 24             	mov    %eax,(%esp)
  8013e5:	e8 c9 69 00 00       	call   807db3 <ntohs>
  8013ea:	0f b7 c0             	movzwl %ax,%eax
  8013ed:	89 44 24 08          	mov    %eax,0x8(%esp)
  8013f1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8013f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8013f8:	8b 03                	mov    (%ebx),%eax
  8013fa:	89 04 24             	mov    %eax,(%esp)
  8013fd:	e8 f8 a3 00 00       	call   80b7fa <netconn_connect>
  }

  if (err != ERR_OK) {
  801402:	84 c0                	test   %al,%al
  801404:	74 26                	je     80142c <lwip_connect+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801406:	0f be c0             	movsbl %al,%eax
  801409:	f7 d8                	neg    %eax
  80140b:	ba 05 00 00 00       	mov    $0x5,%edx
  801410:	83 f8 0e             	cmp    $0xe,%eax
  801413:	77 07                	ja     80141c <lwip_connect+0x89>
  801415:	8b 14 85 a0 21 81 00 	mov    0x8121a0(,%eax,4),%edx
  80141c:	89 53 10             	mov    %edx,0x10(%ebx)
  80141f:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  801425:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80142a:	eb 1d                	jmp    801449 <lwip_connect+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80142c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  801433:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  80143a:	00 00 00 
  return 0;
  80143d:	b8 00 00 00 00       	mov    $0x0,%eax
  801442:	eb 05                	jmp    801449 <lwip_connect+0xb6>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  801444:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  801449:	83 c4 20             	add    $0x20,%esp
  80144c:	5b                   	pop    %ebx
  80144d:	5e                   	pop    %esi
  80144e:	5d                   	pop    %ebp
  80144f:	c3                   	ret    

00801450 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  801450:	55                   	push   %ebp
  801451:	89 e5                	mov    %esp,%ebp
  801453:	56                   	push   %esi
  801454:	53                   	push   %ebx
  801455:	83 ec 10             	sub    $0x10,%esp
  801458:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80145b:	8b 45 08             	mov    0x8(%ebp),%eax
  80145e:	e8 0d f5 ff ff       	call   800970 <get_socket>
  801463:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801465:	85 c0                	test   %eax,%eax
  801467:	74 68                	je     8014d1 <lwip_listen+0x81>
  801469:	85 f6                	test   %esi,%esi
  80146b:	b8 00 00 00 00       	mov    $0x0,%eax
  801470:	0f 48 f0             	cmovs  %eax,%esi
  801473:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  801479:	b0 ff                	mov    $0xff,%al
  80147b:	0f 4e c6             	cmovle %esi,%eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80147e:	0f b6 f0             	movzbl %al,%esi
  801481:	89 74 24 04          	mov    %esi,0x4(%esp)
  801485:	8b 03                	mov    (%ebx),%eax
  801487:	89 04 24             	mov    %eax,(%esp)
  80148a:	e8 0a a4 00 00       	call   80b899 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80148f:	84 c0                	test   %al,%al
  801491:	74 26                	je     8014b9 <lwip_listen+0x69>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  801493:	0f be c0             	movsbl %al,%eax
  801496:	f7 d8                	neg    %eax
  801498:	ba 05 00 00 00       	mov    $0x5,%edx
  80149d:	83 f8 0e             	cmp    $0xe,%eax
  8014a0:	77 07                	ja     8014a9 <lwip_listen+0x59>
  8014a2:	8b 14 85 a0 21 81 00 	mov    0x8121a0(,%eax,4),%edx
  8014a9:	89 53 10             	mov    %edx,0x10(%ebx)
  8014ac:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
    return -1;
  8014b2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8014b7:	eb 1d                	jmp    8014d6 <lwip_listen+0x86>
  }

  sock_set_errno(sock, 0);
  8014b9:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8014c0:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8014c7:	00 00 00 
  return 0;
  8014ca:	b8 00 00 00 00       	mov    $0x0,%eax
  8014cf:	eb 05                	jmp    8014d6 <lwip_listen+0x86>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
    return -1;
  8014d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  }

  sock_set_errno(sock, 0);
  return 0;
}
  8014d6:	83 c4 10             	add    $0x10,%esp
  8014d9:	5b                   	pop    %ebx
  8014da:	5e                   	pop    %esi
  8014db:	5d                   	pop    %ebp
  8014dc:	c3                   	ret    

008014dd <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8014dd:	55                   	push   %ebp
  8014de:	89 e5                	mov    %esp,%ebp
  8014e0:	57                   	push   %edi
  8014e1:	56                   	push   %esi
  8014e2:	53                   	push   %ebx
  8014e3:	83 ec 5c             	sub    $0x5c,%esp
  8014e6:	8b 5d 14             	mov    0x14(%ebp),%ebx
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8014e9:	8b 45 08             	mov    0x8(%ebp),%eax
  8014ec:	e8 7f f4 ff ff       	call   800970 <get_socket>
  8014f1:	89 c7                	mov    %eax,%edi
  if (!sock)
  8014f3:	85 c0                	test   %eax,%eax
  8014f5:	0f 84 14 02 00 00    	je     80170f <lwip_recvfrom+0x232>
  8014fb:	66 c7 45 c4 00 00    	movw   $0x0,-0x3c(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801501:	89 d8                	mov    %ebx,%eax
  801503:	83 e0 08             	and    $0x8,%eax
  801506:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801509:	83 e3 01             	and    $0x1,%ebx
  80150c:	89 5d b8             	mov    %ebx,-0x48(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  80150f:	8b 77 04             	mov    0x4(%edi),%esi
  801512:	85 f6                	test   %esi,%esi
  801514:	75 7d                	jne    801593 <lwip_recvfrom+0xb6>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  801516:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  80151a:	75 06                	jne    801522 <lwip_recvfrom+0x45>
  80151c:	f6 47 0f 08          	testb  $0x8,0xf(%edi)
  801520:	74 22                	je     801544 <lwip_recvfrom+0x67>
  801522:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801527:	75 1b                	jne    801544 <lwip_recvfrom+0x67>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  801529:	c7 47 10 0b 00 00 00 	movl   $0xb,0x10(%edi)
  801530:	c7 05 00 c2 b3 00 0b 	movl   $0xb,0xb3c200
  801537:	00 00 00 
        return -1;
  80153a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80153f:	e9 d0 01 00 00       	jmp    801714 <lwip_recvfrom+0x237>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  801544:	8b 07                	mov    (%edi),%eax
  801546:	89 04 24             	mov    %eax,(%esp)
  801549:	e8 1e a4 00 00       	call   80b96c <netconn_recv>
  80154e:	89 c6                	mov    %eax,%esi
  801550:	89 47 04             	mov    %eax,0x4(%edi)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  801553:	85 c0                	test   %eax,%eax
  801555:	75 3c                	jne    801593 <lwip_recvfrom+0xb6>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  801557:	8b 17                	mov    (%edi),%edx
  801559:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  80155d:	74 0b                	je     80156a <lwip_recvfrom+0x8d>
  80155f:	b8 6e 00 00 00       	mov    $0x6e,%eax
  801564:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  801568:	74 17                	je     801581 <lwip_recvfrom+0xa4>
  80156a:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  80156e:	f7 da                	neg    %edx
  801570:	b8 05 00 00 00       	mov    $0x5,%eax
  801575:	83 fa 0e             	cmp    $0xe,%edx
  801578:	77 07                	ja     801581 <lwip_recvfrom+0xa4>
  80157a:	8b 04 95 a0 21 81 00 	mov    0x8121a0(,%edx,4),%eax
  801581:	89 47 10             	mov    %eax,0x10(%edi)
  801584:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
        return 0;
  801589:	b8 00 00 00 00       	mov    $0x0,%eax
  80158e:	e9 81 01 00 00       	jmp    801714 <lwip_recvfrom+0x237>
      }
    }

    buflen = netbuf_len(buf);
  801593:	8b 06                	mov    (%esi),%eax
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  801595:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  801599:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  80159d:	29 d3                	sub    %edx,%ebx

    if (len > buflen) {
  80159f:	0f b7 cb             	movzwl %bx,%ecx
  8015a2:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  8015a5:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  8015a8:	66 0f 4e 5d 10       	cmovle 0x10(%ebp),%bx
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  8015ad:	0f b7 cb             	movzwl %bx,%ecx
  8015b0:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  8015b3:	0f b7 d2             	movzwl %dx,%edx
  8015b6:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8015ba:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8015be:	0f b7 55 c4          	movzwl -0x3c(%ebp),%edx
  8015c2:	03 55 0c             	add    0xc(%ebp),%edx
  8015c5:	89 54 24 04          	mov    %edx,0x4(%esp)
  8015c9:	89 04 24             	mov    %eax,(%esp)
  8015cc:	e8 fe 3f 00 00       	call   8055cf <pbuf_copy_partial>

    off += copylen;
  8015d1:	66 01 5d c4          	add    %bx,-0x3c(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8015d5:	8b 07                	mov    (%edi),%eax
  8015d7:	89 04 24             	mov    %eax,(%esp)
  8015da:	e8 fd a0 00 00       	call   80b6dc <netconn_type>
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  8015df:	c6 45 c7 01          	movb   $0x1,-0x39(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8015e3:	83 f8 10             	cmp    $0x10,%eax
  8015e6:	75 1d                	jne    801605 <lwip_recvfrom+0x128>
      len -= copylen;
  8015e8:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8015eb:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8015ee:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8015f2:	7e 11                	jle    801605 <lwip_recvfrom+0x128>
  8015f4:	8b 06                	mov    (%esi),%eax
  8015f6:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8015fa:	75 09                	jne    801605 <lwip_recvfrom+0x128>
  8015fc:	66 83 7f 0a 00       	cmpw   $0x0,0xa(%edi)
  801601:	0f 94 45 c7          	sete   -0x39(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  801605:	83 7d b8 00          	cmpl   $0x0,-0x48(%ebp)
  801609:	75 39                	jne    801644 <lwip_recvfrom+0x167>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  80160b:	8b 07                	mov    (%edi),%eax
  80160d:	83 38 10             	cmpl   $0x10,(%eax)
  801610:	75 13                	jne    801625 <lwip_recvfrom+0x148>
  801612:	8b 45 bc             	mov    -0x44(%ebp),%eax
  801615:	2b 45 c0             	sub    -0x40(%ebp),%eax
  801618:	85 c0                	test   %eax,%eax
  80161a:	7e 09                	jle    801625 <lwip_recvfrom+0x148>
        sock->lastdata = buf;
  80161c:	89 77 04             	mov    %esi,0x4(%edi)
        sock->lastoffset += copylen;
  80161f:	66 01 5f 08          	add    %bx,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  801623:	eb 15                	jmp    80163a <lwip_recvfrom+0x15d>
      } else {
        sock->lastdata = NULL;
  801625:	c7 47 04 00 00 00 00 	movl   $0x0,0x4(%edi)
        sock->lastoffset = 0;
  80162c:	66 c7 47 08 00 00    	movw   $0x0,0x8(%edi)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  801632:	89 34 24             	mov    %esi,(%esp)
  801635:	e8 42 12 00 00       	call   80287c <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  80163a:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
  80163e:	0f 84 cb fe ff ff    	je     80150f <lwip_recvfrom+0x32>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  801644:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801648:	0f 84 aa 00 00 00    	je     8016f8 <lwip_recvfrom+0x21b>
  80164e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801652:	0f 84 a0 00 00 00    	je     8016f8 <lwip_recvfrom+0x21b>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  801658:	8b 07                	mov    (%edi),%eax
  80165a:	89 04 24             	mov    %eax,(%esp)
  80165d:	e8 7a a0 00 00       	call   80b6dc <netconn_type>
  801662:	83 f8 10             	cmp    $0x10,%eax
  801665:	75 25                	jne    80168c <lwip_recvfrom+0x1af>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
      netconn_getaddr(sock->conn, addr, &port, 0);
  801667:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80166e:	00 
  80166f:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  801672:	89 44 24 08          	mov    %eax,0x8(%esp)
  801676:	8d 45 d8             	lea    -0x28(%ebp),%eax
  801679:	89 44 24 04          	mov    %eax,0x4(%esp)
  80167d:	8b 07                	mov    (%edi),%eax
  80167f:	89 04 24             	mov    %eax,(%esp)
  801682:	e8 82 a0 00 00       	call   80b709 <netconn_getaddr>
  /* Check to see from where the data was.*/
  if (from && fromlen) {
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  801687:	8d 5d d8             	lea    -0x28(%ebp),%ebx
  80168a:	eb 0b                	jmp    801697 <lwip_recvfrom+0x1ba>
      netconn_getaddr(sock->conn, addr, &port, 0);
    } else {
      addr = netbuf_fromaddr(buf);
  80168c:	8b 5e 08             	mov    0x8(%esi),%ebx
      port = netbuf_fromport(buf);
  80168f:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  801693:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  801697:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  80169e:	00 
  80169f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8016a6:	00 
  8016a7:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8016aa:	89 04 24             	mov    %eax,(%esp)
  8016ad:	e8 55 e2 00 00       	call   80f907 <memset>
    sin.sin_len = sizeof(sin);
  8016b2:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  8016b6:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8016ba:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8016be:	89 04 24             	mov    %eax,(%esp)
  8016c1:	e8 e0 66 00 00       	call   807da6 <htons>
  8016c6:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8016ca:	8b 03                	mov    (%ebx),%eax
  8016cc:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8016cf:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8016d2:	83 38 10             	cmpl   $0x10,(%eax)
  8016d5:	76 06                	jbe    8016dd <lwip_recvfrom+0x200>
      *fromlen = sizeof(sin);
  8016d7:	c7 00 10 00 00 00    	movl   $0x10,(%eax)

    SMEMCPY(from, &sin, *fromlen);
  8016dd:	8b 45 1c             	mov    0x1c(%ebp),%eax
  8016e0:	8b 00                	mov    (%eax),%eax
  8016e2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8016e6:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8016e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8016ed:	8b 45 18             	mov    0x18(%ebp),%eax
  8016f0:	89 04 24             	mov    %eax,(%esp)
  8016f3:	e8 c4 e2 00 00       	call   80f9bc <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8016f8:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  8016ff:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801706:	00 00 00 
  return off;
  801709:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  80170d:	eb 05                	jmp    801714 <lwip_recvfrom+0x237>
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;
  80170f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  return off;
}
  801714:	83 c4 5c             	add    $0x5c,%esp
  801717:	5b                   	pop    %ebx
  801718:	5e                   	pop    %esi
  801719:	5f                   	pop    %edi
  80171a:	5d                   	pop    %ebp
  80171b:	c3                   	ret    

0080171c <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  80171c:	55                   	push   %ebp
  80171d:	89 e5                	mov    %esp,%ebp
  80171f:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  801722:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801729:	00 
  80172a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801731:	00 
  801732:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801739:	00 
  80173a:	8b 45 10             	mov    0x10(%ebp),%eax
  80173d:	89 44 24 08          	mov    %eax,0x8(%esp)
  801741:	8b 45 0c             	mov    0xc(%ebp),%eax
  801744:	89 44 24 04          	mov    %eax,0x4(%esp)
  801748:	8b 45 08             	mov    0x8(%ebp),%eax
  80174b:	89 04 24             	mov    %eax,(%esp)
  80174e:	e8 8a fd ff ff       	call   8014dd <lwip_recvfrom>
}
  801753:	c9                   	leave  
  801754:	c3                   	ret    

00801755 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  801755:	55                   	push   %ebp
  801756:	89 e5                	mov    %esp,%ebp
  801758:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  80175b:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  801762:	00 
  801763:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80176a:	00 
  80176b:	8b 45 14             	mov    0x14(%ebp),%eax
  80176e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801772:	8b 45 10             	mov    0x10(%ebp),%eax
  801775:	89 44 24 08          	mov    %eax,0x8(%esp)
  801779:	8b 45 0c             	mov    0xc(%ebp),%eax
  80177c:	89 44 24 04          	mov    %eax,0x4(%esp)
  801780:	8b 45 08             	mov    0x8(%ebp),%eax
  801783:	89 04 24             	mov    %eax,(%esp)
  801786:	e8 52 fd ff ff       	call   8014dd <lwip_recvfrom>
}
  80178b:	c9                   	leave  
  80178c:	c3                   	ret    

0080178d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80178d:	55                   	push   %ebp
  80178e:	89 e5                	mov    %esp,%ebp
  801790:	57                   	push   %edi
  801791:	56                   	push   %esi
  801792:	53                   	push   %ebx
  801793:	83 ec 3c             	sub    $0x3c,%esp
  801796:	8b 7d 10             	mov    0x10(%ebp),%edi
  801799:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80179c:	8b 45 08             	mov    0x8(%ebp),%eax
  80179f:	e8 cc f1 ff ff       	call   800970 <get_socket>
  8017a4:	89 c3                	mov    %eax,%ebx
  if (!sock)
  8017a6:	85 c0                	test   %eax,%eax
  8017a8:	0f 84 32 01 00 00    	je     8018e0 <lwip_sendto+0x153>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  8017ae:	8b 00                	mov    (%eax),%eax
  8017b0:	83 38 10             	cmpl   $0x10,(%eax)
  8017b3:	75 22                	jne    8017d7 <lwip_sendto+0x4a>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  8017b5:	8b 45 14             	mov    0x14(%ebp),%eax
  8017b8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8017bc:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8017c0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8017c3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8017c7:	8b 45 08             	mov    0x8(%ebp),%eax
  8017ca:	89 04 24             	mov    %eax,(%esp)
  8017cd:	e8 1b 01 00 00       	call   8018ed <lwip_send>
  8017d2:	e9 0e 01 00 00       	jmp    8018e5 <lwip_sendto+0x158>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  8017d7:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  8017dd:	76 1c                	jbe    8017fb <lwip_sendto+0x6e>
  8017df:	c7 44 24 08 7c 21 81 	movl   $0x81217c,0x8(%esp)
  8017e6:	00 
  8017e7:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  8017ee:	00 
  8017ef:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  8017f6:	e8 9f d8 00 00       	call   80f09a <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  8017fb:	85 f6                	test   %esi,%esi
  8017fd:	0f 95 c0             	setne  %al
  801800:	75 06                	jne    801808 <lwip_sendto+0x7b>
  801802:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  801806:	74 28                	je     801830 <lwip_sendto+0xa3>
  801808:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  80180c:	75 06                	jne    801814 <lwip_sendto+0x87>
  80180e:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  801812:	74 1c                	je     801830 <lwip_sendto+0xa3>
  801814:	c7 44 24 08 5f 21 81 	movl   $0x81215f,0x8(%esp)
  80181b:	00 
  80181c:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  801823:	00 
  801824:	c7 04 24 ee 20 81 00 	movl   $0x8120ee,(%esp)
  80182b:	e8 6a d8 00 00       	call   80f09a <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  801830:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  801837:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  80183e:	84 c0                	test   %al,%al
  801840:	74 1e                	je     801860 <lwip_sendto+0xd3>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  801842:	8b 46 04             	mov    0x4(%esi),%eax
  801845:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  801848:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80184c:	89 04 24             	mov    %eax,(%esp)
  80184f:	e8 5f 65 00 00       	call   807db3 <ntohs>
    buf.addr         = &remote_addr;
  801854:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801857:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  80185a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80185e:	eb 14                	jmp    801874 <lwip_sendto+0xe7>
  } else {
    remote_addr.addr = 0;
  801860:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  801867:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  80186e:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  801874:	0f b7 c7             	movzwl %di,%eax
  801877:	89 44 24 08          	mov    %eax,0x8(%esp)
  80187b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80187e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801882:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801885:	89 04 24             	mov    %eax,(%esp)
  801888:	e8 0c 11 00 00       	call   802999 <netbuf_ref>
  80188d:	0f be f0             	movsbl %al,%esi
  801890:	85 f6                	test   %esi,%esi
  801892:	75 14                	jne    8018a8 <lwip_sendto+0x11b>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  801894:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  801897:	89 44 24 04          	mov    %eax,0x4(%esp)
  80189b:	8b 03                	mov    (%ebx),%eax
  80189d:	89 04 24             	mov    %eax,(%esp)
  8018a0:	e8 6c a2 00 00       	call   80bb11 <netconn_send>
  8018a5:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  8018a8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8018ab:	85 c0                	test   %eax,%eax
  8018ad:	74 08                	je     8018b7 <lwip_sendto+0x12a>
    pbuf_free(buf.p);
  8018af:	89 04 24             	mov    %eax,(%esp)
  8018b2:	e8 6d 35 00 00       	call   804e24 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  8018b7:	89 f2                	mov    %esi,%edx
  8018b9:	f7 da                	neg    %edx
  8018bb:	b8 05 00 00 00       	mov    $0x5,%eax
  8018c0:	83 fa 0e             	cmp    $0xe,%edx
  8018c3:	77 07                	ja     8018cc <lwip_sendto+0x13f>
  8018c5:	8b 04 95 a0 21 81 00 	mov    0x8121a0(,%edx,4),%eax
  8018cc:	89 43 10             	mov    %eax,0x10(%ebx)
  8018cf:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
  return (err==ERR_OK?size:-1);
  8018d4:	85 f6                	test   %esi,%esi
  8018d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8018db:	0f 44 c7             	cmove  %edi,%eax
  8018de:	eb 05                	jmp    8018e5 <lwip_sendto+0x158>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  8018e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  8018e5:	83 c4 3c             	add    $0x3c,%esp
  8018e8:	5b                   	pop    %ebx
  8018e9:	5e                   	pop    %esi
  8018ea:	5f                   	pop    %edi
  8018eb:	5d                   	pop    %ebp
  8018ec:	c3                   	ret    

008018ed <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  8018ed:	55                   	push   %ebp
  8018ee:	89 e5                	mov    %esp,%ebp
  8018f0:	57                   	push   %edi
  8018f1:	56                   	push   %esi
  8018f2:	53                   	push   %ebx
  8018f3:	83 ec 2c             	sub    $0x2c,%esp
  8018f6:	8b 7d 08             	mov    0x8(%ebp),%edi
  8018f9:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  8018fc:	89 f8                	mov    %edi,%eax
  8018fe:	e8 6d f0 ff ff       	call   800970 <get_socket>
  801903:	89 c3                	mov    %eax,%ebx
  if (!sock)
  801905:	85 c0                	test   %eax,%eax
  801907:	0f 84 86 00 00 00    	je     801993 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  80190d:	8b 00                	mov    (%eax),%eax
  80190f:	83 38 10             	cmpl   $0x10,(%eax)
  801912:	74 2c                	je     801940 <lwip_send+0x53>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  801914:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80191b:	00 
  80191c:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  801923:	00 
  801924:	8b 45 14             	mov    0x14(%ebp),%eax
  801927:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80192b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80192f:	8b 45 0c             	mov    0xc(%ebp),%eax
  801932:	89 44 24 04          	mov    %eax,0x4(%esp)
  801936:	89 3c 24             	mov    %edi,(%esp)
  801939:	e8 4f fe ff ff       	call   80178d <lwip_sendto>
  80193e:	eb 58                	jmp    801998 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  801940:	8b 55 14             	mov    0x14(%ebp),%edx
  801943:	83 e2 10             	and    $0x10,%edx
  801946:	83 fa 01             	cmp    $0x1,%edx
  801949:	19 d2                	sbb    %edx,%edx
  80194b:	83 e2 fe             	and    $0xfffffffe,%edx
  80194e:	83 c2 03             	add    $0x3,%edx
  801951:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801955:	89 74 24 08          	mov    %esi,0x8(%esp)
  801959:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80195c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801960:	89 04 24             	mov    %eax,(%esp)
  801963:	e8 2a a2 00 00       	call   80bb92 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  801968:	0f be c8             	movsbl %al,%ecx
  80196b:	f7 d9                	neg    %ecx
  80196d:	ba 05 00 00 00       	mov    $0x5,%edx
  801972:	83 f9 0e             	cmp    $0xe,%ecx
  801975:	77 07                	ja     80197e <lwip_send+0x91>
  801977:	8b 14 8d a0 21 81 00 	mov    0x8121a0(,%ecx,4),%edx
  80197e:	89 53 10             	mov    %edx,0x10(%ebx)
  801981:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
  return (err==ERR_OK?size:-1);
  801987:	84 c0                	test   %al,%al
  801989:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80198e:	0f 44 c6             	cmove  %esi,%eax
  801991:	eb 05                	jmp    801998 <lwip_send+0xab>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  801993:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  801998:	83 c4 2c             	add    $0x2c,%esp
  80199b:	5b                   	pop    %ebx
  80199c:	5e                   	pop    %esi
  80199d:	5f                   	pop    %edi
  80199e:	5d                   	pop    %ebp
  80199f:	c3                   	ret    

008019a0 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  8019a0:	55                   	push   %ebp
  8019a1:	89 e5                	mov    %esp,%ebp
  8019a3:	53                   	push   %ebx
  8019a4:	83 ec 14             	sub    $0x14,%esp
  8019a7:	8b 45 0c             	mov    0xc(%ebp),%eax
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  8019aa:	83 f8 02             	cmp    $0x2,%eax
  8019ad:	74 2c                	je     8019db <lwip_socket+0x3b>
  8019af:	83 f8 03             	cmp    $0x3,%eax
  8019b2:	74 07                	je     8019bb <lwip_socket+0x1b>
  8019b4:	83 f8 01             	cmp    $0x1,%eax
  8019b7:	75 6e                	jne    801a27 <lwip_socket+0x87>
  8019b9:	eb 4c                	jmp    801a07 <lwip_socket+0x67>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  8019bb:	c7 44 24 08 a2 0b 80 	movl   $0x800ba2,0x8(%esp)
  8019c2:	00 
  8019c3:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  8019c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8019cb:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  8019d2:	e8 be 9b 00 00       	call   80b595 <netconn_new_with_proto_and_callback>
  8019d7:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8019d9:	eb 5d                	jmp    801a38 <lwip_socket+0x98>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  8019db:	81 7d 10 88 00 00 00 	cmpl   $0x88,0x10(%ebp)
  8019e2:	0f 94 c0             	sete   %al
  8019e5:	0f b6 c0             	movzbl %al,%eax
  8019e8:	83 c0 20             	add    $0x20,%eax
  8019eb:	c7 44 24 08 a2 0b 80 	movl   $0x800ba2,0x8(%esp)
  8019f2:	00 
  8019f3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8019fa:	00 
  8019fb:	89 04 24             	mov    %eax,(%esp)
  8019fe:	e8 92 9b 00 00       	call   80b595 <netconn_new_with_proto_and_callback>
  801a03:	89 c3                	mov    %eax,%ebx
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801a05:	eb 31                	jmp    801a38 <lwip_socket+0x98>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  801a07:	c7 44 24 08 a2 0b 80 	movl   $0x800ba2,0x8(%esp)
  801a0e:	00 
  801a0f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801a16:	00 
  801a17:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  801a1e:	e8 72 9b 00 00       	call   80b595 <netconn_new_with_proto_and_callback>
  801a23:	89 c3                	mov    %eax,%ebx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  801a25:	eb 11                	jmp    801a38 <lwip_socket+0x98>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  801a27:	c7 05 00 c2 b3 00 16 	movl   $0x16,0xb3c200
  801a2e:	00 00 00 
    return -1;
  801a31:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a36:	eb 47                	jmp    801a7f <lwip_socket+0xdf>
  }

  if (!conn) {
  801a38:	85 db                	test   %ebx,%ebx
  801a3a:	75 11                	jne    801a4d <lwip_socket+0xad>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  801a3c:	c7 05 00 c2 b3 00 69 	movl   $0x69,0xb3c200
  801a43:	00 00 00 
    return -1;
  801a46:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a4b:	eb 32                	jmp    801a7f <lwip_socket+0xdf>
  }

  i = alloc_socket(conn);
  801a4d:	89 d8                	mov    %ebx,%eax
  801a4f:	e8 d7 f2 ff ff       	call   800d2b <alloc_socket>

  if (i == -1) {
  801a54:	83 f8 ff             	cmp    $0xffffffff,%eax
  801a57:	75 19                	jne    801a72 <lwip_socket+0xd2>
    netconn_delete(conn);
  801a59:	89 1c 24             	mov    %ebx,(%esp)
  801a5c:	e8 3e 9c 00 00       	call   80b69f <netconn_delete>
    set_errno(ENFILE);
  801a61:	c7 05 00 c2 b3 00 17 	movl   $0x17,0xb3c200
  801a68:	00 00 00 
    return -1;
  801a6b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801a70:	eb 0d                	jmp    801a7f <lwip_socket+0xdf>
  }
  conn->socket = i;
  801a72:	89 43 1c             	mov    %eax,0x1c(%ebx)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  801a75:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801a7c:	00 00 00 
  return i;
}
  801a7f:	83 c4 14             	add    $0x14,%esp
  801a82:	5b                   	pop    %ebx
  801a83:	5d                   	pop    %ebp
  801a84:	c3                   	ret    

00801a85 <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  801a85:	55                   	push   %ebp
  801a86:	89 e5                	mov    %esp,%ebp
  801a88:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  801a8b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  801a92:	00 
  801a93:	8b 45 10             	mov    0x10(%ebp),%eax
  801a96:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  801a9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  801aa1:	8b 45 08             	mov    0x8(%ebp),%eax
  801aa4:	89 04 24             	mov    %eax,(%esp)
  801aa7:	e8 41 fe ff ff       	call   8018ed <lwip_send>
}
  801aac:	c9                   	leave  
  801aad:	c3                   	ret    

00801aae <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  801aae:	55                   	push   %ebp
  801aaf:	89 e5                	mov    %esp,%ebp
  801ab1:	57                   	push   %edi
  801ab2:	56                   	push   %esi
  801ab3:	53                   	push   %ebx
  801ab4:	83 ec 4c             	sub    $0x4c,%esp
  801ab7:	8b 75 0c             	mov    0xc(%ebp),%esi
  801aba:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  801abd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  801ac4:	89 75 c8             	mov    %esi,-0x38(%ebp)
  select_cb.writeset = writeset;
  801ac7:	8b 45 10             	mov    0x10(%ebp),%eax
  801aca:	89 45 cc             	mov    %eax,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  801acd:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  801ad0:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  801ad7:	a1 60 60 81 00       	mov    0x816060,%eax
  801adc:	89 04 24             	mov    %eax,(%esp)
  801adf:	e8 74 3c 00 00       	call   805758 <sys_sem_wait>

  if (readset)
  801ae4:	85 f6                	test   %esi,%esi
  801ae6:	74 07                	je     801aef <lwip_select+0x41>
    lreadset = *readset;
  801ae8:	8b 06                	mov    (%esi),%eax
  801aea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801aed:	eb 1b                	jmp    801b0a <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  801aef:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801af6:	00 
  801af7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801afe:	00 
  801aff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801b02:	89 04 24             	mov    %eax,(%esp)
  801b05:	e8 fd dd 00 00       	call   80f907 <memset>
  if (writeset)
  801b0a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801b0e:	74 0a                	je     801b1a <lwip_select+0x6c>
    lwriteset = *writeset;
  801b10:	8b 45 10             	mov    0x10(%ebp),%eax
  801b13:	8b 00                	mov    (%eax),%eax
  801b15:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801b18:	eb 1b                	jmp    801b35 <lwip_select+0x87>
  else
    FD_ZERO(&lwriteset);
  801b1a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b21:	00 
  801b22:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b29:	00 
  801b2a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801b2d:	89 04 24             	mov    %eax,(%esp)
  801b30:	e8 d2 dd 00 00       	call   80f907 <memset>
  if (exceptset)
  801b35:	85 db                	test   %ebx,%ebx
  801b37:	74 07                	je     801b40 <lwip_select+0x92>
    lexceptset = *exceptset;
  801b39:	8b 03                	mov    (%ebx),%eax
  801b3b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801b3e:	eb 1b                	jmp    801b5b <lwip_select+0xad>
  else
    FD_ZERO(&lexceptset);
  801b40:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801b47:	00 
  801b48:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801b4f:	00 
  801b50:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b53:	89 04 24             	mov    %eax,(%esp)
  801b56:	e8 ac dd 00 00       	call   80f907 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801b5b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801b5e:	89 04 24             	mov    %eax,(%esp)
  801b61:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801b64:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801b67:	8b 45 08             	mov    0x8(%ebp),%eax
  801b6a:	e8 40 ee ff ff       	call   8009af <lwip_selscan>
  801b6f:	89 c7                	mov    %eax,%edi

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  801b71:	85 c0                	test   %eax,%eax
  801b73:	0f 85 fd 01 00 00    	jne    801d76 <lwip_select+0x2c8>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  801b79:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  801b7d:	0f 84 8f 02 00 00    	je     801e12 <lwip_select+0x364>
  801b83:	8b 45 18             	mov    0x18(%ebp),%eax
  801b86:	83 38 00             	cmpl   $0x0,(%eax)
  801b89:	0f 85 25 02 00 00    	jne    801db4 <lwip_select+0x306>
  801b8f:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  801b93:	0f 85 1b 02 00 00    	jne    801db4 <lwip_select+0x306>
      sys_sem_signal(selectsem);
  801b99:	a1 60 60 81 00       	mov    0x816060,%eax
  801b9e:	89 04 24             	mov    %eax,(%esp)
  801ba1:	e8 8a 8d 00 00       	call   80a930 <sys_sem_signal>
      if (readset)
  801ba6:	85 f6                	test   %esi,%esi
  801ba8:	74 18                	je     801bc2 <lwip_select+0x114>
        FD_ZERO(readset);
  801baa:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bb1:	00 
  801bb2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801bb9:	00 
  801bba:	89 34 24             	mov    %esi,(%esp)
  801bbd:	e8 45 dd 00 00       	call   80f907 <memset>
      if (writeset)
  801bc2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801bc6:	74 1b                	je     801be3 <lwip_select+0x135>
        FD_ZERO(writeset);
  801bc8:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bcf:	00 
  801bd0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801bd7:	00 
  801bd8:	8b 45 10             	mov    0x10(%ebp),%eax
  801bdb:	89 04 24             	mov    %eax,(%esp)
  801bde:	e8 24 dd 00 00       	call   80f907 <memset>
      if (exceptset)
  801be3:	85 db                	test   %ebx,%ebx
  801be5:	74 18                	je     801bff <lwip_select+0x151>
        FD_ZERO(exceptset);
  801be7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801bee:	00 
  801bef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801bf6:	00 
  801bf7:	89 1c 24             	mov    %ebx,(%esp)
  801bfa:	e8 08 dd 00 00       	call   80f907 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  801bff:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801c06:	00 00 00 
  
      return 0;
  801c09:	b8 00 00 00 00       	mov    $0x0,%eax
  801c0e:	e9 35 02 00 00       	jmp    801e48 <lwip_select+0x39a>
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  801c13:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801c17:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c1a:	89 04 24             	mov    %eax,(%esp)
  801c1d:	e8 08 3d 00 00       	call   80592a <sys_sem_wait_timeout>
  801c22:	89 c7                	mov    %eax,%edi
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  801c24:	a1 60 60 81 00       	mov    0x816060,%eax
  801c29:	89 04 24             	mov    %eax,(%esp)
  801c2c:	e8 27 3b 00 00       	call   805758 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  801c31:	a1 68 60 81 00       	mov    0x816068,%eax
  801c36:	8d 55 c4             	lea    -0x3c(%ebp),%edx
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801c39:	89 d1                	mov    %edx,%ecx
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
  801c3b:	39 d0                	cmp    %edx,%eax
  801c3d:	75 1b                	jne    801c5a <lwip_select+0x1ac>
      select_cb_list = select_cb.next;
  801c3f:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  801c42:	a3 68 60 81 00       	mov    %eax,0x816068
  801c47:	eb 15                	jmp    801c5e <lwip_select+0x1b0>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  801c49:	8b 10                	mov    (%eax),%edx
  801c4b:	39 ca                	cmp    %ecx,%edx
  801c4d:	74 04                	je     801c53 <lwip_select+0x1a5>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c4f:	89 d0                	mov    %edx,%eax
  801c51:	eb 07                	jmp    801c5a <lwip_select+0x1ac>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  801c53:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  801c56:	89 10                	mov    %edx,(%eax)
          break;
  801c58:	eb 04                	jmp    801c5e <lwip_select+0x1b0>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  801c5a:	85 c0                	test   %eax,%eax
  801c5c:	75 eb                	jne    801c49 <lwip_select+0x19b>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  801c5e:	a1 60 60 81 00       	mov    0x816060,%eax
  801c63:	89 04 24             	mov    %eax,(%esp)
  801c66:	e8 c5 8c 00 00       	call   80a930 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  801c6b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801c6e:	89 04 24             	mov    %eax,(%esp)
  801c71:	e8 61 8a 00 00       	call   80a6d7 <sys_sem_free>
    if (i == 0)  {
  801c76:	85 ff                	test   %edi,%edi
  801c78:	75 6d                	jne    801ce7 <lwip_select+0x239>
      /* Timeout */
      if (readset)
  801c7a:	85 f6                	test   %esi,%esi
  801c7c:	74 18                	je     801c96 <lwip_select+0x1e8>
        FD_ZERO(readset);
  801c7e:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801c85:	00 
  801c86:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801c8d:	00 
  801c8e:	89 34 24             	mov    %esi,(%esp)
  801c91:	e8 71 dc 00 00       	call   80f907 <memset>
      if (writeset)
  801c96:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801c9a:	74 1b                	je     801cb7 <lwip_select+0x209>
        FD_ZERO(writeset);
  801c9c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801ca3:	00 
  801ca4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cab:	00 
  801cac:	8b 45 10             	mov    0x10(%ebp),%eax
  801caf:	89 04 24             	mov    %eax,(%esp)
  801cb2:	e8 50 dc 00 00       	call   80f907 <memset>
      if (exceptset)
  801cb7:	85 db                	test   %ebx,%ebx
  801cb9:	74 18                	je     801cd3 <lwip_select+0x225>
        FD_ZERO(exceptset);
  801cbb:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cc2:	00 
  801cc3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801cca:	00 
  801ccb:	89 1c 24             	mov    %ebx,(%esp)
  801cce:	e8 34 dc 00 00       	call   80f907 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  801cd3:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801cda:	00 00 00 
  
      return 0;
  801cdd:	b8 00 00 00 00       	mov    $0x0,%eax
  801ce2:	e9 61 01 00 00       	jmp    801e48 <lwip_select+0x39a>
    }
    
    if (readset)
  801ce7:	85 f6                	test   %esi,%esi
  801ce9:	74 07                	je     801cf2 <lwip_select+0x244>
      lreadset = *readset;
  801ceb:	8b 06                	mov    (%esi),%eax
  801ced:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  801cf0:	eb 1b                	jmp    801d0d <lwip_select+0x25f>
    else
      FD_ZERO(&lreadset);
  801cf2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801cf9:	00 
  801cfa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d01:	00 
  801d02:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  801d05:	89 04 24             	mov    %eax,(%esp)
  801d08:	e8 fa db 00 00       	call   80f907 <memset>
    if (writeset)
  801d0d:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801d11:	74 0a                	je     801d1d <lwip_select+0x26f>
      lwriteset = *writeset;
  801d13:	8b 45 10             	mov    0x10(%ebp),%eax
  801d16:	8b 00                	mov    (%eax),%eax
  801d18:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801d1b:	eb 1b                	jmp    801d38 <lwip_select+0x28a>
    else
      FD_ZERO(&lwriteset);
  801d1d:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d24:	00 
  801d25:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d2c:	00 
  801d2d:	8d 45 e0             	lea    -0x20(%ebp),%eax
  801d30:	89 04 24             	mov    %eax,(%esp)
  801d33:	e8 cf db 00 00       	call   80f907 <memset>
    if (exceptset)
  801d38:	85 db                	test   %ebx,%ebx
  801d3a:	74 07                	je     801d43 <lwip_select+0x295>
      lexceptset = *exceptset;
  801d3c:	8b 03                	mov    (%ebx),%eax
  801d3e:	89 45 dc             	mov    %eax,-0x24(%ebp)
  801d41:	eb 1b                	jmp    801d5e <lwip_select+0x2b0>
    else
      FD_ZERO(&lexceptset);
  801d43:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  801d4a:	00 
  801d4b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  801d52:	00 
  801d53:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d56:	89 04 24             	mov    %eax,(%esp)
  801d59:	e8 a9 db 00 00       	call   80f907 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  801d5e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  801d61:	89 04 24             	mov    %eax,(%esp)
  801d64:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  801d67:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  801d6a:	8b 45 08             	mov    0x8(%ebp),%eax
  801d6d:	e8 3d ec ff ff       	call   8009af <lwip_selscan>
  801d72:	89 c7                	mov    %eax,%edi
  801d74:	eb 0d                	jmp    801d83 <lwip_select+0x2d5>
  } else
    sys_sem_signal(selectsem);
  801d76:	a1 60 60 81 00       	mov    0x816060,%eax
  801d7b:	89 04 24             	mov    %eax,(%esp)
  801d7e:	e8 ad 8b 00 00       	call   80a930 <sys_sem_signal>
  
  if (readset)
  801d83:	85 f6                	test   %esi,%esi
  801d85:	74 05                	je     801d8c <lwip_select+0x2de>
    *readset = lreadset;
  801d87:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801d8a:	89 06                	mov    %eax,(%esi)
  if (writeset)
  801d8c:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  801d90:	74 08                	je     801d9a <lwip_select+0x2ec>
    *writeset = lwriteset;
  801d92:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801d95:	8b 75 10             	mov    0x10(%ebp),%esi
  801d98:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  801d9a:	85 db                	test   %ebx,%ebx
  801d9c:	74 05                	je     801da3 <lwip_select+0x2f5>
    *exceptset = lexceptset;
  801d9e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  801da1:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  801da3:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  801daa:	00 00 00 
  
  return nready;
  801dad:	89 f8                	mov    %edi,%eax
  801daf:	e9 94 00 00 00       	jmp    801e48 <lwip_select+0x39a>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801db4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801dbb:	e8 8e 88 00 00       	call   80a64e <sys_sem_new>
  801dc0:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801dc3:	a1 68 60 81 00       	mov    0x816068,%eax
  801dc8:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801dcb:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801dce:	a3 68 60 81 00       	mov    %eax,0x816068
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801dd3:	a1 60 60 81 00       	mov    0x816060,%eax
  801dd8:	89 04 24             	mov    %eax,(%esp)
  801ddb:	e8 50 8b 00 00       	call   80a930 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  801de0:	8b 45 18             	mov    0x18(%ebp),%eax
  801de3:	69 38 e8 03 00 00    	imul   $0x3e8,(%eax),%edi
  801de9:	8b 48 04             	mov    0x4(%eax),%ecx
  801dec:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  801df2:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  801df7:	89 c8                	mov    %ecx,%eax
  801df9:	f7 ea                	imul   %edx
  801dfb:	c1 fa 06             	sar    $0x6,%edx
  801dfe:	c1 f9 1f             	sar    $0x1f,%ecx
  801e01:	29 ca                	sub    %ecx,%edx
      if(msectimeout == 0)
  801e03:	01 d7                	add    %edx,%edi
        msectimeout = 1;
  801e05:	b8 01 00 00 00       	mov    $0x1,%eax
  801e0a:	0f 44 f8             	cmove  %eax,%edi
  801e0d:	e9 01 fe ff ff       	jmp    801c13 <lwip_select+0x165>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  801e12:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801e19:	e8 30 88 00 00       	call   80a64e <sys_sem_new>
  801e1e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  801e21:	a1 68 60 81 00       	mov    0x816068,%eax
  801e26:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  801e29:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  801e2c:	a3 68 60 81 00       	mov    %eax,0x816068
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  801e31:	a1 60 60 81 00       	mov    0x816060,%eax
  801e36:	89 04 24             	mov    %eax,(%esp)
  801e39:	e8 f2 8a 00 00       	call   80a930 <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  801e3e:	bf 00 00 00 00       	mov    $0x0,%edi
  801e43:	e9 cb fd ff ff       	jmp    801c13 <lwip_select+0x165>
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  
  return nready;
}
  801e48:	83 c4 4c             	add    $0x4c,%esp
  801e4b:	5b                   	pop    %ebx
  801e4c:	5e                   	pop    %esi
  801e4d:	5f                   	pop    %edi
  801e4e:	5d                   	pop    %ebp
  801e4f:	c3                   	ret    

00801e50 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  801e50:	55                   	push   %ebp
  801e51:	89 e5                	mov    %esp,%ebp
  801e53:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  801e56:	8b 45 08             	mov    0x8(%ebp),%eax
  801e59:	89 04 24             	mov    %eax,(%esp)
  801e5c:	e8 b4 f4 ff ff       	call   801315 <lwip_close>
}
  801e61:	c9                   	leave  
  801e62:	c3                   	ret    

00801e63 <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e63:	55                   	push   %ebp
  801e64:	89 e5                	mov    %esp,%ebp
  801e66:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  801e69:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801e70:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e73:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e76:	8b 45 08             	mov    0x8(%ebp),%eax
  801e79:	e8 64 ec ff ff       	call   800ae2 <lwip_getaddrname>
}
  801e7e:	c9                   	leave  
  801e7f:	c3                   	ret    

00801e80 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  801e80:	55                   	push   %ebp
  801e81:	89 e5                	mov    %esp,%ebp
  801e83:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  801e86:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  801e8d:	8b 4d 10             	mov    0x10(%ebp),%ecx
  801e90:	8b 55 0c             	mov    0xc(%ebp),%edx
  801e93:	8b 45 08             	mov    0x8(%ebp),%eax
  801e96:	e8 47 ec ff ff       	call   800ae2 <lwip_getaddrname>
}
  801e9b:	c9                   	leave  
  801e9c:	c3                   	ret    

00801e9d <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  801e9d:	55                   	push   %ebp
  801e9e:	89 e5                	mov    %esp,%ebp
  801ea0:	57                   	push   %edi
  801ea1:	56                   	push   %esi
  801ea2:	53                   	push   %ebx
  801ea3:	83 ec 3c             	sub    $0x3c,%esp
  801ea6:	8b 75 0c             	mov    0xc(%ebp),%esi
  801ea9:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  801eac:	8b 45 08             	mov    0x8(%ebp),%eax
  801eaf:	e8 bc ea ff ff       	call   800970 <get_socket>
  801eb4:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  801eb6:	85 c0                	test   %eax,%eax
  801eb8:	0f 84 8a 01 00 00    	je     802048 <lwip_getsockopt+0x1ab>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  801ebe:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  801ec2:	74 04                	je     801ec8 <lwip_getsockopt+0x2b>
  801ec4:	85 ff                	test   %edi,%edi
  801ec6:	75 1b                	jne    801ee3 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  801ec8:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  801ecf:	c7 05 00 c2 b3 00 0e 	movl   $0xe,0xb3c200
  801ed6:	00 00 00 
    return -1;
  801ed9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801ede:	e9 a8 01 00 00       	jmp    80208b <lwip_getsockopt+0x1ee>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801ee3:	83 fe 06             	cmp    $0x6,%esi
  801ee6:	0f 84 a1 00 00 00    	je     801f8d <lwip_getsockopt+0xf0>
  801eec:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  801ef2:	74 0f                	je     801f03 <lwip_getsockopt+0x66>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  801ef4:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  801ef9:	85 f6                	test   %esi,%esi
  801efb:	0f 85 c9 00 00 00    	jne    801fca <lwip_getsockopt+0x12d>
  801f01:	eb 74                	jmp    801f77 <lwip_getsockopt+0xda>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  801f03:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801f07:	74 3c                	je     801f45 <lwip_getsockopt+0xa8>
  801f09:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  801f0d:	8d 76 00             	lea    0x0(%esi),%esi
  801f10:	7f 12                	jg     801f24 <lwip_getsockopt+0x87>
  801f12:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  801f16:	74 2d                	je     801f45 <lwip_getsockopt+0xa8>
  801f18:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  801f1c:	0f 85 95 00 00 00    	jne    801fb7 <lwip_getsockopt+0x11a>
  801f22:	eb 21                	jmp    801f45 <lwip_getsockopt+0xa8>
  801f24:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  801f2b:	0f 8c 86 00 00 00    	jl     801fb7 <lwip_getsockopt+0x11a>
  801f31:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  801f38:	7e 0b                	jle    801f45 <lwip_getsockopt+0xa8>
  801f3a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  801f41:	74 12                	je     801f55 <lwip_getsockopt+0xb8>
  801f43:	eb 72                	jmp    801fb7 <lwip_getsockopt+0x11a>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  801f45:	83 3f 03             	cmpl   $0x3,(%edi)
  801f48:	0f 86 01 01 00 00    	jbe    80204f <lwip_getsockopt+0x1b2>
  801f4e:	66 90                	xchg   %ax,%ax
  801f50:	e9 8e 00 00 00       	jmp    801fe3 <lwip_getsockopt+0x146>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801f55:	83 3f 04             	cmpl   $0x4,(%edi)
  801f58:	19 c0                	sbb    %eax,%eax
  801f5a:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f5d:	8b 13                	mov    (%ebx),%edx
  801f5f:	83 3a 20             	cmpl   $0x20,(%edx)
  801f62:	0f 85 f1 00 00 00    	jne    802059 <lwip_getsockopt+0x1bc>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  801f68:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  801f6b:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  801f6f:	0f 85 ee 00 00 00    	jne    802063 <lwip_getsockopt+0x1c6>
  801f75:	eb 53                	jmp    801fca <lwip_getsockopt+0x12d>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  801f77:	8b 45 10             	mov    0x10(%ebp),%eax
  801f7a:	83 e8 01             	sub    $0x1,%eax
  801f7d:	83 f8 01             	cmp    $0x1,%eax
  801f80:	77 3c                	ja     801fbe <lwip_getsockopt+0x121>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  801f82:	83 3f 03             	cmpl   $0x3,(%edi)
  801f85:	0f 86 e2 00 00 00    	jbe    80206d <lwip_getsockopt+0x1d0>
  801f8b:	eb 56                	jmp    801fe3 <lwip_getsockopt+0x146>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  801f8d:	83 3f 03             	cmpl   $0x3,(%edi)
  801f90:	0f 86 e1 00 00 00    	jbe    802077 <lwip_getsockopt+0x1da>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f96:	8b 10                	mov    (%eax),%edx
      return 0;
  801f98:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  801f9d:	83 3a 10             	cmpl   $0x10,(%edx)
  801fa0:	0f 85 e5 00 00 00    	jne    80208b <lwip_getsockopt+0x1ee>
      return 0;

    switch (optname) {
  801fa6:	8b 45 10             	mov    0x10(%ebp),%eax
  801fa9:	83 e8 01             	sub    $0x1,%eax
  801fac:	83 f8 01             	cmp    $0x1,%eax
  801faf:	0f 87 cc 00 00 00    	ja     802081 <lwip_getsockopt+0x1e4>
  801fb5:	eb 0e                	jmp    801fc5 <lwip_getsockopt+0x128>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801fb7:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801fbc:	eb 0c                	jmp    801fca <lwip_getsockopt+0x12d>
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  801fbe:	b8 5c 00 00 00       	mov    $0x5c,%eax
  801fc3:	eb 05                	jmp    801fca <lwip_getsockopt+0x12d>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  801fc5:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  801fca:	84 c0                	test   %al,%al
  801fcc:	74 15                	je     801fe3 <lwip_getsockopt+0x146>
    sock_set_errno(sock, err);
  801fce:	0f be c0             	movsbl %al,%eax
  801fd1:	89 43 10             	mov    %eax,0x10(%ebx)
  801fd4:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  801fd9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  801fde:	e9 a8 00 00 00       	jmp    80208b <lwip_getsockopt+0x1ee>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  801fe3:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  801fe6:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  801fe9:	8b 45 10             	mov    0x10(%ebp),%eax
  801fec:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  801fef:	8b 45 14             	mov    0x14(%ebp),%eax
  801ff2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  801ff5:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  801ff8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  801ffc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802003:	00 
  802004:	8d 45 cc             	lea    -0x34(%ebp),%eax
  802007:	89 44 24 04          	mov    %eax,0x4(%esp)
  80200b:	c7 04 24 d4 0d 80 00 	movl   $0x800dd4,(%esp)
  802012:	e8 4c 06 00 00       	call   802663 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  802017:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80201e:	00 
  80201f:	8b 03                	mov    (%ebx),%eax
  802021:	8b 40 10             	mov    0x10(%eax),%eax
  802024:	89 04 24             	mov    %eax,(%esp)
  802027:	e8 79 89 00 00       	call   80a9a5 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  80202c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  802030:	0f be d0             	movsbl %al,%edx
  802033:	89 53 10             	mov    %edx,0x10(%ebx)
  802036:	89 15 00 c2 b3 00    	mov    %edx,0xb3c200
  return err ? -1 : 0;
  80203c:	84 c0                	test   %al,%al
  80203e:	0f 95 c0             	setne  %al
  802041:	0f b6 c0             	movzbl %al,%eax
  802044:	f7 d8                	neg    %eax
  802046:	eb 43                	jmp    80208b <lwip_getsockopt+0x1ee>
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  802048:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80204d:	eb 3c                	jmp    80208b <lwip_getsockopt+0x1ee>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80204f:	b8 16 00 00 00       	mov    $0x16,%eax
  802054:	e9 75 ff ff ff       	jmp    801fce <lwip_getsockopt+0x131>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  802059:	b8 61 00 00 00       	mov    $0x61,%eax
  80205e:	e9 6b ff ff ff       	jmp    801fce <lwip_getsockopt+0x131>
  802063:	b8 61 00 00 00       	mov    $0x61,%eax
  802068:	e9 61 ff ff ff       	jmp    801fce <lwip_getsockopt+0x131>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  80206d:	b8 16 00 00 00       	mov    $0x16,%eax
  802072:	e9 57 ff ff ff       	jmp    801fce <lwip_getsockopt+0x131>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  802077:	b8 16 00 00 00       	mov    $0x16,%eax
  80207c:	e9 4d ff ff ff       	jmp    801fce <lwip_getsockopt+0x131>
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  802081:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802086:	e9 43 ff ff ff       	jmp    801fce <lwip_getsockopt+0x131>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  80208b:	83 c4 3c             	add    $0x3c,%esp
  80208e:	5b                   	pop    %ebx
  80208f:	5e                   	pop    %esi
  802090:	5f                   	pop    %edi
  802091:	5d                   	pop    %ebp
  802092:	c3                   	ret    

00802093 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  802093:	55                   	push   %ebp
  802094:	89 e5                	mov    %esp,%ebp
  802096:	57                   	push   %edi
  802097:	56                   	push   %esi
  802098:	53                   	push   %ebx
  802099:	83 ec 3c             	sub    $0x3c,%esp
  80209c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80209f:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  8020a2:	8b 45 08             	mov    0x8(%ebp),%eax
  8020a5:	e8 c6 e8 ff ff       	call   800970 <get_socket>
  8020aa:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8020ac:	85 c0                	test   %eax,%eax
  8020ae:	0f 84 50 01 00 00    	je     802204 <lwip_setsockopt+0x171>
    return -1;

  if (NULL == optval) {
  8020b4:	85 ff                	test   %edi,%edi
  8020b6:	75 1b                	jne    8020d3 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  8020b8:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  8020bf:	c7 05 00 c2 b3 00 0e 	movl   $0xe,0xb3c200
  8020c6:	00 00 00 
    return -1;
  8020c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8020ce:	e9 74 01 00 00       	jmp    802247 <lwip_setsockopt+0x1b4>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8020d3:	83 fe 06             	cmp    $0x6,%esi
  8020d6:	74 7e                	je     802156 <lwip_setsockopt+0xc3>
  8020d8:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8020de:	74 0f                	je     8020ef <lwip_setsockopt+0x5c>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  8020e0:	b8 5c 00 00 00       	mov    $0x5c,%eax
    sock_set_errno(sock, EFAULT);
    return -1;
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8020e5:	85 f6                	test   %esi,%esi
  8020e7:	0f 85 a0 00 00 00    	jne    80218d <lwip_setsockopt+0xfa>
  8020ed:	eb 50                	jmp    80213f <lwip_setsockopt+0xac>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8020ef:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8020f3:	74 18                	je     80210d <lwip_setsockopt+0x7a>
  8020f5:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8020fc:	74 1e                	je     80211c <lwip_setsockopt+0x89>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8020fe:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  802103:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  802107:	0f 85 80 00 00 00    	jne    80218d <lwip_setsockopt+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  80210d:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  802111:	0f 86 f4 00 00 00    	jbe    80220b <lwip_setsockopt+0x178>
  802117:	e9 87 00 00 00       	jmp    8021a3 <lwip_setsockopt+0x110>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  80211c:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  802120:	19 c0                	sbb    %eax,%eax
  802122:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  802125:	8b 13                	mov    (%ebx),%edx
  802127:	83 3a 20             	cmpl   $0x20,(%edx)
  80212a:	0f 85 e5 00 00 00    	jne    802215 <lwip_setsockopt+0x182>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  802130:	8b 52 08             	mov    0x8(%edx),%edx
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  802133:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  802137:	0f 85 e2 00 00 00    	jne    80221f <lwip_setsockopt+0x18c>
  80213d:	eb 4e                	jmp    80218d <lwip_setsockopt+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80213f:	8b 45 10             	mov    0x10(%ebp),%eax
  802142:	83 e8 01             	sub    $0x1,%eax
  802145:	83 f8 01             	cmp    $0x1,%eax
  802148:	77 37                	ja     802181 <lwip_setsockopt+0xee>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  80214a:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80214e:	0f 86 d5 00 00 00    	jbe    802229 <lwip_setsockopt+0x196>
  802154:	eb 4d                	jmp    8021a3 <lwip_setsockopt+0x110>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  802156:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80215a:	0f 86 d3 00 00 00    	jbe    802233 <lwip_setsockopt+0x1a0>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802160:	8b 10                	mov    (%eax),%edx
      return 0;
  802162:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  802167:	83 3a 10             	cmpl   $0x10,(%edx)
  80216a:	0f 85 d7 00 00 00    	jne    802247 <lwip_setsockopt+0x1b4>
      return 0;

    switch (optname) {
  802170:	8b 45 10             	mov    0x10(%ebp),%eax
  802173:	83 e8 01             	sub    $0x1,%eax
  802176:	83 f8 01             	cmp    $0x1,%eax
  802179:	0f 87 be 00 00 00    	ja     80223d <lwip_setsockopt+0x1aa>
  80217f:	eb 07                	jmp    802188 <lwip_setsockopt+0xf5>
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  802181:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802186:	eb 05                	jmp    80218d <lwip_setsockopt+0xfa>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  802188:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  80218d:	85 c0                	test   %eax,%eax
  80218f:	74 12                	je     8021a3 <lwip_setsockopt+0x110>
    sock_set_errno(sock, err);
  802191:	89 43 10             	mov    %eax,0x10(%ebx)
  802194:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
    return -1;
  802199:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80219e:	e9 a4 00 00 00       	jmp    802247 <lwip_setsockopt+0x1b4>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  8021a3:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  8021a6:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  8021a9:	8b 45 10             	mov    0x10(%ebp),%eax
  8021ac:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  8021af:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  8021b2:	8d 45 18             	lea    0x18(%ebp),%eax
  8021b5:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  8021b8:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  8021bc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8021c3:	00 
  8021c4:	8d 45 cc             	lea    -0x34(%ebp),%eax
  8021c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021cb:	c7 04 24 5b 0f 80 00 	movl   $0x800f5b,(%esp)
  8021d2:	e8 8c 04 00 00       	call   802663 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  8021d7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8021de:	00 
  8021df:	8b 03                	mov    (%ebx),%eax
  8021e1:	8b 40 10             	mov    0x10(%eax),%eax
  8021e4:	89 04 24             	mov    %eax,(%esp)
  8021e7:	e8 b9 87 00 00       	call   80a9a5 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8021ec:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8021f0:	89 43 10             	mov    %eax,0x10(%ebx)
  8021f3:	a3 00 c2 b3 00       	mov    %eax,0xb3c200
  return err ? -1 : 0;
  8021f8:	85 c0                	test   %eax,%eax
  8021fa:	0f 95 c0             	setne  %al
  8021fd:	0f b6 c0             	movzbl %al,%eax
  802200:	f7 d8                	neg    %eax
  802202:	eb 43                	jmp    802247 <lwip_setsockopt+0x1b4>
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  802204:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802209:	eb 3c                	jmp    802247 <lwip_setsockopt+0x1b4>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  80220b:	b8 16 00 00 00       	mov    $0x16,%eax
  802210:	e9 7c ff ff ff       	jmp    802191 <lwip_setsockopt+0xfe>
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  802215:	b8 61 00 00 00       	mov    $0x61,%eax
  80221a:	e9 72 ff ff ff       	jmp    802191 <lwip_setsockopt+0xfe>
  80221f:	b8 61 00 00 00       	mov    $0x61,%eax
  802224:	e9 68 ff ff ff       	jmp    802191 <lwip_setsockopt+0xfe>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  802229:	b8 16 00 00 00       	mov    $0x16,%eax
  80222e:	e9 5e ff ff ff       	jmp    802191 <lwip_setsockopt+0xfe>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  802233:	b8 16 00 00 00       	mov    $0x16,%eax
  802238:	e9 54 ff ff ff       	jmp    802191 <lwip_setsockopt+0xfe>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80223d:	b8 5c 00 00 00       	mov    $0x5c,%eax
  802242:	e9 4a ff ff ff       	jmp    802191 <lwip_setsockopt+0xfe>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
}
  802247:	83 c4 3c             	add    $0x3c,%esp
  80224a:	5b                   	pop    %ebx
  80224b:	5e                   	pop    %esi
  80224c:	5f                   	pop    %edi
  80224d:	5d                   	pop    %ebp
  80224e:	c3                   	ret    

0080224f <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  80224f:	55                   	push   %ebp
  802250:	89 e5                	mov    %esp,%ebp
  802252:	56                   	push   %esi
  802253:	53                   	push   %ebx
  802254:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  802257:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  80225a:	8b 45 08             	mov    0x8(%ebp),%eax
  80225d:	e8 0e e7 ff ff       	call   800970 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  802262:	85 c0                	test   %eax,%eax
  802264:	0f 84 af 00 00 00    	je     802319 <lwip_ioctl+0xca>
    return -1;

  switch (cmd) {
  80226a:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  802270:	74 60                	je     8022d2 <lwip_ioctl+0x83>
  802272:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  802278:	0f 85 83 00 00 00    	jne    802301 <lwip_ioctl+0xb2>
  case FIONREAD:
    if (!argp) {
  80227e:	85 f6                	test   %esi,%esi
  802280:	75 1b                	jne    80229d <lwip_ioctl+0x4e>
      sock_set_errno(sock, EINVAL);
  802282:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  802289:	c7 05 00 c2 b3 00 16 	movl   $0x16,0xb3c200
  802290:	00 00 00 
      return -1;
  802293:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802298:	e9 81 00 00 00       	jmp    80231e <lwip_ioctl+0xcf>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  80229d:	8b 10                	mov    (%eax),%edx
  80229f:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  8022a3:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  8022a6:	8b 48 04             	mov    0x4(%eax),%ecx
  8022a9:	85 c9                	test   %ecx,%ecx
  8022ab:	74 0d                	je     8022ba <lwip_ioctl+0x6b>
      buflen = netbuf_len(sock->lastdata);
  8022ad:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;
  8022af:	66 03 51 08          	add    0x8(%ecx),%dx

      *((u16_t*)argp) += buflen;
  8022b3:	66 2b 50 08          	sub    0x8(%eax),%dx
  8022b7:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  8022ba:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8022c1:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8022c8:	00 00 00 
    return 0;
  8022cb:	b8 00 00 00 00       	mov    $0x0,%eax
  8022d0:	eb 4c                	jmp    80231e <lwip_ioctl+0xcf>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  8022d2:	85 f6                	test   %esi,%esi
  8022d4:	74 0d                	je     8022e3 <lwip_ioctl+0x94>
  8022d6:	83 3e 00             	cmpl   $0x0,(%esi)
  8022d9:	74 08                	je     8022e3 <lwip_ioctl+0x94>
      sock->flags |= O_NONBLOCK;
  8022db:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  8022e1:	eb 06                	jmp    8022e9 <lwip_ioctl+0x9a>
    else
      sock->flags &= ~O_NONBLOCK;
  8022e3:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  8022e9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  8022f0:	c7 05 00 c2 b3 00 00 	movl   $0x0,0xb3c200
  8022f7:	00 00 00 
    return 0;
  8022fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8022ff:	eb 1d                	jmp    80231e <lwip_ioctl+0xcf>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  802301:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  802308:	c7 05 00 c2 b3 00 26 	movl   $0x26,0xb3c200
  80230f:	00 00 00 
    return -1;
  802312:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802317:	eb 05                	jmp    80231e <lwip_ioctl+0xcf>
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
    return -1;
  802319:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
    return -1;
  } /* switch (cmd) */
}
  80231e:	5b                   	pop    %ebx
  80231f:	5e                   	pop    %esi
  802320:	5d                   	pop    %ebp
  802321:	c3                   	ret    
  802322:	66 90                	xchg   %ax,%ax
  802324:	66 90                	xchg   %ax,%ax
  802326:	66 90                	xchg   %ax,%ax
  802328:	66 90                	xchg   %ax,%ax
  80232a:	66 90                	xchg   %ax,%ax
  80232c:	66 90                	xchg   %ax,%ax
  80232e:	66 90                	xchg   %ax,%ax

00802330 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  802330:	55                   	push   %ebp
  802331:	89 e5                	mov    %esp,%ebp
  802333:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  802336:	e8 15 44 00 00       	call   806750 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80233b:	83 3d 5c c2 b3 00 00 	cmpl   $0x0,0xb3c25c
  802342:	75 09                	jne    80234d <tcpip_tcp_timer+0x1d>
  802344:	83 3d 70 c2 b3 00 00 	cmpl   $0x0,0xb3c270
  80234b:	74 1e                	je     80236b <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80234d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802354:	00 
  802355:	c7 44 24 04 30 23 80 	movl   $0x802330,0x4(%esp)
  80235c:	00 
  80235d:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  802364:	e8 7c 34 00 00       	call   8057e5 <sys_timeout>
  802369:	eb 0a                	jmp    802375 <tcpip_tcp_timer+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80236b:	c7 05 00 63 81 00 00 	movl   $0x0,0x816300
  802372:	00 00 00 
  }
}
  802375:	c9                   	leave  
  802376:	c3                   	ret    

00802377 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  802377:	55                   	push   %ebp
  802378:	89 e5                	mov    %esp,%ebp
  80237a:	53                   	push   %ebx
  80237b:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80237e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802385:	00 
  802386:	c7 44 24 04 66 25 80 	movl   $0x802566,0x4(%esp)
  80238d:	00 
  80238e:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802395:	e8 4b 34 00 00       	call   8057e5 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80239a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023a1:	00 
  8023a2:	c7 44 24 04 3d 25 80 	movl   $0x80253d,0x4(%esp)
  8023a9:	00 
  8023aa:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8023b1:	e8 2f 34 00 00       	call   8057e5 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8023b6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023bd:	00 
  8023be:	c7 44 24 04 14 25 80 	movl   $0x802514,0x4(%esp)
  8023c5:	00 
  8023c6:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  8023cd:	e8 13 34 00 00       	call   8057e5 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8023d2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023d9:	00 
  8023da:	c7 44 24 04 eb 24 80 	movl   $0x8024eb,0x4(%esp)
  8023e1:	00 
  8023e2:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8023e9:	e8 f7 33 00 00       	call   8057e5 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8023ee:	a1 08 63 81 00       	mov    0x816308,%eax
  8023f3:	85 c0                	test   %eax,%eax
  8023f5:	75 05                	jne    8023fc <tcpip_thread+0x85>
    tcpip_init_done(tcpip_init_done_arg);
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8023f7:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8023fa:	eb 0d                	jmp    802409 <tcpip_thread+0x92>
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
    tcpip_init_done(tcpip_init_done_arg);
  8023fc:	8b 15 04 63 81 00    	mov    0x816304,%edx
  802402:	89 14 24             	mov    %edx,(%esp)
  802405:	ff d0                	call   *%eax
  802407:	eb ee                	jmp    8023f7 <tcpip_thread+0x80>
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  802409:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80240d:	a1 00 50 81 00       	mov    0x815000,%eax
  802412:	89 04 24             	mov    %eax,(%esp)
  802415:	e8 a3 32 00 00       	call   8056bd <sys_mbox_fetch>
    switch (msg->type) {
  80241a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  80241d:	8b 02                	mov    (%edx),%eax
  80241f:	83 f8 01             	cmp    $0x1,%eax
  802422:	74 1e                	je     802442 <tcpip_thread+0xcb>
  802424:	83 f8 01             	cmp    $0x1,%eax
  802427:	72 0c                	jb     802435 <tcpip_thread+0xbe>
  802429:	83 f8 02             	cmp    $0x2,%eax
  80242c:	74 52                	je     802480 <tcpip_thread+0x109>
  80242e:	83 f8 03             	cmp    $0x3,%eax
  802431:	74 6e                	je     8024a1 <tcpip_thread+0x12a>
  802433:	eb d4                	jmp    802409 <tcpip_thread+0x92>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  802435:	8b 42 08             	mov    0x8(%edx),%eax
  802438:	8d 50 04             	lea    0x4(%eax),%edx
  80243b:	89 14 24             	mov    %edx,(%esp)
  80243e:	ff 10                	call   *(%eax)
      break;
  802440:	eb c7                	jmp    802409 <tcpip_thread+0x92>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  802442:	8b 42 0c             	mov    0xc(%edx),%eax
  802445:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  802449:	74 11                	je     80245c <tcpip_thread+0xe5>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80244b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80244f:	8b 42 08             	mov    0x8(%edx),%eax
  802452:	89 04 24             	mov    %eax,(%esp)
  802455:	e8 3b 80 00 00       	call   80a495 <ethernet_input>
  80245a:	eb 0f                	jmp    80246b <tcpip_thread+0xf4>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  80245c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802460:	8b 42 08             	mov    0x8(%edx),%eax
  802463:	89 04 24             	mov    %eax,(%esp)
  802466:	e8 05 47 00 00       	call   806b70 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  80246b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80246e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802472:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  802479:	e8 f4 25 00 00       	call   804a72 <memp_free>
      break;
  80247e:	eb 89                	jmp    802409 <tcpip_thread+0x92>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  802480:	8b 42 0c             	mov    0xc(%edx),%eax
  802483:	89 04 24             	mov    %eax,(%esp)
  802486:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  802489:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80248c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802490:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802497:	e8 d6 25 00 00       	call   804a72 <memp_free>
      break;
  80249c:	e9 68 ff ff ff       	jmp    802409 <tcpip_thread+0x92>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8024a1:	8b 42 08             	mov    0x8(%edx),%eax
  8024a4:	83 f8 ff             	cmp    $0xffffffff,%eax
  8024a7:	74 18                	je     8024c1 <tcpip_thread+0x14a>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8024a9:	8b 4a 10             	mov    0x10(%edx),%ecx
  8024ac:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8024b0:	8b 52 0c             	mov    0xc(%edx),%edx
  8024b3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8024b7:	89 04 24             	mov    %eax,(%esp)
  8024ba:	e8 26 33 00 00       	call   8057e5 <sys_timeout>
  8024bf:	eb 12                	jmp    8024d3 <tcpip_thread+0x15c>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  8024c1:	8b 42 10             	mov    0x10(%edx),%eax
  8024c4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024c8:	8b 42 0c             	mov    0xc(%edx),%eax
  8024cb:	89 04 24             	mov    %eax,(%esp)
  8024ce:	e8 cb 33 00 00       	call   80589e <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8024d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8024d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024da:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8024e1:	e8 8c 25 00 00       	call   804a72 <memp_free>
      break;
  8024e6:	e9 1e ff ff ff       	jmp    802409 <tcpip_thread+0x92>

008024eb <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8024eb:	55                   	push   %ebp
  8024ec:	89 e5                	mov    %esp,%ebp
  8024ee:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8024f1:	e8 51 1d 00 00       	call   804247 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8024f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024fd:	00 
  8024fe:	c7 44 24 04 eb 24 80 	movl   $0x8024eb,0x4(%esp)
  802505:	00 
  802506:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80250d:	e8 d3 32 00 00       	call   8057e5 <sys_timeout>
}
  802512:	c9                   	leave  
  802513:	c3                   	ret    

00802514 <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  802514:	55                   	push   %ebp
  802515:	89 e5                	mov    %esp,%ebp
  802517:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  80251a:	e8 3f 1b 00 00       	call   80405e <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  80251f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802526:	00 
  802527:	c7 44 24 04 14 25 80 	movl   $0x802514,0x4(%esp)
  80252e:	00 
  80252f:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  802536:	e8 aa 32 00 00       	call   8057e5 <sys_timeout>
}
  80253b:	c9                   	leave  
  80253c:	c3                   	ret    

0080253d <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  80253d:	55                   	push   %ebp
  80253e:	89 e5                	mov    %esp,%ebp
  802540:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  802543:	e8 c8 77 00 00       	call   809d10 <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  802548:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80254f:	00 
  802550:	c7 44 24 04 3d 25 80 	movl   $0x80253d,0x4(%esp)
  802557:	00 
  802558:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  80255f:	e8 81 32 00 00       	call   8057e5 <sys_timeout>
}
  802564:	c9                   	leave  
  802565:	c3                   	ret    

00802566 <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  802566:	55                   	push   %ebp
  802567:	89 e5                	mov    %esp,%ebp
  802569:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  80256c:	e8 e4 4c 00 00       	call   807255 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  802571:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802578:	00 
  802579:	c7 44 24 04 66 25 80 	movl   $0x802566,0x4(%esp)
  802580:	00 
  802581:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  802588:	e8 58 32 00 00       	call   8057e5 <sys_timeout>
}
  80258d:	c9                   	leave  
  80258e:	c3                   	ret    

0080258f <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  80258f:	55                   	push   %ebp
  802590:	89 e5                	mov    %esp,%ebp
  802592:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  802595:	8b 45 08             	mov    0x8(%ebp),%eax
  802598:	89 04 24             	mov    %eax,(%esp)
  80259b:	e8 84 28 00 00       	call   804e24 <pbuf_free>
}
  8025a0:	c9                   	leave  
  8025a1:	c3                   	ret    

008025a2 <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  8025a2:	55                   	push   %ebp
  8025a3:	89 e5                	mov    %esp,%ebp
  8025a5:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  8025a8:	83 3d 00 63 81 00 00 	cmpl   $0x0,0x816300
  8025af:	75 38                	jne    8025e9 <tcp_timer_needed+0x47>
  8025b1:	83 3d 5c c2 b3 00 00 	cmpl   $0x0,0xb3c25c
  8025b8:	75 09                	jne    8025c3 <tcp_timer_needed+0x21>
  8025ba:	83 3d 70 c2 b3 00 00 	cmpl   $0x0,0xb3c270
  8025c1:	74 26                	je     8025e9 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  8025c3:	c7 05 00 63 81 00 01 	movl   $0x1,0x816300
  8025ca:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8025cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8025d4:	00 
  8025d5:	c7 44 24 04 30 23 80 	movl   $0x802330,0x4(%esp)
  8025dc:	00 
  8025dd:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8025e4:	e8 fc 31 00 00       	call   8057e5 <sys_timeout>
  }
}
  8025e9:	c9                   	leave  
  8025ea:	c3                   	ret    

008025eb <tcpip_input>:
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8025eb:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  8025f2:	74 57                	je     80264b <tcpip_input+0x60>
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8025f4:	55                   	push   %ebp
  8025f5:	89 e5                	mov    %esp,%ebp
  8025f7:	53                   	push   %ebx
  8025f8:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  8025fb:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  802602:	e8 0b 24 00 00       	call   804a12 <memp_malloc>
  802607:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802609:	85 c0                	test   %eax,%eax
  80260b:	74 44                	je     802651 <tcpip_input+0x66>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  80260d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
    msg->msg.inp.p = p;
  802613:	8b 45 08             	mov    0x8(%ebp),%eax
  802616:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  802619:	8b 45 0c             	mov    0xc(%ebp),%eax
  80261c:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80261f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802623:	a1 00 50 81 00       	mov    0x815000,%eax
  802628:	89 04 24             	mov    %eax,(%esp)
  80262b:	e8 8c 84 00 00       	call   80aabc <sys_mbox_trypost>
  802630:	84 c0                	test   %al,%al
  802632:	74 24                	je     802658 <tcpip_input+0x6d>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  802634:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802638:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80263f:	e8 2e 24 00 00       	call   804a72 <memp_free>
      return ERR_MEM;
  802644:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802649:	eb 12                	jmp    80265d <tcpip_input+0x72>
    }
    return ERR_OK;
  }
  return ERR_VAL;
  80264b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802650:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
      return ERR_MEM;
  802651:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802656:	eb 05                	jmp    80265d <tcpip_input+0x72>
    msg->msg.inp.netif = inp;
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  802658:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  80265d:	83 c4 14             	add    $0x14,%esp
  802660:	5b                   	pop    %ebx
  802661:	5d                   	pop    %ebp
  802662:	c3                   	ret    

00802663 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  802663:	55                   	push   %ebp
  802664:	89 e5                	mov    %esp,%ebp
  802666:	56                   	push   %esi
  802667:	53                   	push   %ebx
  802668:	83 ec 10             	sub    $0x10,%esp
  80266b:	8b 75 10             	mov    0x10(%ebp),%esi
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  80266e:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802675:	74 6e                	je     8026e5 <tcpip_callback_with_block+0x82>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  802677:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80267e:	e8 8f 23 00 00       	call   804a12 <memp_malloc>
  802683:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  802685:	85 c0                	test   %eax,%eax
  802687:	74 63                	je     8026ec <tcpip_callback_with_block+0x89>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  802689:	c7 00 02 00 00 00    	movl   $0x2,(%eax)
    msg->msg.cb.f = f;
  80268f:	8b 45 08             	mov    0x8(%ebp),%eax
  802692:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.cb.ctx = ctx;
  802695:	8b 45 0c             	mov    0xc(%ebp),%eax
  802698:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (block) {
  80269b:	89 f0                	mov    %esi,%eax
  80269d:	84 c0                	test   %al,%al
  80269f:	74 18                	je     8026b9 <tcpip_callback_with_block+0x56>
      sys_mbox_post(mbox, msg);
  8026a1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026a5:	a1 00 50 81 00       	mov    0x815000,%eax
  8026aa:	89 04 24             	mov    %eax,(%esp)
  8026ad:	e8 d4 84 00 00       	call   80ab86 <sys_mbox_post>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  8026b2:	b8 00 00 00 00       	mov    $0x0,%eax
  8026b7:	eb 3f                	jmp    8026f8 <tcpip_callback_with_block+0x95>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8026b9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026bd:	a1 00 50 81 00       	mov    0x815000,%eax
  8026c2:	89 04 24             	mov    %eax,(%esp)
  8026c5:	e8 f2 83 00 00       	call   80aabc <sys_mbox_trypost>
  8026ca:	84 c0                	test   %al,%al
  8026cc:	74 25                	je     8026f3 <tcpip_callback_with_block+0x90>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  8026ce:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026d2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8026d9:	e8 94 23 00 00       	call   804a72 <memp_free>
        return ERR_MEM;
  8026de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026e3:	eb 13                	jmp    8026f8 <tcpip_callback_with_block+0x95>
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8026e5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8026ea:	eb 0c                	jmp    8026f8 <tcpip_callback_with_block+0x95>
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  8026ec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8026f1:	eb 05                	jmp    8026f8 <tcpip_callback_with_block+0x95>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  8026f3:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  8026f8:	83 c4 10             	add    $0x10,%esp
  8026fb:	5b                   	pop    %ebx
  8026fc:	5e                   	pop    %esi
  8026fd:	5d                   	pop    %ebp
  8026fe:	c3                   	ret    

008026ff <tcpip_timeout>:
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8026ff:	83 3d 00 50 81 00 ff 	cmpl   $0xffffffff,0x815000
  802706:	74 46                	je     80274e <tcpip_timeout+0x4f>
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  802708:	55                   	push   %ebp
  802709:	89 e5                	mov    %esp,%ebp
  80270b:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  80270e:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  802715:	e8 f8 22 00 00       	call   804a12 <memp_malloc>
    if (msg == NULL) {
  80271a:	85 c0                	test   %eax,%eax
  80271c:	74 36                	je     802754 <tcpip_timeout+0x55>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  80271e:	c7 00 03 00 00 00    	movl   $0x3,(%eax)
    msg->msg.tmo.msecs = msecs;
  802724:	8b 55 08             	mov    0x8(%ebp),%edx
  802727:	89 50 08             	mov    %edx,0x8(%eax)
    msg->msg.tmo.h = h;
  80272a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80272d:	89 50 0c             	mov    %edx,0xc(%eax)
    msg->msg.tmo.arg = arg;
  802730:	8b 55 10             	mov    0x10(%ebp),%edx
  802733:	89 50 10             	mov    %edx,0x10(%eax)
    sys_mbox_post(mbox, msg);
  802736:	89 44 24 04          	mov    %eax,0x4(%esp)
  80273a:	a1 00 50 81 00       	mov    0x815000,%eax
  80273f:	89 04 24             	mov    %eax,(%esp)
  802742:	e8 3f 84 00 00       	call   80ab86 <sys_mbox_post>
    return ERR_OK;
  802747:	b8 00 00 00 00       	mov    $0x0,%eax
  80274c:	eb 0b                	jmp    802759 <tcpip_timeout+0x5a>
  }
  return ERR_VAL;
  80274e:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  802753:	c3                   	ret    
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
      return ERR_MEM;
  802754:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
}
  802759:	c9                   	leave  
  80275a:	c3                   	ret    

0080275b <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  80275b:	55                   	push   %ebp
  80275c:	89 e5                	mov    %esp,%ebp
  80275e:	53                   	push   %ebx
  80275f:	83 ec 34             	sub    $0x34,%esp
  802762:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  802765:	a1 00 50 81 00       	mov    0x815000,%eax
  80276a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80276d:	74 36                	je     8027a5 <tcpip_apimsg+0x4a>
    msg.type = TCPIP_MSG_API;
  80276f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  802776:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  802779:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80277c:	89 54 24 04          	mov    %edx,0x4(%esp)
  802780:	89 04 24             	mov    %eax,(%esp)
  802783:	e8 fe 83 00 00       	call   80ab86 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  802788:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80278f:	00 
  802790:	8b 43 04             	mov    0x4(%ebx),%eax
  802793:	8b 40 10             	mov    0x10(%eax),%eax
  802796:	89 04 24             	mov    %eax,(%esp)
  802799:	e8 07 82 00 00       	call   80a9a5 <sys_arch_sem_wait>
    return ERR_OK;
  80279e:	b8 00 00 00 00       	mov    $0x0,%eax
  8027a3:	eb 05                	jmp    8027aa <tcpip_apimsg+0x4f>
  }
  return ERR_VAL;
  8027a5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  8027aa:	83 c4 34             	add    $0x34,%esp
  8027ad:	5b                   	pop    %ebx
  8027ae:	5d                   	pop    %ebp
  8027af:	c3                   	ret    

008027b0 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  8027b0:	55                   	push   %ebp
  8027b1:	89 e5                	mov    %esp,%ebp
  8027b3:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  8027b6:	e8 f5 03 00 00       	call   802bb0 <lwip_init>

  tcpip_init_done = initfunc;
  8027bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8027be:	a3 08 63 81 00       	mov    %eax,0x816308
  tcpip_init_done_arg = arg;
  8027c3:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027c6:	a3 04 63 81 00       	mov    %eax,0x816304
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  8027cb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8027d2:	e8 3f 80 00 00       	call   80a816 <sys_mbox_new>
  8027d7:	a3 00 50 81 00       	mov    %eax,0x815000
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  8027dc:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  8027e3:	00 
  8027e4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8027eb:	00 
  8027ec:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8027f3:	00 
  8027f4:	c7 44 24 04 77 23 80 	movl   $0x802377,0x4(%esp)
  8027fb:	00 
  8027fc:	c7 04 24 dc 21 81 00 	movl   $0x8121dc,(%esp)
  802803:	e8 dc 84 00 00       	call   80ace4 <sys_thread_new>
}
  802808:	c9                   	leave  
  802809:	c3                   	ret    

0080280a <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  80280a:	55                   	push   %ebp
  80280b:	89 e5                	mov    %esp,%ebp
  80280d:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  802810:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802817:	00 
  802818:	8b 45 08             	mov    0x8(%ebp),%eax
  80281b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80281f:	c7 04 24 8f 25 80 00 	movl   $0x80258f,(%esp)
  802826:	e8 38 fe ff ff       	call   802663 <tcpip_callback_with_block>
}
  80282b:	c9                   	leave  
  80282c:	c3                   	ret    

0080282d <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  80282d:	55                   	push   %ebp
  80282e:	89 e5                	mov    %esp,%ebp
  802830:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  802833:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80283a:	00 
  80283b:	8b 45 08             	mov    0x8(%ebp),%eax
  80283e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802842:	c7 04 24 15 45 80 00 	movl   $0x804515,(%esp)
  802849:	e8 15 fe ff ff       	call   802663 <tcpip_callback_with_block>
}
  80284e:	c9                   	leave  
  80284f:	c3                   	ret    

00802850 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  802850:	55                   	push   %ebp
  802851:	89 e5                	mov    %esp,%ebp
  802853:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  802856:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80285d:	e8 b0 21 00 00       	call   804a12 <memp_malloc>
  if (buf != NULL) {
  802862:	85 c0                	test   %eax,%eax
  802864:	74 14                	je     80287a <netbuf_new+0x2a>
    buf->p = NULL;
  802866:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  80286c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  802873:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  80287a:	c9                   	leave  
  80287b:	c3                   	ret    

0080287c <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80287c:	55                   	push   %ebp
  80287d:	89 e5                	mov    %esp,%ebp
  80287f:	53                   	push   %ebx
  802880:	83 ec 14             	sub    $0x14,%esp
  802883:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  802886:	85 db                	test   %ebx,%ebx
  802888:	74 2b                	je     8028b5 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  80288a:	8b 03                	mov    (%ebx),%eax
  80288c:	85 c0                	test   %eax,%eax
  80288e:	74 15                	je     8028a5 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  802890:	89 04 24             	mov    %eax,(%esp)
  802893:	e8 8c 25 00 00       	call   804e24 <pbuf_free>
      buf->p = buf->ptr = NULL;
  802898:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80289f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  8028a5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8028a9:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8028b0:	e8 bd 21 00 00       	call   804a72 <memp_free>
  }
}
  8028b5:	83 c4 14             	add    $0x14,%esp
  8028b8:	5b                   	pop    %ebx
  8028b9:	5d                   	pop    %ebp
  8028ba:	c3                   	ret    

008028bb <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  8028bb:	55                   	push   %ebp
  8028bc:	89 e5                	mov    %esp,%ebp
  8028be:	56                   	push   %esi
  8028bf:	53                   	push   %ebx
  8028c0:	83 ec 10             	sub    $0x10,%esp
  8028c3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8028c6:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  8028c9:	85 db                	test   %ebx,%ebx
  8028cb:	75 1c                	jne    8028e9 <netbuf_alloc+0x2e>
  8028cd:	c7 44 24 08 e9 21 81 	movl   $0x8121e9,0x8(%esp)
  8028d4:	00 
  8028d5:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  8028dc:	00 
  8028dd:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  8028e4:	e8 b1 c7 00 00       	call   80f09a <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  8028e9:	8b 03                	mov    (%ebx),%eax
  8028eb:	85 c0                	test   %eax,%eax
  8028ed:	74 08                	je     8028f7 <netbuf_alloc+0x3c>
    pbuf_free(buf->p);
  8028ef:	89 04 24             	mov    %eax,(%esp)
  8028f2:	e8 2d 25 00 00       	call   804e24 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  8028f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8028fe:	00 
  8028ff:	0f b7 c6             	movzwl %si,%eax
  802902:	89 44 24 04          	mov    %eax,0x4(%esp)
  802906:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80290d:	e8 f3 25 00 00       	call   804f05 <pbuf_alloc>
  802912:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  802914:	85 c0                	test   %eax,%eax
  802916:	74 2a                	je     802942 <netbuf_alloc+0x87>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  802918:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80291c:	76 1c                	jbe    80293a <netbuf_alloc+0x7f>
  80291e:	c7 44 24 08 d0 22 81 	movl   $0x8122d0,0x8(%esp)
  802925:	00 
  802926:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  80292d:	00 
  80292e:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802935:	e8 60 c7 00 00       	call   80f09a <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  80293a:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  80293d:	8b 40 04             	mov    0x4(%eax),%eax
  802940:	eb 05                	jmp    802947 <netbuf_alloc+0x8c>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  802942:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  802947:	83 c4 10             	add    $0x10,%esp
  80294a:	5b                   	pop    %ebx
  80294b:	5e                   	pop    %esi
  80294c:	5d                   	pop    %ebp
  80294d:	c3                   	ret    

0080294e <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  80294e:	55                   	push   %ebp
  80294f:	89 e5                	mov    %esp,%ebp
  802951:	53                   	push   %ebx
  802952:	83 ec 14             	sub    $0x14,%esp
  802955:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802958:	85 db                	test   %ebx,%ebx
  80295a:	75 1c                	jne    802978 <netbuf_free+0x2a>
  80295c:	c7 44 24 08 19 22 81 	movl   $0x812219,0x8(%esp)
  802963:	00 
  802964:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80296b:	00 
  80296c:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802973:	e8 22 c7 00 00       	call   80f09a <_panic>
  if (buf->p != NULL) {
  802978:	8b 03                	mov    (%ebx),%eax
  80297a:	85 c0                	test   %eax,%eax
  80297c:	74 08                	je     802986 <netbuf_free+0x38>
    pbuf_free(buf->p);
  80297e:	89 04 24             	mov    %eax,(%esp)
  802981:	e8 9e 24 00 00       	call   804e24 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  802986:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  80298d:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  802993:	83 c4 14             	add    $0x14,%esp
  802996:	5b                   	pop    %ebx
  802997:	5d                   	pop    %ebp
  802998:	c3                   	ret    

00802999 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  802999:	55                   	push   %ebp
  80299a:	89 e5                	mov    %esp,%ebp
  80299c:	56                   	push   %esi
  80299d:	53                   	push   %ebx
  80299e:	83 ec 10             	sub    $0x10,%esp
  8029a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8029a4:	8b 75 10             	mov    0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8029a7:	85 db                	test   %ebx,%ebx
  8029a9:	75 1c                	jne    8029c7 <netbuf_ref+0x2e>
  8029ab:	c7 44 24 08 32 22 81 	movl   $0x812232,0x8(%esp)
  8029b2:	00 
  8029b3:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  8029ba:	00 
  8029bb:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  8029c2:	e8 d3 c6 00 00       	call   80f09a <_panic>
  if (buf->p != NULL) {
  8029c7:	8b 03                	mov    (%ebx),%eax
  8029c9:	85 c0                	test   %eax,%eax
  8029cb:	74 08                	je     8029d5 <netbuf_ref+0x3c>
    pbuf_free(buf->p);
  8029cd:	89 04 24             	mov    %eax,(%esp)
  8029d0:	e8 4f 24 00 00       	call   804e24 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8029d5:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8029dc:	00 
  8029dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8029e4:	00 
  8029e5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8029ec:	e8 14 25 00 00       	call   804f05 <pbuf_alloc>
  8029f1:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8029f3:	85 c0                	test   %eax,%eax
  8029f5:	75 0e                	jne    802a05 <netbuf_ref+0x6c>
    buf->ptr = NULL;
  8029f7:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  8029fe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  802a03:	eb 1a                	jmp    802a1f <netbuf_ref+0x86>
  }
  buf->p->payload = (void*)dataptr;
  802a05:	8b 55 0c             	mov    0xc(%ebp),%edx
  802a08:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  802a0b:	8b 03                	mov    (%ebx),%eax
  802a0d:	66 89 70 08          	mov    %si,0x8(%eax)
  802a11:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  802a15:	8b 03                	mov    (%ebx),%eax
  802a17:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  802a1a:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802a1f:	83 c4 10             	add    $0x10,%esp
  802a22:	5b                   	pop    %ebx
  802a23:	5e                   	pop    %esi
  802a24:	5d                   	pop    %ebp
  802a25:	c3                   	ret    

00802a26 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  802a26:	55                   	push   %ebp
  802a27:	89 e5                	mov    %esp,%ebp
  802a29:	56                   	push   %esi
  802a2a:	53                   	push   %ebx
  802a2b:	83 ec 10             	sub    $0x10,%esp
  802a2e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802a31:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  802a34:	85 db                	test   %ebx,%ebx
  802a36:	75 1c                	jne    802a54 <netbuf_chain+0x2e>
  802a38:	c7 44 24 08 4a 22 81 	movl   $0x81224a,0x8(%esp)
  802a3f:	00 
  802a40:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  802a47:	00 
  802a48:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802a4f:	e8 46 c6 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  802a54:	85 f6                	test   %esi,%esi
  802a56:	75 1c                	jne    802a74 <netbuf_chain+0x4e>
  802a58:	c7 44 24 08 63 22 81 	movl   $0x812263,0x8(%esp)
  802a5f:	00 
  802a60:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  802a67:	00 
  802a68:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802a6f:	e8 26 c6 00 00       	call   80f09a <_panic>
  pbuf_chain(head->p, tail->p);
  802a74:	8b 06                	mov    (%esi),%eax
  802a76:	89 44 24 04          	mov    %eax,0x4(%esp)
  802a7a:	8b 03                	mov    (%ebx),%eax
  802a7c:	89 04 24             	mov    %eax,(%esp)
  802a7f:	e8 d6 28 00 00       	call   80535a <pbuf_chain>
  head->ptr = head->p;
  802a84:	8b 03                	mov    (%ebx),%eax
  802a86:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  802a89:	89 74 24 04          	mov    %esi,0x4(%esp)
  802a8d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  802a94:	e8 d9 1f 00 00       	call   804a72 <memp_free>
}
  802a99:	83 c4 10             	add    $0x10,%esp
  802a9c:	5b                   	pop    %ebx
  802a9d:	5e                   	pop    %esi
  802a9e:	5d                   	pop    %ebp
  802a9f:	c3                   	ret    

00802aa0 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  802aa0:	55                   	push   %ebp
  802aa1:	89 e5                	mov    %esp,%ebp
  802aa3:	53                   	push   %ebx
  802aa4:	83 ec 14             	sub    $0x14,%esp
  802aa7:	8b 45 08             	mov    0x8(%ebp),%eax
  802aaa:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  802aad:	8b 55 10             	mov    0x10(%ebp),%edx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  802ab0:	85 c0                	test   %eax,%eax
  802ab2:	75 1c                	jne    802ad0 <netbuf_data+0x30>
  802ab4:	c7 44 24 08 7e 22 81 	movl   $0x81227e,0x8(%esp)
  802abb:	00 
  802abc:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  802ac3:	00 
  802ac4:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802acb:	e8 ca c5 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  802ad0:	85 c9                	test   %ecx,%ecx
  802ad2:	75 1c                	jne    802af0 <netbuf_data+0x50>
  802ad4:	c7 44 24 08 97 22 81 	movl   $0x812297,0x8(%esp)
  802adb:	00 
  802adc:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  802ae3:	00 
  802ae4:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802aeb:	e8 aa c5 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  802af0:	85 d2                	test   %edx,%edx
  802af2:	75 1c                	jne    802b10 <netbuf_data+0x70>
  802af4:	c7 44 24 08 b4 22 81 	movl   $0x8122b4,0x8(%esp)
  802afb:	00 
  802afc:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  802b03:	00 
  802b04:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802b0b:	e8 8a c5 00 00       	call   80f09a <_panic>

  if (buf->ptr == NULL) {
  802b10:	8b 58 04             	mov    0x4(%eax),%ebx
  802b13:	85 db                	test   %ebx,%ebx
  802b15:	74 16                	je     802b2d <netbuf_data+0x8d>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  802b17:	8b 5b 04             	mov    0x4(%ebx),%ebx
  802b1a:	89 19                	mov    %ebx,(%ecx)
  *len = buf->ptr->len;
  802b1c:	8b 40 04             	mov    0x4(%eax),%eax
  802b1f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  802b23:	66 89 02             	mov    %ax,(%edx)
  return ERR_OK;
  802b26:	b8 00 00 00 00       	mov    $0x0,%eax
  802b2b:	eb 05                	jmp    802b32 <netbuf_data+0x92>
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
    return ERR_BUF;
  802b2d:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  }
  *dataptr = buf->ptr->payload;
  *len = buf->ptr->len;
  return ERR_OK;
}
  802b32:	83 c4 14             	add    $0x14,%esp
  802b35:	5b                   	pop    %ebx
  802b36:	5d                   	pop    %ebp
  802b37:	c3                   	ret    

00802b38 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  802b38:	55                   	push   %ebp
  802b39:	89 e5                	mov    %esp,%ebp
  802b3b:	83 ec 18             	sub    $0x18,%esp
  802b3e:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  802b41:	85 c0                	test   %eax,%eax
  802b43:	75 1c                	jne    802b61 <netbuf_next+0x29>
  802b45:	c7 44 24 08 19 22 81 	movl   $0x812219,0x8(%esp)
  802b4c:	00 
  802b4d:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  802b54:	00 
  802b55:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802b5c:	e8 39 c5 00 00       	call   80f09a <_panic>
  if (buf->ptr->next == NULL) {
  802b61:	8b 50 04             	mov    0x4(%eax),%edx
  802b64:	8b 12                	mov    (%edx),%edx
  802b66:	85 d2                	test   %edx,%edx
  802b68:	74 0b                	je     802b75 <netbuf_next+0x3d>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  802b6a:	89 50 04             	mov    %edx,0x4(%eax)
  if (buf->ptr->next == NULL) {
  802b6d:	83 3a 00             	cmpl   $0x0,(%edx)
  802b70:	0f 94 c0             	sete   %al
  802b73:	eb 05                	jmp    802b7a <netbuf_next+0x42>
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
    return -1;
  802b75:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  buf->ptr = buf->ptr->next;
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  802b7a:	c9                   	leave  
  802b7b:	c3                   	ret    

00802b7c <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  802b7c:	55                   	push   %ebp
  802b7d:	89 e5                	mov    %esp,%ebp
  802b7f:	83 ec 18             	sub    $0x18,%esp
  802b82:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  802b85:	85 c0                	test   %eax,%eax
  802b87:	75 1c                	jne    802ba5 <netbuf_first+0x29>
  802b89:	c7 44 24 08 19 22 81 	movl   $0x812219,0x8(%esp)
  802b90:	00 
  802b91:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  802b98:	00 
  802b99:	c7 04 24 03 22 81 00 	movl   $0x812203,(%esp)
  802ba0:	e8 f5 c4 00 00       	call   80f09a <_panic>
  buf->ptr = buf->p;
  802ba5:	8b 10                	mov    (%eax),%edx
  802ba7:	89 50 04             	mov    %edx,0x4(%eax)
}
  802baa:	c9                   	leave  
  802bab:	c3                   	ret    
  802bac:	66 90                	xchg   %ax,%ax
  802bae:	66 90                	xchg   %ax,%ax

00802bb0 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  802bb0:	55                   	push   %ebp
  802bb1:	89 e5                	mov    %esp,%ebp
  802bb3:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  802bb6:	e8 fa 79 00 00       	call   80a5b5 <sys_init>
  mem_init();
  802bbb:	e8 ed 18 00 00       	call   8044ad <mem_init>
  memp_init();
  802bc0:	e8 f5 1d 00 00       	call   8049ba <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  802bc5:	e8 9e e4 ff ff       	call   801068 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  802bca:	c9                   	leave  
  802bcb:	c3                   	ret    
  802bcc:	66 90                	xchg   %ax,%ax
  802bce:	66 90                	xchg   %ax,%ax

00802bd0 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  802bd0:	55                   	push   %ebp
  802bd1:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  802bd3:	38 10                	cmp    %dl,(%eax)
  802bd5:	74 06                	je     802bdd <dhcp_set_state+0xd>
    dhcp->state = new_state;
  802bd7:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  802bd9:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  802bdd:	5d                   	pop    %ebp
  802bde:	c3                   	ret    

00802bdf <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  802bdf:	55                   	push   %ebp
  802be0:	89 e5                	mov    %esp,%ebp
  802be2:	57                   	push   %edi
  802be3:	56                   	push   %esi
  802be4:	53                   	push   %ebx
  802be5:	83 ec 08             	sub    $0x8,%esp
  802be8:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  802beb:	8b 70 14             	mov    0x14(%eax),%esi
  802bee:	85 f6                	test   %esi,%esi
  802bf0:	0f 84 c9 00 00 00    	je     802cbf <dhcp_get_option_ptr+0xe0>
  802bf6:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  802bfa:	66 85 ff             	test   %di,%di
  802bfd:	0f 84 c3 00 00 00    	je     802cc6 <dhcp_get_option_ptr+0xe7>
  802c03:	b9 00 00 00 00       	mov    $0x0,%ecx
  802c08:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)
  802c0c:	eb 2d                	jmp    802c3b <dhcp_get_option_ptr+0x5c>
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  802c0e:	80 fb 34             	cmp    $0x34,%bl
  802c11:	75 12                	jne    802c25 <dhcp_get_option_ptr+0x46>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  802c13:	8d 41 02             	lea    0x2(%ecx),%eax
        overload = options[offset++];
  802c16:	83 c1 03             	add    $0x3,%ecx
  802c19:	0f b7 c0             	movzwl %ax,%eax
  802c1c:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802c20:	88 45 f3             	mov    %al,-0xd(%ebp)
  802c23:	eb 16                	jmp    802c3b <dhcp_get_option_ptr+0x5c>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  802c25:	38 d3                	cmp    %dl,%bl
  802c27:	0f 84 ac 00 00 00    	je     802cd9 <dhcp_get_option_ptr+0xfa>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  802c2d:	8d 41 01             	lea    0x1(%ecx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  802c30:	0f b7 c0             	movzwl %ax,%eax
  802c33:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802c37:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  802c3b:	66 39 f9             	cmp    %di,%cx
  802c3e:	73 0d                	jae    802c4d <dhcp_get_option_ptr+0x6e>
  802c40:	0f b7 c1             	movzwl %cx,%eax
  802c43:	01 f0                	add    %esi,%eax
  802c45:	0f b6 18             	movzbl (%eax),%ebx
  802c48:	80 fb ff             	cmp    $0xff,%bl
  802c4b:	75 c1                	jne    802c0e <dhcp_get_option_ptr+0x2f>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  802c4d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
  802c51:	84 c0                	test   %al,%al
  802c53:	74 78                	je     802ccd <dhcp_get_option_ptr+0xee>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  802c55:	3c 01                	cmp    $0x1,%al
  802c57:	75 10                	jne    802c69 <dhcp_get_option_ptr+0x8a>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  802c59:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c5c:	8b 70 10             	mov    0x10(%eax),%esi
  802c5f:	83 c6 6c             	add    $0x6c,%esi
        field_len = DHCP_FILE_LEN;
  802c62:	bf 80 00 00 00       	mov    $0x80,%edi
  802c67:	eb 24                	jmp    802c8d <dhcp_get_option_ptr+0xae>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  802c69:	80 7d f3 02          	cmpb   $0x2,-0xd(%ebp)
  802c6d:	75 10                	jne    802c7f <dhcp_get_option_ptr+0xa0>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c6f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c72:	8b 70 10             	mov    0x10(%eax),%esi
  802c75:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_SNAME_LEN;
  802c78:	bf 40 00 00 00       	mov    $0x40,%edi
  802c7d:	eb 0e                	jmp    802c8d <dhcp_get_option_ptr+0xae>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  802c7f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  802c82:	8b 70 10             	mov    0x10(%eax),%esi
  802c85:	83 c6 2c             	add    $0x2c,%esi
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  802c88:	bf c0 00 00 00       	mov    $0xc0,%edi
      }
      offset = 0;
  802c8d:	b9 00 00 00 00       	mov    $0x0,%ecx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802c92:	eb 12                	jmp    802ca6 <dhcp_get_option_ptr+0xc7>
        if (options[offset] == option_type) {
  802c94:	38 da                	cmp    %bl,%dl
  802c96:	74 41                	je     802cd9 <dhcp_get_option_ptr+0xfa>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  802c98:	8d 41 01             	lea    0x1(%ecx),%eax
          offset += 1 + options[offset];
  802c9b:	0f b7 c0             	movzwl %ax,%eax
  802c9e:	0f b6 04 06          	movzbl (%esi,%eax,1),%eax
  802ca2:	8d 4c 01 02          	lea    0x2(%ecx,%eax,1),%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  802ca6:	66 39 f9             	cmp    %di,%cx
  802ca9:	73 29                	jae    802cd4 <dhcp_get_option_ptr+0xf5>
  802cab:	0f b7 c1             	movzwl %cx,%eax
  802cae:	01 f0                	add    %esi,%eax
  802cb0:	0f b6 18             	movzbl (%eax),%ebx
  802cb3:	80 fb ff             	cmp    $0xff,%bl
  802cb6:	75 dc                	jne    802c94 <dhcp_get_option_ptr+0xb5>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  802cb8:	b8 00 00 00 00       	mov    $0x0,%eax
  802cbd:	eb 1a                	jmp    802cd9 <dhcp_get_option_ptr+0xfa>
  802cbf:	b8 00 00 00 00       	mov    $0x0,%eax
  802cc4:	eb 13                	jmp    802cd9 <dhcp_get_option_ptr+0xfa>
  802cc6:	b8 00 00 00 00       	mov    $0x0,%eax
  802ccb:	eb 0c                	jmp    802cd9 <dhcp_get_option_ptr+0xfa>
  802ccd:	b8 00 00 00 00       	mov    $0x0,%eax
  802cd2:	eb 05                	jmp    802cd9 <dhcp_get_option_ptr+0xfa>
  802cd4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802cd9:	83 c4 08             	add    $0x8,%esp
  802cdc:	5b                   	pop    %ebx
  802cdd:	5e                   	pop    %esi
  802cde:	5f                   	pop    %edi
  802cdf:	5d                   	pop    %ebp
  802ce0:	c3                   	ret    

00802ce1 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  802ce1:	55                   	push   %ebp
  802ce2:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  802ce4:	0f b6 08             	movzbl (%eax),%ecx
  802ce7:	c1 e1 18             	shl    $0x18,%ecx
  value |= (u32_t)(*ptr++) << 16;
  802cea:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  802cee:	c1 e2 10             	shl    $0x10,%edx
  802cf1:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++) << 8;
  value |= (u32_t)(*ptr++);
  802cf3:	0f b6 50 03          	movzbl 0x3(%eax),%edx
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  value |= (u32_t)(*ptr++) << 16;
  value |= (u32_t)(*ptr++) << 8;
  802cf7:	09 d1                	or     %edx,%ecx
  802cf9:	0f b6 50 02          	movzbl 0x2(%eax),%edx
  802cfd:	c1 e2 08             	shl    $0x8,%edx
  value |= (u32_t)(*ptr++);
  802d00:	89 c8                	mov    %ecx,%eax
  802d02:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  802d04:	5d                   	pop    %ebp
  802d05:	c3                   	ret    

00802d06 <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  802d06:	55                   	push   %ebp
  802d07:	89 e5                	mov    %esp,%ebp
  802d09:	56                   	push   %esi
  802d0a:	53                   	push   %ebx
  802d0b:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802d0e:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802d12:	66 83 f9 43          	cmp    $0x43,%cx
  802d16:	76 1c                	jbe    802d34 <dhcp_option_byte+0x2e>
  802d18:	c7 44 24 08 f4 22 81 	movl   $0x8122f4,0x8(%esp)
  802d1f:	00 
  802d20:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  802d27:	00 
  802d28:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802d2f:	e8 66 c3 00 00       	call   80f09a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  802d34:	8b 58 20             	mov    0x20(%eax),%ebx
  802d37:	8d 71 01             	lea    0x1(%ecx),%esi
  802d3a:	66 89 70 24          	mov    %si,0x24(%eax)
  802d3e:	0f b7 c9             	movzwl %cx,%ecx
  802d41:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802d48:	83 c4 10             	add    $0x10,%esp
  802d4b:	5b                   	pop    %ebx
  802d4c:	5e                   	pop    %esi
  802d4d:	5d                   	pop    %ebp
  802d4e:	c3                   	ret    

00802d4f <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  802d4f:	55                   	push   %ebp
  802d50:	89 e5                	mov    %esp,%ebp
  802d52:	57                   	push   %edi
  802d53:	56                   	push   %esi
  802d54:	53                   	push   %ebx
  802d55:	83 ec 1c             	sub    $0x1c,%esp
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  802d58:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  802d5c:	0f b7 fb             	movzwl %bx,%edi
  802d5f:	0f b6 f1             	movzbl %cl,%esi
  802d62:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  802d66:	83 fe 44             	cmp    $0x44,%esi
  802d69:	76 1c                	jbe    802d87 <dhcp_option+0x38>
  802d6b:	c7 44 24 08 30 23 81 	movl   $0x812330,0x8(%esp)
  802d72:	00 
  802d73:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  802d7a:	00 
  802d7b:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802d82:	e8 13 c3 00 00       	call   80f09a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  802d87:	8b 70 20             	mov    0x20(%eax),%esi
  802d8a:	8d 7b 01             	lea    0x1(%ebx),%edi
  802d8d:	66 89 78 24          	mov    %di,0x24(%eax)
  802d91:	0f b7 db             	movzwl %bx,%ebx
  802d94:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  802d9b:	8b 58 20             	mov    0x20(%eax),%ebx
  802d9e:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802da2:	8d 72 01             	lea    0x1(%edx),%esi
  802da5:	66 89 70 24          	mov    %si,0x24(%eax)
  802da9:	0f b7 d2             	movzwl %dx,%edx
  802dac:	88 8c 13 f0 00 00 00 	mov    %cl,0xf0(%ebx,%edx,1)
}
  802db3:	83 c4 1c             	add    $0x1c,%esp
  802db6:	5b                   	pop    %ebx
  802db7:	5e                   	pop    %esi
  802db8:	5f                   	pop    %edi
  802db9:	5d                   	pop    %ebp
  802dba:	c3                   	ret    

00802dbb <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  802dbb:	55                   	push   %ebp
  802dbc:	89 e5                	mov    %esp,%ebp
  802dbe:	56                   	push   %esi
  802dbf:	53                   	push   %ebx
  802dc0:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  802dc3:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802dc7:	0f b7 d9             	movzwl %cx,%ebx
  802dca:	83 c3 02             	add    $0x2,%ebx
  802dcd:	83 fb 44             	cmp    $0x44,%ebx
  802dd0:	76 1c                	jbe    802dee <dhcp_option_short+0x33>
  802dd2:	c7 44 24 08 78 23 81 	movl   $0x812378,0x8(%esp)
  802dd9:	00 
  802dda:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  802de1:	00 
  802de2:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802de9:	e8 ac c2 00 00       	call   80f09a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  802dee:	8d 71 01             	lea    0x1(%ecx),%esi
  802df1:	66 89 70 24          	mov    %si,0x24(%eax)
  802df5:	0f b7 c9             	movzwl %cx,%ecx
  802df8:	89 d3                	mov    %edx,%ebx
  802dfa:	66 c1 eb 08          	shr    $0x8,%bx
  802dfe:	8b 70 20             	mov    0x20(%eax),%esi
  802e01:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  802e08:	8b 58 20             	mov    0x20(%eax),%ebx
  802e0b:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802e0f:	8d 71 01             	lea    0x1(%ecx),%esi
  802e12:	66 89 70 24          	mov    %si,0x24(%eax)
  802e16:	0f b7 c9             	movzwl %cx,%ecx
  802e19:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802e20:	83 c4 10             	add    $0x10,%esp
  802e23:	5b                   	pop    %ebx
  802e24:	5e                   	pop    %esi
  802e25:	5d                   	pop    %ebp
  802e26:	c3                   	ret    

00802e27 <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  802e27:	55                   	push   %ebp
  802e28:	89 e5                	mov    %esp,%ebp
  802e2a:	53                   	push   %ebx
  802e2b:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  802e2e:	85 c0                	test   %eax,%eax
  802e30:	75 1c                	jne    802e4e <dhcp_option_trailer+0x27>
  802e32:	c7 44 24 08 bc 23 81 	movl   $0x8123bc,0x8(%esp)
  802e39:	00 
  802e3a:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  802e41:	00 
  802e42:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802e49:	e8 4c c2 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  802e4e:	8b 48 20             	mov    0x20(%eax),%ecx
  802e51:	85 c9                	test   %ecx,%ecx
  802e53:	75 1c                	jne    802e71 <dhcp_option_trailer+0x4a>
  802e55:	c7 44 24 08 e0 23 81 	movl   $0x8123e0,0x8(%esp)
  802e5c:	00 
  802e5d:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  802e64:	00 
  802e65:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802e6c:	e8 29 c2 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802e71:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802e75:	66 83 fa 43          	cmp    $0x43,%dx
  802e79:	76 1c                	jbe    802e97 <dhcp_option_trailer+0x70>
  802e7b:	c7 44 24 08 0c 24 81 	movl   $0x81240c,0x8(%esp)
  802e82:	00 
  802e83:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  802e8a:	00 
  802e8b:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802e92:	e8 03 c2 00 00       	call   80f09a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  802e97:	8d 5a 01             	lea    0x1(%edx),%ebx
  802e9a:	66 89 58 24          	mov    %bx,0x24(%eax)
  802e9e:	0f b7 d2             	movzwl %dx,%edx
  802ea1:	c6 84 11 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%edx,1)
  802ea8:	ff 
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802ea9:	eb 31                	jmp    802edc <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  802eab:	c7 44 24 08 0c 24 81 	movl   $0x81240c,0x8(%esp)
  802eb2:	00 
  802eb3:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  802eba:	00 
  802ebb:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802ec2:	e8 d3 c1 00 00       	call   80f09a <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  802ec7:	8b 48 20             	mov    0x20(%eax),%ecx
  802eca:	8d 5a 01             	lea    0x1(%edx),%ebx
  802ecd:	66 89 58 24          	mov    %bx,0x24(%eax)
  802ed1:	0f b7 d2             	movzwl %dx,%edx
  802ed4:	c6 84 11 f0 00 00 00 	movb   $0x0,0xf0(%ecx,%edx,1)
  802edb:	00 
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  802edc:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  802ee0:	66 83 fa 43          	cmp    $0x43,%dx
  802ee4:	76 e1                	jbe    802ec7 <dhcp_option_trailer+0xa0>
  802ee6:	f6 c2 03             	test   $0x3,%dl
  802ee9:	75 c0                	jne    802eab <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  802eeb:	83 c4 14             	add    $0x14,%esp
  802eee:	5b                   	pop    %ebx
  802eef:	5d                   	pop    %ebp
  802ef0:	c3                   	ret    

00802ef1 <dhcp_option_long>:
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
}

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  802ef1:	55                   	push   %ebp
  802ef2:	89 e5                	mov    %esp,%ebp
  802ef4:	56                   	push   %esi
  802ef5:	53                   	push   %ebx
  802ef6:	83 ec 10             	sub    $0x10,%esp
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  802ef9:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802efd:	0f b7 d9             	movzwl %cx,%ebx
  802f00:	83 c3 04             	add    $0x4,%ebx
  802f03:	83 fb 44             	cmp    $0x44,%ebx
  802f06:	76 1c                	jbe    802f24 <dhcp_option_long+0x33>
  802f08:	c7 44 24 08 4c 24 81 	movl   $0x81244c,0x8(%esp)
  802f0f:	00 
  802f10:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  802f17:	00 
  802f18:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802f1f:	e8 76 c1 00 00       	call   80f09a <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  802f24:	8d 71 01             	lea    0x1(%ecx),%esi
  802f27:	66 89 70 24          	mov    %si,0x24(%eax)
  802f2b:	0f b7 c9             	movzwl %cx,%ecx
  802f2e:	89 d3                	mov    %edx,%ebx
  802f30:	c1 eb 18             	shr    $0x18,%ebx
  802f33:	8b 70 20             	mov    0x20(%eax),%esi
  802f36:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  802f3d:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f41:	8d 71 01             	lea    0x1(%ecx),%esi
  802f44:	66 89 70 24          	mov    %si,0x24(%eax)
  802f48:	0f b7 c9             	movzwl %cx,%ecx
  802f4b:	89 d3                	mov    %edx,%ebx
  802f4d:	c1 eb 10             	shr    $0x10,%ebx
  802f50:	8b 70 20             	mov    0x20(%eax),%esi
  802f53:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  802f5a:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f5e:	8d 71 01             	lea    0x1(%ecx),%esi
  802f61:	66 89 70 24          	mov    %si,0x24(%eax)
  802f65:	0f b7 c9             	movzwl %cx,%ecx
  802f68:	0f b6 de             	movzbl %dh,%ebx
  802f6b:	8b 70 20             	mov    0x20(%eax),%esi
  802f6e:	88 9c 0e f0 00 00 00 	mov    %bl,0xf0(%esi,%ecx,1)
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  802f75:	8b 58 20             	mov    0x20(%eax),%ebx
  802f78:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  802f7c:	8d 71 01             	lea    0x1(%ecx),%esi
  802f7f:	66 89 70 24          	mov    %si,0x24(%eax)
  802f83:	0f b7 c9             	movzwl %cx,%ecx
  802f86:	88 94 0b f0 00 00 00 	mov    %dl,0xf0(%ebx,%ecx,1)
}
  802f8d:	83 c4 10             	add    $0x10,%esp
  802f90:	5b                   	pop    %ebx
  802f91:	5e                   	pop    %esi
  802f92:	5d                   	pop    %ebp
  802f93:	c3                   	ret    

00802f94 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  802f94:	55                   	push   %ebp
  802f95:	89 e5                	mov    %esp,%ebp
  802f97:	57                   	push   %edi
  802f98:	56                   	push   %esi
  802f99:	53                   	push   %ebx
  802f9a:	83 ec 1c             	sub    $0x1c,%esp
  802f9d:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  802f9f:	85 c0                	test   %eax,%eax
  802fa1:	75 1c                	jne    802fbf <dhcp_create_request+0x2b>
  802fa3:	c7 44 24 08 8c 24 81 	movl   $0x81248c,0x8(%esp)
  802faa:	00 
  802fab:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  802fb2:	00 
  802fb3:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802fba:	e8 db c0 00 00       	call   80f09a <_panic>
  dhcp = netif->dhcp;
  802fbf:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  802fc2:	85 db                	test   %ebx,%ebx
  802fc4:	75 1c                	jne    802fe2 <dhcp_create_request+0x4e>
  802fc6:	c7 44 24 08 b0 24 81 	movl   $0x8124b0,0x8(%esp)
  802fcd:	00 
  802fce:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  802fd5:	00 
  802fd6:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802fdd:	e8 b8 c0 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  802fe2:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  802fe6:	74 1c                	je     803004 <dhcp_create_request+0x70>
  802fe8:	c7 44 24 08 d4 24 81 	movl   $0x8124d4,0x8(%esp)
  802fef:	00 
  802ff0:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  802ff7:	00 
  802ff8:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  802fff:	e8 96 c0 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  803004:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  803008:	74 1c                	je     803026 <dhcp_create_request+0x92>
  80300a:	c7 44 24 08 00 25 81 	movl   $0x812500,0x8(%esp)
  803011:	00 
  803012:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  803019:	00 
  80301a:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  803021:	e8 74 c0 00 00       	call   80f09a <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  803026:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80302d:	00 
  80302e:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  803035:	00 
  803036:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80303d:	e8 c3 1e 00 00       	call   804f05 <pbuf_alloc>
  803042:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  803045:	85 c0                	test   %eax,%eax
  803047:	0f 84 2a 01 00 00    	je     803177 <dhcp_create_request+0x1e3>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  80304d:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  803053:	77 1c                	ja     803071 <dhcp_create_request+0xdd>
  803055:	c7 44 24 08 2c 25 81 	movl   $0x81252c,0x8(%esp)
  80305c:	00 
  80305d:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  803064:	00 
  803065:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  80306c:	e8 29 c0 00 00       	call   80f09a <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  803071:	8b 15 04 50 81 00    	mov    0x815004,%edx
  803077:	8d 4a 01             	lea    0x1(%edx),%ecx
  80307a:	89 0d 04 50 81 00    	mov    %ecx,0x815004
  803080:	89 53 04             	mov    %edx,0x4(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  803083:	8b 40 04             	mov    0x4(%eax),%eax
  803086:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  803089:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  80308c:	8b 43 20             	mov    0x20(%ebx),%eax
  80308f:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  803093:	8b 43 20             	mov    0x20(%ebx),%eax
  803096:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  80309a:	8b 43 20             	mov    0x20(%ebx),%eax
  80309d:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  8030a1:	8b 73 20             	mov    0x20(%ebx),%esi
  8030a4:	8b 43 04             	mov    0x4(%ebx),%eax
  8030a7:	89 04 24             	mov    %eax,(%esp)
  8030aa:	e8 11 4d 00 00       	call   807dc0 <htonl>
  8030af:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  8030b2:	8b 43 20             	mov    0x20(%ebx),%eax
  8030b5:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  8030bb:	8b 43 20             	mov    0x20(%ebx),%eax
  8030be:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  8030c4:	8b 43 20             	mov    0x20(%ebx),%eax
  8030c7:	8b 57 04             	mov    0x4(%edi),%edx
  8030ca:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  8030cd:	8b 43 20             	mov    0x20(%ebx),%eax
  8030d0:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  8030d7:	8b 43 20             	mov    0x20(%ebx),%eax
  8030da:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  8030e1:	8b 43 20             	mov    0x20(%ebx),%eax
  8030e4:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  8030eb:	b8 00 00 00 00       	mov    $0x0,%eax
  8030f0:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  8030f3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8030f6:	8b 59 20             	mov    0x20(%ecx),%ebx
  8030f9:	89 c1                	mov    %eax,%ecx
  8030fb:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  8030ff:	ba 00 00 00 00       	mov    $0x0,%edx
  803104:	66 39 c6             	cmp    %ax,%si
  803107:	76 05                	jbe    80310e <dhcp_create_request+0x17a>
  803109:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  80310e:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  803112:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  803115:	83 f8 10             	cmp    $0x10,%eax
  803118:	75 d9                	jne    8030f3 <dhcp_create_request+0x15f>
  80311a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80311d:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  80311f:	8b 53 20             	mov    0x20(%ebx),%edx
  803122:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  803127:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  80312a:	83 f8 40             	cmp    $0x40,%eax
  80312d:	75 f0                	jne    80311f <dhcp_create_request+0x18b>
  80312f:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  803131:	8b 53 20             	mov    0x20(%ebx),%edx
  803134:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  803139:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  80313c:	3d 80 00 00 00       	cmp    $0x80,%eax
  803141:	75 ee                	jne    803131 <dhcp_create_request+0x19d>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  803143:	8b 73 20             	mov    0x20(%ebx),%esi
  803146:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  80314d:	e8 6e 4c 00 00       	call   807dc0 <htonl>
  803152:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  803158:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  80315e:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  803163:	8b 53 20             	mov    0x20(%ebx),%edx
  803166:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  80316d:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  803170:	83 f8 44             	cmp    $0x44,%eax
  803173:	75 ee                	jne    803163 <dhcp_create_request+0x1cf>
  803175:	eb 07                	jmp    80317e <dhcp_create_request+0x1ea>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  803177:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80317c:	eb 05                	jmp    803183 <dhcp_create_request+0x1ef>
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  80317e:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803183:	83 c4 1c             	add    $0x1c,%esp
  803186:	5b                   	pop    %ebx
  803187:	5e                   	pop    %esi
  803188:	5f                   	pop    %edi
  803189:	5d                   	pop    %ebp
  80318a:	c3                   	ret    

0080318b <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  80318b:	55                   	push   %ebp
  80318c:	89 e5                	mov    %esp,%ebp
  80318e:	53                   	push   %ebx
  80318f:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  803192:	85 c0                	test   %eax,%eax
  803194:	75 1c                	jne    8031b2 <dhcp_delete_request+0x27>
  803196:	c7 44 24 08 70 25 81 	movl   $0x812570,0x8(%esp)
  80319d:	00 
  80319e:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  8031a5:	00 
  8031a6:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8031ad:	e8 e8 be 00 00       	call   80f09a <_panic>
  dhcp = netif->dhcp;
  8031b2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  8031b5:	85 db                	test   %ebx,%ebx
  8031b7:	75 1c                	jne    8031d5 <dhcp_delete_request+0x4a>
  8031b9:	c7 44 24 08 94 25 81 	movl   $0x812594,0x8(%esp)
  8031c0:	00 
  8031c1:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  8031c8:	00 
  8031c9:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8031d0:	e8 c5 be 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  8031d5:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8031d8:	85 c0                	test   %eax,%eax
  8031da:	75 1c                	jne    8031f8 <dhcp_delete_request+0x6d>
  8031dc:	c7 44 24 08 b8 25 81 	movl   $0x8125b8,0x8(%esp)
  8031e3:	00 
  8031e4:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  8031eb:	00 
  8031ec:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8031f3:	e8 a2 be 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8031f8:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8031fc:	75 1c                	jne    80321a <dhcp_delete_request+0x8f>
  8031fe:	c7 44 24 08 e4 25 81 	movl   $0x8125e4,0x8(%esp)
  803205:	00 
  803206:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  80320d:	00 
  80320e:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  803215:	e8 80 be 00 00       	call   80f09a <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  80321a:	89 04 24             	mov    %eax,(%esp)
  80321d:	e8 02 1c 00 00       	call   804e24 <pbuf_free>
  }
  dhcp->p_out = NULL;
  803222:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  803229:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  803230:	83 c4 14             	add    $0x14,%esp
  803233:	5b                   	pop    %ebx
  803234:	5d                   	pop    %ebp
  803235:	c3                   	ret    

00803236 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  803236:	55                   	push   %ebp
  803237:	89 e5                	mov    %esp,%ebp
  803239:	57                   	push   %edi
  80323a:	56                   	push   %esi
  80323b:	53                   	push   %ebx
  80323c:	83 ec 2c             	sub    $0x2c,%esp
  80323f:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  803241:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  803244:	ba 04 00 00 00       	mov    $0x4,%edx
  803249:	89 d8                	mov    %ebx,%eax
  80324b:	e8 80 f9 ff ff       	call   802bd0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803250:	89 f8                	mov    %edi,%eax
  803252:	e8 3d fd ff ff       	call   802f94 <dhcp_create_request>
  803257:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803259:	84 c0                	test   %al,%al
  80325b:	0f 85 a3 00 00 00    	jne    803304 <dhcp_rebind+0xce>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803261:	b9 01 00 00 00       	mov    $0x1,%ecx
  803266:	ba 35 00 00 00       	mov    $0x35,%edx
  80326b:	89 d8                	mov    %ebx,%eax
  80326d:	e8 dd fa ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803272:	ba 03 00 00 00       	mov    $0x3,%edx
  803277:	89 d8                	mov    %ebx,%eax
  803279:	e8 88 fa ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80327e:	b9 02 00 00 00       	mov    $0x2,%ecx
  803283:	ba 39 00 00 00       	mov    $0x39,%edx
  803288:	89 d8                	mov    %ebx,%eax
  80328a:	e8 c0 fa ff ff       	call   802d4f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80328f:	ba 40 02 00 00       	mov    $0x240,%edx
  803294:	89 d8                	mov    %ebx,%eax
  803296:	e8 20 fb ff ff       	call   802dbb <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  80329b:	89 d8                	mov    %ebx,%eax
  80329d:	e8 85 fb ff ff       	call   802e27 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8032a2:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8032a6:	66 05 f0 00          	add    $0xf0,%ax
  8032aa:	0f b7 c0             	movzwl %ax,%eax
  8032ad:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032b1:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8032b4:	89 04 24             	mov    %eax,(%esp)
  8032b7:	e8 da 1e 00 00       	call   805196 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8032bc:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8032c3:	00 
  8032c4:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  8032cb:	00 
  8032cc:	8b 43 08             	mov    0x8(%ebx),%eax
  8032cf:	89 04 24             	mov    %eax,(%esp)
  8032d2:	e8 8e 64 00 00       	call   809765 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8032d7:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8032db:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8032e2:	00 
  8032e3:	c7 44 24 08 fc 2e 81 	movl   $0x812efc,0x8(%esp)
  8032ea:	00 
  8032eb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8032ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032f2:	8b 43 08             	mov    0x8(%ebx),%eax
  8032f5:	89 04 24             	mov    %eax,(%esp)
  8032f8:	e8 46 62 00 00       	call   809543 <udp_sendto_if>
    dhcp_delete_request(netif);
  8032fd:	89 f8                	mov    %edi,%eax
  8032ff:	e8 87 fe ff ff       	call   80318b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803304:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  803308:	8d 48 01             	lea    0x1(%eax),%ecx
  80330b:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80330e:	b8 10 27 00 00       	mov    $0x2710,%eax
  803313:	80 f9 09             	cmp    $0x9,%cl
  803316:	77 08                	ja     803320 <dhcp_rebind+0xea>
  803318:	0f b6 c9             	movzbl %cl,%ecx
  80331b:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803320:	0f b7 d0             	movzwl %ax,%edx
  803323:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803329:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
  80332e:	89 d0                	mov    %edx,%eax
  803330:	f7 ef                	imul   %edi
  803332:	c1 fa 05             	sar    $0x5,%edx
  803335:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803339:	89 f0                	mov    %esi,%eax
  80333b:	83 c4 2c             	add    $0x2c,%esp
  80333e:	5b                   	pop    %ebx
  80333f:	5e                   	pop    %esi
  803340:	5f                   	pop    %edi
  803341:	5d                   	pop    %ebp
  803342:	c3                   	ret    

00803343 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  803343:	55                   	push   %ebp
  803344:	89 e5                	mov    %esp,%ebp
  803346:	57                   	push   %edi
  803347:	56                   	push   %esi
  803348:	53                   	push   %ebx
  803349:	83 ec 2c             	sub    $0x2c,%esp
  80334c:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80334e:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  803351:	a1 00 2f 81 00       	mov    0x812f00,%eax
  803356:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803359:	89 f8                	mov    %edi,%eax
  80335b:	e8 34 fc ff ff       	call   802f94 <dhcp_create_request>
  803360:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  803362:	84 c0                	test   %al,%al
  803364:	0f 85 f0 00 00 00    	jne    80345a <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80336a:	b9 01 00 00 00       	mov    $0x1,%ecx
  80336f:	ba 35 00 00 00       	mov    $0x35,%edx
  803374:	89 d8                	mov    %ebx,%eax
  803376:	e8 d4 f9 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80337b:	ba 01 00 00 00       	mov    $0x1,%edx
  803380:	89 d8                	mov    %ebx,%eax
  803382:	e8 7f f9 ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803387:	b9 02 00 00 00       	mov    $0x2,%ecx
  80338c:	ba 39 00 00 00       	mov    $0x39,%edx
  803391:	89 d8                	mov    %ebx,%eax
  803393:	e8 b7 f9 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803398:	ba 40 02 00 00       	mov    $0x240,%edx
  80339d:	89 d8                	mov    %ebx,%eax
  80339f:	e8 17 fa ff ff       	call   802dbb <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8033a4:	b9 04 00 00 00       	mov    $0x4,%ecx
  8033a9:	ba 37 00 00 00       	mov    $0x37,%edx
  8033ae:	89 d8                	mov    %ebx,%eax
  8033b0:	e8 9a f9 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8033b5:	ba 01 00 00 00       	mov    $0x1,%edx
  8033ba:	89 d8                	mov    %ebx,%eax
  8033bc:	e8 45 f9 ff ff       	call   802d06 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8033c1:	ba 03 00 00 00       	mov    $0x3,%edx
  8033c6:	89 d8                	mov    %ebx,%eax
  8033c8:	e8 39 f9 ff ff       	call   802d06 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8033cd:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8033d2:	89 d8                	mov    %ebx,%eax
  8033d4:	e8 2d f9 ff ff       	call   802d06 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8033d9:	ba 06 00 00 00       	mov    $0x6,%edx
  8033de:	89 d8                	mov    %ebx,%eax
  8033e0:	e8 21 f9 ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  8033e5:	89 d8                	mov    %ebx,%eax
  8033e7:	e8 3b fa ff ff       	call   802e27 <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8033ec:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8033f0:	66 05 f0 00          	add    $0xf0,%ax
  8033f4:	0f b7 c0             	movzwl %ax,%eax
  8033f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8033fb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8033fe:	89 04 24             	mov    %eax,(%esp)
  803401:	e8 90 1d 00 00       	call   805196 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803406:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80340d:	00 
  80340e:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803415:	00 
  803416:	8b 43 08             	mov    0x8(%ebx),%eax
  803419:	89 04 24             	mov    %eax,(%esp)
  80341c:	e8 44 63 00 00       	call   809765 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803421:	89 7c 24 10          	mov    %edi,0x10(%esp)
  803425:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80342c:	00 
  80342d:	c7 44 24 08 fc 2e 81 	movl   $0x812efc,0x8(%esp)
  803434:	00 
  803435:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803438:	89 44 24 04          	mov    %eax,0x4(%esp)
  80343c:	8b 43 08             	mov    0x8(%ebx),%eax
  80343f:	89 04 24             	mov    %eax,(%esp)
  803442:	e8 fc 60 00 00       	call   809543 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  803447:	89 f8                	mov    %edi,%eax
  803449:	e8 3d fd ff ff       	call   80318b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80344e:	ba 06 00 00 00       	mov    $0x6,%edx
  803453:	89 d8                	mov    %ebx,%eax
  803455:	e8 76 f7 ff ff       	call   802bd0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80345a:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  80345e:	8d 48 01             	lea    0x1(%eax),%ecx
  803461:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  803464:	b8 10 27 00 00       	mov    $0x2710,%eax
  803469:	80 f9 03             	cmp    $0x3,%cl
  80346c:	77 0b                	ja     803479 <dhcp_discover+0x136>
  80346e:	0f b6 c1             	movzbl %cl,%eax
  803471:	83 c0 01             	add    $0x1,%eax
  803474:	66 69 c0 e8 03       	imul   $0x3e8,%ax,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803479:	0f b7 d0             	movzwl %ax,%edx
  80347c:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803482:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  803487:	89 d0                	mov    %edx,%eax
  803489:	f7 e9                	imul   %ecx
  80348b:	c1 fa 05             	sar    $0x5,%edx
  80348e:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803492:	89 f0                	mov    %esi,%eax
  803494:	83 c4 2c             	add    $0x2c,%esp
  803497:	5b                   	pop    %ebx
  803498:	5e                   	pop    %esi
  803499:	5f                   	pop    %edi
  80349a:	5d                   	pop    %ebp
  80349b:	c3                   	ret    

0080349c <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80349c:	55                   	push   %ebp
  80349d:	89 e5                	mov    %esp,%ebp
  80349f:	57                   	push   %edi
  8034a0:	56                   	push   %esi
  8034a1:	53                   	push   %ebx
  8034a2:	83 ec 2c             	sub    $0x2c,%esp
  8034a5:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8034a7:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8034aa:	e8 e5 fa ff ff       	call   802f94 <dhcp_create_request>
  8034af:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8034b1:	84 c0                	test   %al,%al
  8034b3:	0f 85 3a 01 00 00    	jne    8035f3 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8034b9:	b9 01 00 00 00       	mov    $0x1,%ecx
  8034be:	ba 35 00 00 00       	mov    $0x35,%edx
  8034c3:	89 d8                	mov    %ebx,%eax
  8034c5:	e8 85 f8 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8034ca:	ba 03 00 00 00       	mov    $0x3,%edx
  8034cf:	89 d8                	mov    %ebx,%eax
  8034d1:	e8 30 f8 ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8034d6:	b9 02 00 00 00       	mov    $0x2,%ecx
  8034db:	ba 39 00 00 00       	mov    $0x39,%edx
  8034e0:	89 d8                	mov    %ebx,%eax
  8034e2:	e8 68 f8 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8034e7:	ba 40 02 00 00       	mov    $0x240,%edx
  8034ec:	89 d8                	mov    %ebx,%eax
  8034ee:	e8 c8 f8 ff ff       	call   802dbb <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8034f3:	b9 04 00 00 00       	mov    $0x4,%ecx
  8034f8:	ba 32 00 00 00       	mov    $0x32,%edx
  8034fd:	89 d8                	mov    %ebx,%eax
  8034ff:	e8 4b f8 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803504:	8b 43 30             	mov    0x30(%ebx),%eax
  803507:	89 04 24             	mov    %eax,(%esp)
  80350a:	e8 eb 4a 00 00       	call   807ffa <ntohl>
  80350f:	89 c2                	mov    %eax,%edx
  803511:	89 d8                	mov    %ebx,%eax
  803513:	e8 d9 f9 ff ff       	call   802ef1 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  803518:	b9 04 00 00 00       	mov    $0x4,%ecx
  80351d:	ba 36 00 00 00       	mov    $0x36,%edx
  803522:	89 d8                	mov    %ebx,%eax
  803524:	e8 26 f8 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  803529:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80352c:	89 04 24             	mov    %eax,(%esp)
  80352f:	e8 c6 4a 00 00       	call   807ffa <ntohl>
  803534:	89 c2                	mov    %eax,%edx
  803536:	89 d8                	mov    %ebx,%eax
  803538:	e8 b4 f9 ff ff       	call   802ef1 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  80353d:	b9 04 00 00 00       	mov    $0x4,%ecx
  803542:	ba 37 00 00 00       	mov    $0x37,%edx
  803547:	89 d8                	mov    %ebx,%eax
  803549:	e8 01 f8 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80354e:	ba 01 00 00 00       	mov    $0x1,%edx
  803553:	89 d8                	mov    %ebx,%eax
  803555:	e8 ac f7 ff ff       	call   802d06 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80355a:	ba 03 00 00 00       	mov    $0x3,%edx
  80355f:	89 d8                	mov    %ebx,%eax
  803561:	e8 a0 f7 ff ff       	call   802d06 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  803566:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80356b:	89 d8                	mov    %ebx,%eax
  80356d:	e8 94 f7 ff ff       	call   802d06 <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  803572:	ba 06 00 00 00       	mov    $0x6,%edx
  803577:	89 d8                	mov    %ebx,%eax
  803579:	e8 88 f7 ff ff       	call   802d06 <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  80357e:	89 d8                	mov    %ebx,%eax
  803580:	e8 a2 f8 ff ff       	call   802e27 <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803585:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803589:	66 05 f0 00          	add    $0xf0,%ax
  80358d:	0f b7 c0             	movzwl %ax,%eax
  803590:	89 44 24 04          	mov    %eax,0x4(%esp)
  803594:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803597:	89 04 24             	mov    %eax,(%esp)
  80359a:	e8 f7 1b 00 00       	call   805196 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80359f:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8035a3:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8035aa:	00 
  8035ab:	c7 44 24 08 fc 2e 81 	movl   $0x812efc,0x8(%esp)
  8035b2:	00 
  8035b3:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8035b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8035ba:	8b 43 08             	mov    0x8(%ebx),%eax
  8035bd:	89 04 24             	mov    %eax,(%esp)
  8035c0:	e8 7e 5f 00 00       	call   809543 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8035c5:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8035cc:	00 
  8035cd:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  8035d4:	00 
  8035d5:	8b 43 08             	mov    0x8(%ebx),%eax
  8035d8:	89 04 24             	mov    %eax,(%esp)
  8035db:	e8 85 61 00 00       	call   809765 <udp_connect>
    dhcp_delete_request(netif);
  8035e0:	89 f8                	mov    %edi,%eax
  8035e2:	e8 a4 fb ff ff       	call   80318b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  8035e7:	ba 01 00 00 00       	mov    $0x1,%edx
  8035ec:	89 d8                	mov    %ebx,%eax
  8035ee:	e8 dd f5 ff ff       	call   802bd0 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8035f3:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8035f7:	8d 48 01             	lea    0x1(%eax),%ecx
  8035fa:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8035fd:	b8 a0 0f 00 00       	mov    $0xfa0,%eax
  803602:	80 f9 03             	cmp    $0x3,%cl
  803605:	77 08                	ja     80360f <dhcp_select+0x173>
  803607:	0f b6 c9             	movzbl %cl,%ecx
  80360a:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80360f:	0f b7 d0             	movzwl %ax,%edx
  803612:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  803618:	bf d3 4d 62 10       	mov    $0x10624dd3,%edi
  80361d:	89 d0                	mov    %edx,%eax
  80361f:	f7 ef                	imul   %edi
  803621:	c1 fa 05             	sar    $0x5,%edx
  803624:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  803628:	89 f0                	mov    %esi,%eax
  80362a:	83 c4 2c             	add    $0x2c,%esp
  80362d:	5b                   	pop    %ebx
  80362e:	5e                   	pop    %esi
  80362f:	5f                   	pop    %edi
  803630:	5d                   	pop    %ebp
  803631:	c3                   	ret    

00803632 <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  803632:	55                   	push   %ebp
  803633:	89 e5                	mov    %esp,%ebp
  803635:	53                   	push   %ebx
  803636:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  803639:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  80363c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  803643:	00 
  803644:	8d 53 30             	lea    0x30(%ebx),%edx
  803647:	89 54 24 04          	mov    %edx,0x4(%esp)
  80364b:	89 04 24             	mov    %eax,(%esp)
  80364e:	e8 e1 6a 00 00       	call   80a134 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  803653:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803657:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  80365d:	ba 08 00 00 00       	mov    $0x8,%edx
  803662:	89 d8                	mov    %ebx,%eax
  803664:	e8 67 f5 ff ff       	call   802bd0 <dhcp_set_state>
}
  803669:	83 c4 14             	add    $0x14,%esp
  80366c:	5b                   	pop    %ebx
  80366d:	5d                   	pop    %ebp
  80366e:	c3                   	ret    

0080366f <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  80366f:	55                   	push   %ebp
  803670:	89 e5                	mov    %esp,%ebp
  803672:	57                   	push   %edi
  803673:	56                   	push   %esi
  803674:	53                   	push   %ebx
  803675:	83 ec 2c             	sub    $0x2c,%esp
  803678:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  80367a:	85 c0                	test   %eax,%eax
  80367c:	75 1c                	jne    80369a <dhcp_bind+0x2b>
  80367e:	c7 44 24 08 57 26 81 	movl   $0x812657,0x8(%esp)
  803685:	00 
  803686:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  80368d:	00 
  80368e:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  803695:	e8 00 ba 00 00       	call   80f09a <_panic>
  dhcp = netif->dhcp;
  80369a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  80369d:	85 db                	test   %ebx,%ebx
  80369f:	75 1c                	jne    8036bd <dhcp_bind+0x4e>
  8036a1:	c7 44 24 08 70 26 81 	movl   $0x812670,0x8(%esp)
  8036a8:	00 
  8036a9:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  8036b0:	00 
  8036b1:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8036b8:	e8 dd b9 00 00       	call   80f09a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  8036bd:	8b 43 50             	mov    0x50(%ebx),%eax
  8036c0:	83 f8 ff             	cmp    $0xffffffff,%eax
  8036c3:	74 2a                	je     8036ef <dhcp_bind+0x80>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8036c5:	83 c0 1e             	add    $0x1e,%eax
  8036c8:	ba 89 88 88 88       	mov    $0x88888889,%edx
  8036cd:	f7 e2                	mul    %edx
  8036cf:	c1 ea 05             	shr    $0x5,%edx
  8036d2:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8036d8:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8036dd:	0f 46 c2             	cmovbe %edx,%eax
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  8036e0:	66 85 c0             	test   %ax,%ax
  8036e3:	ba 01 00 00 00       	mov    $0x1,%edx
  8036e8:	0f 44 c2             	cmove  %edx,%eax
  8036eb:	66 89 43 28          	mov    %ax,0x28(%ebx)
      dhcp->t1_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  8036ef:	8b 43 54             	mov    0x54(%ebx),%eax
  8036f2:	83 f8 ff             	cmp    $0xffffffff,%eax
  8036f5:	74 2a                	je     803721 <dhcp_bind+0xb2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8036f7:	83 c0 1e             	add    $0x1e,%eax
  8036fa:	ba 89 88 88 88       	mov    $0x88888889,%edx
  8036ff:	f7 e2                	mul    %edx
  803701:	c1 ea 05             	shr    $0x5,%edx
  803704:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  80370a:	b8 ff ff 00 00       	mov    $0xffff,%eax
  80370f:	0f 46 c2             	cmovbe %edx,%eax
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  803712:	66 85 c0             	test   %ax,%ax
  803715:	ba 01 00 00 00       	mov    $0x1,%edx
  80371a:	0f 44 c2             	cmove  %edx,%eax
  80371d:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  803721:	83 fb cc             	cmp    $0xffffffcc,%ebx
  803724:	0f 84 be 00 00 00    	je     8037e8 <dhcp_bind+0x179>
  80372a:	8b 43 34             	mov    0x34(%ebx),%eax
  80372d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  803730:	85 c0                	test   %eax,%eax
  803732:	75 48                	jne    80377c <dhcp_bind+0x10d>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  803734:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80373b:	e8 ba 48 00 00       	call   807ffa <ntohl>
  803740:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  803743:	84 c0                	test   %al,%al
  803745:	78 11                	js     803758 <dhcp_bind+0xe9>
      sn_mask.addr = htonl(0xff000000);
  803747:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  80374e:	e8 6d 46 00 00       	call   807dc0 <htonl>
  803753:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803756:	eb 24                	jmp    80377c <dhcp_bind+0x10d>
    } else if (first_octet >= 192) {
  803758:	3c bf                	cmp    $0xbf,%al
  80375a:	76 11                	jbe    80376d <dhcp_bind+0xfe>
      sn_mask.addr = htonl(0xffffff00);
  80375c:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  803763:	e8 58 46 00 00       	call   807dc0 <htonl>
  803768:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80376b:	eb 0f                	jmp    80377c <dhcp_bind+0x10d>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  80376d:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  803774:	e8 47 46 00 00       	call   807dc0 <htonl>
  803779:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  80377c:	83 fb c8             	cmp    $0xffffffc8,%ebx
  80377f:	74 0a                	je     80378b <dhcp_bind+0x11c>
  803781:	8b 43 38             	mov    0x38(%ebx),%eax
  803784:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  803787:	85 c0                	test   %eax,%eax
  803789:	75 1a                	jne    8037a5 <dhcp_bind+0x136>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  80378b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80378e:	23 7b 30             	and    0x30(%ebx),%edi
  803791:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  803794:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80379b:	e8 20 46 00 00       	call   807dc0 <htonl>
  8037a0:	09 c7                	or     %eax,%edi
  8037a2:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  8037a5:	8d 43 30             	lea    0x30(%ebx),%eax
  8037a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8037ac:	89 34 24             	mov    %esi,(%esp)
  8037af:	e8 93 13 00 00       	call   804b47 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  8037b4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8037b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8037bb:	89 34 24             	mov    %esi,(%esp)
  8037be:	e8 f5 14 00 00       	call   804cb8 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  8037c3:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8037c6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8037ca:	89 34 24             	mov    %esi,(%esp)
  8037cd:	e8 cb 14 00 00       	call   804c9d <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  8037d2:	89 34 24             	mov    %esi,(%esp)
  8037d5:	e8 06 15 00 00       	call   804ce0 <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  8037da:	ba 0a 00 00 00       	mov    $0xa,%edx
  8037df:	89 d8                	mov    %ebx,%eax
  8037e1:	e8 ea f3 ff ff       	call   802bd0 <dhcp_set_state>
  8037e6:	eb 0c                	jmp    8037f4 <dhcp_bind+0x185>
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  8037e8:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  8037ef:	e9 40 ff ff ff       	jmp    803734 <dhcp_bind+0xc5>
  netif_set_gw(netif, &gw_addr);
  /* bring the interface up */
  netif_set_up(netif);
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
}
  8037f4:	83 c4 2c             	add    $0x2c,%esp
  8037f7:	5b                   	pop    %ebx
  8037f8:	5e                   	pop    %esi
  8037f9:	5f                   	pop    %edi
  8037fa:	5d                   	pop    %ebp
  8037fb:	c3                   	ret    

008037fc <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  8037fc:	55                   	push   %ebp
  8037fd:	89 e5                	mov    %esp,%ebp
  8037ff:	53                   	push   %ebx
  803800:	83 ec 14             	sub    $0x14,%esp
  803803:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  803805:	8b 40 10             	mov    0x10(%eax),%eax
  803808:	85 c0                	test   %eax,%eax
  80380a:	74 0f                	je     80381b <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  80380c:	89 04 24             	mov    %eax,(%esp)
  80380f:	e8 01 0d 00 00       	call   804515 <mem_free>
    dhcp->msg_in = NULL;
  803814:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  80381b:	8b 43 14             	mov    0x14(%ebx),%eax
  80381e:	85 c0                	test   %eax,%eax
  803820:	74 15                	je     803837 <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  803822:	89 04 24             	mov    %eax,(%esp)
  803825:	e8 eb 0c 00 00       	call   804515 <mem_free>
    dhcp->options_in = NULL;
  80382a:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  803831:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  803837:	83 c4 14             	add    $0x14,%esp
  80383a:	5b                   	pop    %ebx
  80383b:	5d                   	pop    %ebp
  80383c:	c3                   	ret    

0080383d <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  80383d:	55                   	push   %ebp
  80383e:	89 e5                	mov    %esp,%ebp
  803840:	57                   	push   %edi
  803841:	56                   	push   %esi
  803842:	53                   	push   %ebx
  803843:	83 ec 2c             	sub    $0x2c,%esp
  803846:	8b 5d 08             	mov    0x8(%ebp),%ebx
  803849:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  80384c:	8b 73 20             	mov    0x20(%ebx),%esi
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  80384f:	8b 4f 04             	mov    0x4(%edi),%ecx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  803852:	89 7e 0c             	mov    %edi,0xc(%esi)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  803855:	80 39 02             	cmpb   $0x2,(%ecx)
  803858:	0f 85 0d 04 00 00    	jne    803c6b <dhcp_recv+0x42e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  80385e:	0f b6 43 24          	movzbl 0x24(%ebx),%eax
  803862:	ba 00 00 00 00       	mov    $0x0,%edx
  803867:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  80386a:	89 ce                	mov    %ecx,%esi
  80386c:	89 c1                	mov    %eax,%ecx
  80386e:	eb 12                	jmp    803882 <dhcp_recv+0x45>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  803870:	0f b6 44 13 25       	movzbl 0x25(%ebx,%edx,1),%eax
  803875:	83 c2 01             	add    $0x1,%edx
  803878:	3a 44 16 1b          	cmp    0x1b(%esi,%edx,1),%al
  80387c:	0f 85 e6 03 00 00    	jne    803c68 <dhcp_recv+0x42b>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  803882:	38 d1                	cmp    %dl,%cl
  803884:	77 ea                	ja     803870 <dhcp_recv+0x33>
  803886:	89 f1                	mov    %esi,%ecx
  803888:	8b 75 e4             	mov    -0x1c(%ebp),%esi
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  80388b:	8b 41 04             	mov    0x4(%ecx),%eax
  80388e:	89 04 24             	mov    %eax,(%esp)
  803891:	e8 64 47 00 00       	call   807ffa <ntohl>
  803896:	3b 46 04             	cmp    0x4(%esi),%eax
  803899:	0f 85 cc 03 00 00    	jne    803c6b <dhcp_recv+0x42e>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  80389f:	85 f6                	test   %esi,%esi
  8038a1:	75 1c                	jne    8038bf <dhcp_recv+0x82>
  8038a3:	c7 44 24 08 7b 26 81 	movl   $0x81267b,0x8(%esp)
  8038aa:	00 
  8038ab:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  8038b2:	00 
  8038b3:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8038ba:	e8 db b7 00 00       	call   80f09a <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  8038bf:	83 7e 0c 00          	cmpl   $0x0,0xc(%esi)
  8038c3:	75 1c                	jne    8038e1 <dhcp_recv+0xa4>
  8038c5:	c7 44 24 08 88 26 81 	movl   $0x812688,0x8(%esp)
  8038cc:	00 
  8038cd:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  8038d4:	00 
  8038d5:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8038dc:	e8 b9 b7 00 00       	call   80f09a <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  8038e1:	89 f0                	mov    %esi,%eax
  8038e3:	e8 14 ff ff ff       	call   8037fc <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  8038e8:	8b 46 0c             	mov    0xc(%esi),%eax
  8038eb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8038ef:	66 3d f0 00          	cmp    $0xf0,%ax
  8038f3:	76 1e                	jbe    803913 <dhcp_recv+0xd6>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  8038f5:	66 2d f0 00          	sub    $0xf0,%ax
  8038f9:	66 89 46 18          	mov    %ax,0x18(%esi)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  8038fd:	0f b7 c0             	movzwl %ax,%eax
  803900:	89 04 24             	mov    %eax,(%esp)
  803903:	e8 e7 0e 00 00       	call   8047ef <mem_malloc>
  803908:	89 46 14             	mov    %eax,0x14(%esi)
    if (dhcp->options_in == NULL) {
  80390b:	85 c0                	test   %eax,%eax
  80390d:	0f 84 58 03 00 00    	je     803c6b <dhcp_recv+0x42e>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803913:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  80391a:	e8 d0 0e 00 00       	call   8047ef <mem_malloc>
  80391f:	89 46 10             	mov    %eax,0x10(%esi)
  if (dhcp->msg_in == NULL) {
  803922:	85 c0                	test   %eax,%eax
  803924:	75 17                	jne    80393d <dhcp_recv+0x100>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  803926:	8b 46 14             	mov    0x14(%esi),%eax
  803929:	89 04 24             	mov    %eax,(%esp)
  80392c:	e8 e4 0b 00 00       	call   804515 <mem_free>
    dhcp->options_in = NULL;
  803931:	c7 46 14 00 00 00 00 	movl   $0x0,0x14(%esi)
  803938:	e9 2e 03 00 00       	jmp    803c6b <dhcp_recv+0x42e>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  80393d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  803944:	00 
  803945:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  80394c:	00 
  80394d:	89 44 24 04          	mov    %eax,0x4(%esp)
  803951:	8b 46 0c             	mov    0xc(%esi),%eax
  803954:	89 04 24             	mov    %eax,(%esp)
  803957:	e8 73 1c 00 00       	call   8055cf <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  80395c:	66 3d f0 00          	cmp    $0xf0,%ax
  803960:	74 1c                	je     80397e <dhcp_recv+0x141>
  803962:	c7 44 24 08 10 26 81 	movl   $0x812610,0x8(%esp)
  803969:	00 
  80396a:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  803971:	00 
  803972:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  803979:	e8 1c b7 00 00       	call   80f09a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  80397e:	8b 46 14             	mov    0x14(%esi),%eax
  803981:	85 c0                	test   %eax,%eax
  803983:	0f 84 f3 02 00 00    	je     803c7c <dhcp_recv+0x43f>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  803989:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  803990:	00 
  803991:	0f b7 56 18          	movzwl 0x18(%esi),%edx
  803995:	89 54 24 08          	mov    %edx,0x8(%esp)
  803999:	89 44 24 04          	mov    %eax,0x4(%esp)
  80399d:	8b 46 0c             	mov    0xc(%esi),%eax
  8039a0:	89 04 24             	mov    %eax,(%esp)
  8039a3:	e8 27 1c 00 00       	call   8055cf <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  8039a8:	66 3b 46 18          	cmp    0x18(%esi),%ax
  8039ac:	0f 84 ca 02 00 00    	je     803c7c <dhcp_recv+0x43f>
  8039b2:	c7 44 24 08 98 26 81 	movl   $0x812698,0x8(%esp)
  8039b9:	00 
  8039ba:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  8039c1:	00 
  8039c2:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8039c9:	e8 cc b6 00 00       	call   80f09a <_panic>
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
  8039ce:	0f b6 40 02          	movzbl 0x2(%eax),%eax
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  8039d2:	3c 05                	cmp    $0x5,%al
  8039d4:	0f 85 c3 01 00 00    	jne    803b9d <dhcp_recv+0x360>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  8039da:	0f b6 06             	movzbl (%esi),%eax
  8039dd:	3c 01                	cmp    $0x1,%al
  8039df:	0f 85 9b 01 00 00    	jne    803b80 <dhcp_recv+0x343>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8039e5:	8b 43 20             	mov    0x20(%ebx),%eax
  8039e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  8039eb:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)
  dhcp->offered_gw_addr.addr = 0;
  8039f2:	c7 40 38 00 00 00 00 	movl   $0x0,0x38(%eax)
  dhcp->offered_bc_addr.addr = 0;
  8039f9:	c7 40 3c 00 00 00 00 	movl   $0x0,0x3c(%eax)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  803a00:	ba 33 00 00 00       	mov    $0x33,%edx
  803a05:	e8 d5 f1 ff ff       	call   802bdf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a0a:	85 c0                	test   %eax,%eax
  803a0c:	74 0e                	je     803a1c <dhcp_recv+0x1df>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  803a0e:	83 c0 02             	add    $0x2,%eax
  803a11:	e8 cb f2 ff ff       	call   802ce1 <dhcp_get_option_long>
  803a16:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a19:	89 41 4c             	mov    %eax,0x4c(%ecx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  803a1c:	ba 3a 00 00 00       	mov    $0x3a,%edx
  803a21:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a24:	e8 b6 f1 ff ff       	call   802bdf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a29:	85 c0                	test   %eax,%eax
  803a2b:	74 10                	je     803a3d <dhcp_recv+0x200>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  803a2d:	83 c0 02             	add    $0x2,%eax
  803a30:	e8 ac f2 ff ff       	call   802ce1 <dhcp_get_option_long>
  803a35:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a38:	89 41 50             	mov    %eax,0x50(%ecx)
  803a3b:	eb 0e                	jmp    803a4b <dhcp_recv+0x20e>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  803a3d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a40:	8b 41 4c             	mov    0x4c(%ecx),%eax
  803a43:	89 45 e0             	mov    %eax,-0x20(%ebp)
  803a46:	d1 e8                	shr    %eax
  803a48:	89 41 50             	mov    %eax,0x50(%ecx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  803a4b:	ba 3b 00 00 00       	mov    $0x3b,%edx
  803a50:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a53:	e8 87 f1 ff ff       	call   802bdf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803a58:	85 c0                	test   %eax,%eax
  803a5a:	74 10                	je     803a6c <dhcp_recv+0x22f>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  803a5c:	83 c0 02             	add    $0x2,%eax
  803a5f:	e8 7d f2 ff ff       	call   802ce1 <dhcp_get_option_long>
  803a64:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a67:	89 41 54             	mov    %eax,0x54(%ecx)
  803a6a:	eb 09                	jmp    803a75 <dhcp_recv+0x238>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  803a6c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a6f:	8b 41 4c             	mov    0x4c(%ecx),%eax
  803a72:	89 41 54             	mov    %eax,0x54(%ecx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803a75:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803a78:	8b 40 10             	mov    0x10(%eax),%eax
  803a7b:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803a7e:	74 05                	je     803a85 <dhcp_recv+0x248>
  803a80:	8b 40 10             	mov    0x10(%eax),%eax
  803a83:	eb 05                	jmp    803a8a <dhcp_recv+0x24d>
  803a85:	b8 00 00 00 00       	mov    $0x0,%eax
  803a8a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803a8d:	89 41 30             	mov    %eax,0x30(%ecx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  803a90:	ba 01 00 00 00       	mov    $0x1,%edx
  803a95:	89 c8                	mov    %ecx,%eax
  803a97:	e8 43 f1 ff ff       	call   802bdf <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  803a9c:	85 c0                	test   %eax,%eax
  803a9e:	74 16                	je     803ab6 <dhcp_recv+0x279>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803aa0:	83 c0 02             	add    $0x2,%eax
  803aa3:	e8 39 f2 ff ff       	call   802ce1 <dhcp_get_option_long>
  803aa8:	89 04 24             	mov    %eax,(%esp)
  803aab:	e8 10 43 00 00       	call   807dc0 <htonl>
  803ab0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803ab3:	89 41 34             	mov    %eax,0x34(%ecx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  803ab6:	ba 03 00 00 00       	mov    $0x3,%edx
  803abb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803abe:	e8 1c f1 ff ff       	call   802bdf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803ac3:	85 c0                	test   %eax,%eax
  803ac5:	74 16                	je     803add <dhcp_recv+0x2a0>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803ac7:	83 c0 02             	add    $0x2,%eax
  803aca:	e8 12 f2 ff ff       	call   802ce1 <dhcp_get_option_long>
  803acf:	89 04 24             	mov    %eax,(%esp)
  803ad2:	e8 e9 42 00 00       	call   807dc0 <htonl>
  803ad7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803ada:	89 41 38             	mov    %eax,0x38(%ecx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  803add:	ba 1c 00 00 00       	mov    $0x1c,%edx
  803ae2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803ae5:	e8 f5 f0 ff ff       	call   802bdf <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  803aea:	85 c0                	test   %eax,%eax
  803aec:	74 16                	je     803b04 <dhcp_recv+0x2c7>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803aee:	83 c0 02             	add    $0x2,%eax
  803af1:	e8 eb f1 ff ff       	call   802ce1 <dhcp_get_option_long>
  803af6:	89 04 24             	mov    %eax,(%esp)
  803af9:	e8 c2 42 00 00       	call   807dc0 <htonl>
  803afe:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b01:	89 41 3c             	mov    %eax,0x3c(%ecx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  803b04:	ba 06 00 00 00       	mov    $0x6,%edx
  803b09:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803b0c:	e8 ce f0 ff ff       	call   802bdf <dhcp_get_option_ptr>
  803b11:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (option_ptr != NULL) {
  803b14:	85 c0                	test   %eax,%eax
  803b16:	74 56                	je     803b6e <dhcp_recv+0x331>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  803b18:	0f b6 40 01          	movzbl 0x1(%eax),%eax
  803b1c:	c0 e8 02             	shr    $0x2,%al
  803b1f:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  803b22:	83 f8 03             	cmp    $0x3,%eax
  803b25:	ba 02 00 00 00       	mov    $0x2,%edx
  803b2a:	0f 43 c2             	cmovae %edx,%eax
  803b2d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b30:	89 41 40             	mov    %eax,0x40(%ecx)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  803b33:	c6 45 e0 00          	movb   $0x0,-0x20(%ebp)
  803b37:	89 5d 08             	mov    %ebx,0x8(%ebp)
  803b3a:	eb 23                	jmp    803b5f <dhcp_recv+0x322>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  803b3c:	0f b6 5d e0          	movzbl -0x20(%ebp),%ebx
  803b40:	8b 45 dc             	mov    -0x24(%ebp),%eax
  803b43:	8d 44 98 02          	lea    0x2(%eax,%ebx,4),%eax
  803b47:	e8 95 f1 ff ff       	call   802ce1 <dhcp_get_option_long>
  803b4c:	89 04 24             	mov    %eax,(%esp)
  803b4f:	e8 6c 42 00 00       	call   807dc0 <htonl>
  803b54:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b57:	89 44 99 44          	mov    %eax,0x44(%ecx,%ebx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  803b5b:	80 45 e0 01          	addb   $0x1,-0x20(%ebp)
  803b5f:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  803b63:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803b66:	3b 41 40             	cmp    0x40(%ecx),%eax
  803b69:	72 d1                	jb     803b3c <dhcp_recv+0x2ff>
  803b6b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  803b6e:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  803b74:	89 d8                	mov    %ebx,%eax
  803b76:	e8 b7 fa ff ff       	call   803632 <dhcp_check>
  803b7b:	e9 eb 00 00 00       	jmp    803c6b <dhcp_recv+0x42e>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  803b80:	83 e8 03             	sub    $0x3,%eax
  803b83:	3c 02                	cmp    $0x2,%al
  803b85:	0f 87 e0 00 00 00    	ja     803c6b <dhcp_recv+0x42e>
      dhcp->request_timeout = 0;
  803b8b:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
      dhcp_bind(netif);
  803b91:	89 d8                	mov    %ebx,%eax
  803b93:	e8 d7 fa ff ff       	call   80366f <dhcp_bind>
  803b98:	e9 ce 00 00 00       	jmp    803c6b <dhcp_recv+0x42e>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803b9d:	3c 06                	cmp    $0x6,%al
  803b9f:	75 6d                	jne    803c0e <dhcp_recv+0x3d1>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  803ba1:	0f b6 06             	movzbl (%esi),%eax
  803ba4:	8d 50 fd             	lea    -0x3(%eax),%edx
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  803ba7:	80 fa 02             	cmp    $0x2,%dl
  803baa:	76 08                	jbe    803bb4 <dhcp_recv+0x377>
  803bac:	3c 01                	cmp    $0x1,%al
  803bae:	0f 85 b7 00 00 00    	jne    803c6b <dhcp_recv+0x42e>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  803bb4:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803bba:	8b 43 20             	mov    0x20(%ebx),%eax
  803bbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  803bc0:	89 1c 24             	mov    %ebx,(%esp)
  803bc3:	e8 4e 11 00 00       	call   804d16 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  803bc8:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803bcf:	00 
  803bd0:	89 1c 24             	mov    %ebx,(%esp)
  803bd3:	e8 6f 0f 00 00       	call   804b47 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  803bd8:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803bdf:	00 
  803be0:	89 1c 24             	mov    %ebx,(%esp)
  803be3:	e8 b5 10 00 00       	call   804c9d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  803be8:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803bef:	00 
  803bf0:	89 1c 24             	mov    %ebx,(%esp)
  803bf3:	e8 c0 10 00 00       	call   804cb8 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803bf8:	ba 0c 00 00 00       	mov    $0xc,%edx
  803bfd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803c00:	e8 cb ef ff ff       	call   802bd0 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  803c05:	89 d8                	mov    %ebx,%eax
  803c07:	e8 37 f7 ff ff       	call   803343 <dhcp_discover>
  803c0c:	eb 5d                	jmp    803c6b <dhcp_recv+0x42e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  803c0e:	3c 02                	cmp    $0x2,%al
  803c10:	75 59                	jne    803c6b <dhcp_recv+0x42e>
  803c12:	80 3e 06             	cmpb   $0x6,(%esi)
  803c15:	75 54                	jne    803c6b <dhcp_recv+0x42e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  803c17:	66 c7 46 26 00 00    	movw   $0x0,0x26(%esi)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  803c1d:	8b 43 20             	mov    0x20(%ebx),%eax
  803c20:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  803c23:	ba 36 00 00 00       	mov    $0x36,%edx
  803c28:	e8 b2 ef ff ff       	call   802bdf <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  803c2d:	85 c0                	test   %eax,%eax
  803c2f:	74 3a                	je     803c6b <dhcp_recv+0x42e>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  803c31:	83 c0 02             	add    $0x2,%eax
  803c34:	e8 a8 f0 ff ff       	call   802ce1 <dhcp_get_option_long>
  803c39:	89 04 24             	mov    %eax,(%esp)
  803c3c:	e8 7f 41 00 00       	call   807dc0 <htonl>
  803c41:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803c44:	89 41 2c             	mov    %eax,0x2c(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  803c47:	8b 41 10             	mov    0x10(%ecx),%eax
  803c4a:	83 f8 f0             	cmp    $0xfffffff0,%eax
  803c4d:	74 05                	je     803c54 <dhcp_recv+0x417>
  803c4f:	8b 40 10             	mov    0x10(%eax),%eax
  803c52:	eb 05                	jmp    803c59 <dhcp_recv+0x41c>
  803c54:	b8 00 00 00 00       	mov    $0x0,%eax
  803c59:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  803c5c:	89 41 30             	mov    %eax,0x30(%ecx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  803c5f:	89 d8                	mov    %ebx,%eax
  803c61:	e8 36 f8 ff ff       	call   80349c <dhcp_select>
  803c66:	eb 03                	jmp    803c6b <dhcp_recv+0x42e>
  803c68:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  803c6b:	89 3c 24             	mov    %edi,(%esp)
  803c6e:	e8 b1 11 00 00       	call   804e24 <pbuf_free>
  dhcp->p = NULL;
  803c73:	c7 46 0c 00 00 00 00 	movl   $0x0,0xc(%esi)
  803c7a:	eb 16                	jmp    803c92 <dhcp_recv+0x455>
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  803c7c:	ba 35 00 00 00       	mov    $0x35,%edx
  803c81:	89 f0                	mov    %esi,%eax
  803c83:	e8 57 ef ff ff       	call   802bdf <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  803c88:	85 c0                	test   %eax,%eax
  803c8a:	0f 85 3e fd ff ff    	jne    8039ce <dhcp_recv+0x191>
  803c90:	eb d9                	jmp    803c6b <dhcp_recv+0x42e>
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  dhcp->p = NULL;
}
  803c92:	83 c4 2c             	add    $0x2c,%esp
  803c95:	5b                   	pop    %ebx
  803c96:	5e                   	pop    %esi
  803c97:	5f                   	pop    %edi
  803c98:	5d                   	pop    %ebp
  803c99:	c3                   	ret    

00803c9a <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  803c9a:	55                   	push   %ebp
  803c9b:	89 e5                	mov    %esp,%ebp
  803c9d:	57                   	push   %edi
  803c9e:	56                   	push   %esi
  803c9f:	53                   	push   %ebx
  803ca0:	83 ec 2c             	sub    $0x2c,%esp
  803ca3:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  803ca6:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  803ca9:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  803cb0:	e8 3a 0b 00 00       	call   8047ef <mem_malloc>
  803cb5:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  803cb7:	85 c0                	test   %eax,%eax
  803cb9:	0f 84 47 01 00 00    	je     803e06 <dhcp_inform+0x16c>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  803cbf:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  803cc2:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  803cc9:	00 
  803cca:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803cd1:	00 
  803cd2:	89 04 24             	mov    %eax,(%esp)
  803cd5:	e8 2d bc 00 00       	call   80f907 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  803cda:	e8 75 5b 00 00       	call   809854 <udp_new>
  803cdf:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  803ce2:	85 c0                	test   %eax,%eax
  803ce4:	75 0d                	jne    803cf3 <dhcp_inform+0x59>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  803ce6:	89 1c 24             	mov    %ebx,(%esp)
  803ce9:	e8 27 08 00 00       	call   804515 <mem_free>
    return;
  803cee:	e9 13 01 00 00       	jmp    803e06 <dhcp_inform+0x16c>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803cf3:	89 f0                	mov    %esi,%eax
  803cf5:	e8 9a f2 ff ff       	call   802f94 <dhcp_create_request>
  if (result == ERR_OK) {
  803cfa:	84 c0                	test   %al,%al
  803cfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803d00:	0f 85 f7 00 00 00    	jne    803dfd <dhcp_inform+0x163>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803d06:	b9 01 00 00 00       	mov    $0x1,%ecx
  803d0b:	ba 35 00 00 00       	mov    $0x35,%edx
  803d10:	89 d8                	mov    %ebx,%eax
  803d12:	e8 38 f0 ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  803d17:	ba 08 00 00 00       	mov    $0x8,%edx
  803d1c:	89 d8                	mov    %ebx,%eax
  803d1e:	e8 e3 ef ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803d23:	b9 02 00 00 00       	mov    $0x2,%ecx
  803d28:	ba 39 00 00 00       	mov    $0x39,%edx
  803d2d:	89 d8                	mov    %ebx,%eax
  803d2f:	e8 1b f0 ff ff       	call   802d4f <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  803d34:	ba 40 02 00 00       	mov    $0x240,%edx
  803d39:	89 d8                	mov    %ebx,%eax
  803d3b:	e8 7b f0 ff ff       	call   802dbb <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  803d40:	89 d8                	mov    %ebx,%eax
  803d42:	e8 e0 f0 ff ff       	call   802e27 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803d47:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803d4b:	66 05 f0 00          	add    $0xf0,%ax
  803d4f:	0f b7 c0             	movzwl %ax,%eax
  803d52:	89 44 24 04          	mov    %eax,0x4(%esp)
  803d56:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803d59:	89 04 24             	mov    %eax,(%esp)
  803d5c:	e8 35 14 00 00       	call   805196 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  803d61:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  803d68:	00 
  803d69:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803d70:	00 
  803d71:	8b 43 08             	mov    0x8(%ebx),%eax
  803d74:	89 04 24             	mov    %eax,(%esp)
  803d77:	e8 f5 56 00 00       	call   809471 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  803d7c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803d83:	00 
  803d84:	c7 44 24 04 fc 2e 81 	movl   $0x812efc,0x4(%esp)
  803d8b:	00 
  803d8c:	8b 43 08             	mov    0x8(%ebx),%eax
  803d8f:	89 04 24             	mov    %eax,(%esp)
  803d92:	e8 ce 59 00 00       	call   809765 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803d97:	89 74 24 10          	mov    %esi,0x10(%esp)
  803d9b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803da2:	00 
  803da3:	c7 44 24 08 fc 2e 81 	movl   $0x812efc,0x8(%esp)
  803daa:	00 
  803dab:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803dae:	89 44 24 04          	mov    %eax,0x4(%esp)
  803db2:	8b 43 08             	mov    0x8(%ebx),%eax
  803db5:	89 04 24             	mov    %eax,(%esp)
  803db8:	e8 86 57 00 00       	call   809543 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803dbd:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803dc4:	00 
  803dc5:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803dcc:	00 
  803dcd:	8b 43 08             	mov    0x8(%ebx),%eax
  803dd0:	89 04 24             	mov    %eax,(%esp)
  803dd3:	e8 8d 59 00 00       	call   809765 <udp_connect>
    dhcp_delete_request(netif);
  803dd8:	89 f0                	mov    %esi,%eax
  803dda:	e8 ac f3 ff ff       	call   80318b <dhcp_delete_request>
  803ddf:	eb 1c                	jmp    803dfd <dhcp_inform+0x163>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
      udp_remove(dhcp->pcb);
  803de1:	89 04 24             	mov    %eax,(%esp)
  803de4:	e8 25 5a 00 00       	call   80980e <udp_remove>
    }
    dhcp->pcb = NULL;
  803de9:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  803df0:	89 1c 24             	mov    %ebx,(%esp)
  803df3:	e8 1d 07 00 00       	call   804515 <mem_free>
    netif->dhcp = old_dhcp;
  803df8:	89 7e 20             	mov    %edi,0x20(%esi)
  803dfb:	eb 09                	jmp    803e06 <dhcp_inform+0x16c>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  803dfd:	8b 43 08             	mov    0x8(%ebx),%eax
  803e00:	85 c0                	test   %eax,%eax
  803e02:	75 dd                	jne    803de1 <dhcp_inform+0x147>
  803e04:	eb e3                	jmp    803de9 <dhcp_inform+0x14f>
    }
    dhcp->pcb = NULL;
    mem_free((void *)dhcp);
    netif->dhcp = old_dhcp;
  }
}
  803e06:	83 c4 2c             	add    $0x2c,%esp
  803e09:	5b                   	pop    %ebx
  803e0a:	5e                   	pop    %esi
  803e0b:	5f                   	pop    %edi
  803e0c:	5d                   	pop    %ebp
  803e0d:	c3                   	ret    

00803e0e <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  803e0e:	55                   	push   %ebp
  803e0f:	89 e5                	mov    %esp,%ebp
  803e11:	56                   	push   %esi
  803e12:	53                   	push   %ebx
  803e13:	83 ec 20             	sub    $0x20,%esp
  803e16:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  803e19:	85 f6                	test   %esi,%esi
  803e1b:	75 1c                	jne    803e39 <dhcp_arp_reply+0x2b>
  803e1d:	c7 44 24 08 62 26 81 	movl   $0x812662,0x8(%esp)
  803e24:	00 
  803e25:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  803e2c:	00 
  803e2d:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  803e34:	e8 61 b2 00 00       	call   80f09a <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  803e39:	8b 5e 20             	mov    0x20(%esi),%ebx
  803e3c:	85 db                	test   %ebx,%ebx
  803e3e:	0f 84 04 01 00 00    	je     803f48 <dhcp_arp_reply+0x13a>
  803e44:	80 3b 08             	cmpb   $0x8,(%ebx)
  803e47:	0f 85 fb 00 00 00    	jne    803f48 <dhcp_arp_reply+0x13a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  803e4d:	8b 45 0c             	mov    0xc(%ebp),%eax
  803e50:	8b 4b 30             	mov    0x30(%ebx),%ecx
  803e53:	39 08                	cmp    %ecx,(%eax)
  803e55:	0f 85 ed 00 00 00    	jne    803f48 <dhcp_arp_reply+0x13a>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  803e5b:	ba 0c 00 00 00       	mov    $0xc,%edx
  803e60:	89 d8                	mov    %ebx,%eax
  803e62:	e8 69 ed ff ff       	call   802bd0 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803e67:	89 f0                	mov    %esi,%eax
  803e69:	e8 26 f1 ff ff       	call   802f94 <dhcp_create_request>
  if (result == ERR_OK) {
  803e6e:	84 c0                	test   %al,%al
  803e70:	0f 85 c8 00 00 00    	jne    803f3e <dhcp_arp_reply+0x130>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803e76:	b9 01 00 00 00       	mov    $0x1,%ecx
  803e7b:	ba 35 00 00 00       	mov    $0x35,%edx
  803e80:	89 d8                	mov    %ebx,%eax
  803e82:	e8 c8 ee ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  803e87:	ba 04 00 00 00       	mov    $0x4,%edx
  803e8c:	89 d8                	mov    %ebx,%eax
  803e8e:	e8 73 ee ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803e93:	b9 02 00 00 00       	mov    $0x2,%ecx
  803e98:	ba 39 00 00 00       	mov    $0x39,%edx
  803e9d:	89 d8                	mov    %ebx,%eax
  803e9f:	e8 ab ee ff ff       	call   802d4f <dhcp_option>
    dhcp_option_short(dhcp, 576);
  803ea4:	ba 40 02 00 00       	mov    $0x240,%edx
  803ea9:	89 d8                	mov    %ebx,%eax
  803eab:	e8 0b ef ff ff       	call   802dbb <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  803eb0:	b9 04 00 00 00       	mov    $0x4,%ecx
  803eb5:	ba 32 00 00 00       	mov    $0x32,%edx
  803eba:	89 d8                	mov    %ebx,%eax
  803ebc:	e8 8e ee ff ff       	call   802d4f <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  803ec1:	8b 43 30             	mov    0x30(%ebx),%eax
  803ec4:	89 04 24             	mov    %eax,(%esp)
  803ec7:	e8 2e 41 00 00       	call   807ffa <ntohl>
  803ecc:	89 c2                	mov    %eax,%edx
  803ece:	89 d8                	mov    %ebx,%eax
  803ed0:	e8 1c f0 ff ff       	call   802ef1 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  803ed5:	89 d8                	mov    %ebx,%eax
  803ed7:	e8 4b ef ff ff       	call   802e27 <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803edc:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803ee0:	66 05 f0 00          	add    $0xf0,%ax
  803ee4:	0f b7 c0             	movzwl %ax,%eax
  803ee7:	89 44 24 04          	mov    %eax,0x4(%esp)
  803eeb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803eee:	89 04 24             	mov    %eax,(%esp)
  803ef1:	e8 a0 12 00 00       	call   805196 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  803ef6:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803efd:	00 
  803efe:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  803f05:	00 
  803f06:	8b 43 08             	mov    0x8(%ebx),%eax
  803f09:	89 04 24             	mov    %eax,(%esp)
  803f0c:	e8 54 58 00 00       	call   809765 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  803f11:	89 74 24 10          	mov    %esi,0x10(%esp)
  803f15:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803f1c:	00 
  803f1d:	c7 44 24 08 fc 2e 81 	movl   $0x812efc,0x8(%esp)
  803f24:	00 
  803f25:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803f28:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f2c:	8b 43 08             	mov    0x8(%ebx),%eax
  803f2f:	89 04 24             	mov    %eax,(%esp)
  803f32:	e8 0c 56 00 00       	call   809543 <udp_sendto_if>
    dhcp_delete_request(netif);
  803f37:	89 f0                	mov    %esi,%eax
  803f39:	e8 4d f2 ff ff       	call   80318b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  803f3e:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  803f42:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  803f48:	83 c4 20             	add    $0x20,%esp
  803f4b:	5b                   	pop    %ebx
  803f4c:	5e                   	pop    %esi
  803f4d:	5d                   	pop    %ebp
  803f4e:	c3                   	ret    

00803f4f <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  803f4f:	55                   	push   %ebp
  803f50:	89 e5                	mov    %esp,%ebp
  803f52:	57                   	push   %edi
  803f53:	56                   	push   %esi
  803f54:	53                   	push   %ebx
  803f55:	83 ec 2c             	sub    $0x2c,%esp
  803f58:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  803f5b:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  803f5e:	ba 05 00 00 00       	mov    $0x5,%edx
  803f63:	89 d8                	mov    %ebx,%eax
  803f65:	e8 66 ec ff ff       	call   802bd0 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  803f6a:	89 f0                	mov    %esi,%eax
  803f6c:	e8 23 f0 ff ff       	call   802f94 <dhcp_create_request>
  803f71:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  803f73:	84 c0                	test   %al,%al
  803f75:	0f 85 a4 00 00 00    	jne    80401f <dhcp_renew+0xd0>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  803f7b:	b9 01 00 00 00       	mov    $0x1,%ecx
  803f80:	ba 35 00 00 00       	mov    $0x35,%edx
  803f85:	89 d8                	mov    %ebx,%eax
  803f87:	e8 c3 ed ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  803f8c:	ba 03 00 00 00       	mov    $0x3,%edx
  803f91:	89 d8                	mov    %ebx,%eax
  803f93:	e8 6e ed ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  803f98:	b9 02 00 00 00       	mov    $0x2,%ecx
  803f9d:	ba 39 00 00 00       	mov    $0x39,%edx
  803fa2:	89 d8                	mov    %ebx,%eax
  803fa4:	e8 a6 ed ff ff       	call   802d4f <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  803fa9:	ba 40 02 00 00       	mov    $0x240,%edx
  803fae:	89 d8                	mov    %ebx,%eax
  803fb0:	e8 06 ee ff ff       	call   802dbb <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  803fb5:	89 d8                	mov    %ebx,%eax
  803fb7:	e8 6b ee ff ff       	call   802e27 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  803fbc:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  803fc0:	66 05 f0 00          	add    $0xf0,%ax
  803fc4:	0f b7 c0             	movzwl %ax,%eax
  803fc7:	89 44 24 04          	mov    %eax,0x4(%esp)
  803fcb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  803fce:	89 04 24             	mov    %eax,(%esp)
  803fd1:	e8 c0 11 00 00       	call   805196 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  803fd6:	8d 43 2c             	lea    0x2c(%ebx),%eax
  803fd9:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  803fe0:	00 
  803fe1:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  803fe4:	89 44 24 04          	mov    %eax,0x4(%esp)
  803fe8:	8b 43 08             	mov    0x8(%ebx),%eax
  803feb:	89 04 24             	mov    %eax,(%esp)
  803fee:	e8 72 57 00 00       	call   809765 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  803ff3:	89 74 24 10          	mov    %esi,0x10(%esp)
  803ff7:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  803ffe:	00 
  803fff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804002:	89 44 24 08          	mov    %eax,0x8(%esp)
  804006:	8b 43 1c             	mov    0x1c(%ebx),%eax
  804009:	89 44 24 04          	mov    %eax,0x4(%esp)
  80400d:	8b 43 08             	mov    0x8(%ebx),%eax
  804010:	89 04 24             	mov    %eax,(%esp)
  804013:	e8 2b 55 00 00       	call   809543 <udp_sendto_if>
    dhcp_delete_request(netif);
  804018:	89 f0                	mov    %esi,%eax
  80401a:	e8 6c f1 ff ff       	call   80318b <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80401f:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  804023:	8d 48 01             	lea    0x1(%eax),%ecx
  804026:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  804029:	b8 20 4e 00 00       	mov    $0x4e20,%eax
  80402e:	80 f9 09             	cmp    $0x9,%cl
  804031:	77 08                	ja     80403b <dhcp_renew+0xec>
  804033:	0f b6 c9             	movzbl %cl,%ecx
  804036:	66 69 c1 d0 07       	imul   $0x7d0,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80403b:	0f b7 d0             	movzwl %ax,%edx
  80403e:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  804044:	be d3 4d 62 10       	mov    $0x10624dd3,%esi
  804049:	89 d0                	mov    %edx,%eax
  80404b:	f7 ee                	imul   %esi
  80404d:	c1 fa 05             	sar    $0x5,%edx
  804050:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  804054:	89 f8                	mov    %edi,%eax
  804056:	83 c4 2c             	add    $0x2c,%esp
  804059:	5b                   	pop    %ebx
  80405a:	5e                   	pop    %esi
  80405b:	5f                   	pop    %edi
  80405c:	5d                   	pop    %ebp
  80405d:	c3                   	ret    

0080405e <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  80405e:	55                   	push   %ebp
  80405f:	89 e5                	mov    %esp,%ebp
  804061:	53                   	push   %ebx
  804062:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  804065:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80406b:	eb 67                	jmp    8040d4 <dhcp_coarse_tmr+0x76>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80406d:	8b 43 20             	mov    0x20(%ebx),%eax
  804070:	85 c0                	test   %eax,%eax
  804072:	74 5e                	je     8040d2 <dhcp_coarse_tmr+0x74>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  804074:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  804078:	8d 4a ff             	lea    -0x1(%edx),%ecx
  80407b:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  80407f:	66 83 fa 01          	cmp    $0x1,%dx
  804083:	75 1d                	jne    8040a2 <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  804085:	8b 43 20             	mov    0x20(%ebx),%eax
  804088:	0f b6 00             	movzbl (%eax),%eax
  80408b:	89 c2                	mov    %eax,%edx
  80408d:	83 e2 fb             	and    $0xfffffffb,%edx
  804090:	80 fa 01             	cmp    $0x1,%dl
  804093:	74 04                	je     804099 <dhcp_coarse_tmr+0x3b>
  804095:	3c 0a                	cmp    $0xa,%al
  804097:	75 39                	jne    8040d2 <dhcp_coarse_tmr+0x74>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  804099:	89 d8                	mov    %ebx,%eax
  80409b:	e8 96 f1 ff ff       	call   803236 <dhcp_rebind>
  8040a0:	eb 30                	jmp    8040d2 <dhcp_coarse_tmr+0x74>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  8040a2:	8b 53 20             	mov    0x20(%ebx),%edx
  8040a5:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  8040a9:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8040ac:	66 89 4a 28          	mov    %cx,0x28(%edx)
  8040b0:	66 83 f8 01          	cmp    $0x1,%ax
  8040b4:	75 1c                	jne    8040d2 <dhcp_coarse_tmr+0x74>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8040b6:	8b 43 20             	mov    0x20(%ebx),%eax
  8040b9:	0f b6 00             	movzbl (%eax),%eax
  8040bc:	89 c2                	mov    %eax,%edx
  8040be:	83 e2 fb             	and    $0xfffffffb,%edx
  8040c1:	80 fa 01             	cmp    $0x1,%dl
  8040c4:	74 04                	je     8040ca <dhcp_coarse_tmr+0x6c>
  8040c6:	3c 0a                	cmp    $0xa,%al
  8040c8:	75 08                	jne    8040d2 <dhcp_coarse_tmr+0x74>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  8040ca:	89 1c 24             	mov    %ebx,(%esp)
  8040cd:	e8 7d fe ff ff       	call   803f4f <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  8040d2:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8040d4:	85 db                	test   %ebx,%ebx
  8040d6:	75 95                	jne    80406d <dhcp_coarse_tmr+0xf>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  8040d8:	83 c4 14             	add    $0x14,%esp
  8040db:	5b                   	pop    %ebx
  8040dc:	5d                   	pop    %ebp
  8040dd:	c3                   	ret    

008040de <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  8040de:	55                   	push   %ebp
  8040df:	89 e5                	mov    %esp,%ebp
  8040e1:	57                   	push   %edi
  8040e2:	56                   	push   %esi
  8040e3:	53                   	push   %ebx
  8040e4:	83 ec 2c             	sub    $0x2c,%esp
  8040e7:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  8040ea:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  8040ed:	ba 0d 00 00 00       	mov    $0xd,%edx
  8040f2:	89 d8                	mov    %ebx,%eax
  8040f4:	e8 d7 ea ff ff       	call   802bd0 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  8040f9:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  804100:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  804107:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  80410e:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  804115:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80411c:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  804123:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  80412a:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  804131:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  804138:	89 f0                	mov    %esi,%eax
  80413a:	e8 55 ee ff ff       	call   802f94 <dhcp_create_request>
  80413f:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  804141:	84 c0                	test   %al,%al
  804143:	0f 85 87 00 00 00    	jne    8041d0 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  804149:	b9 01 00 00 00       	mov    $0x1,%ecx
  80414e:	ba 35 00 00 00       	mov    $0x35,%edx
  804153:	89 d8                	mov    %ebx,%eax
  804155:	e8 f5 eb ff ff       	call   802d4f <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80415a:	ba 07 00 00 00       	mov    $0x7,%edx
  80415f:	89 d8                	mov    %ebx,%eax
  804161:	e8 a0 eb ff ff       	call   802d06 <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  804166:	89 d8                	mov    %ebx,%eax
  804168:	e8 ba ec ff ff       	call   802e27 <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80416d:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  804171:	66 05 f0 00          	add    $0xf0,%ax
  804175:	0f b7 c0             	movzwl %ax,%eax
  804178:	89 44 24 04          	mov    %eax,0x4(%esp)
  80417c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80417f:	89 04 24             	mov    %eax,(%esp)
  804182:	e8 0f 10 00 00       	call   805196 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  804187:	8d 43 2c             	lea    0x2c(%ebx),%eax
  80418a:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  804191:	00 
  804192:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804195:	89 44 24 04          	mov    %eax,0x4(%esp)
  804199:	8b 43 08             	mov    0x8(%ebx),%eax
  80419c:	89 04 24             	mov    %eax,(%esp)
  80419f:	e8 c1 55 00 00       	call   809765 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8041a4:	89 74 24 10          	mov    %esi,0x10(%esp)
  8041a8:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8041af:	00 
  8041b0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8041b3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8041b7:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8041ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  8041be:	8b 43 08             	mov    0x8(%ebx),%eax
  8041c1:	89 04 24             	mov    %eax,(%esp)
  8041c4:	e8 7a 53 00 00       	call   809543 <udp_sendto_if>
    dhcp_delete_request(netif);
  8041c9:	89 f0                	mov    %esi,%eax
  8041cb:	e8 bb ef ff ff       	call   80318b <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8041d0:	0f b6 43 01          	movzbl 0x1(%ebx),%eax
  8041d4:	8d 48 01             	lea    0x1(%eax),%ecx
  8041d7:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  8041da:	b8 10 27 00 00       	mov    $0x2710,%eax
  8041df:	80 f9 09             	cmp    $0x9,%cl
  8041e2:	77 08                	ja     8041ec <dhcp_release+0x10e>
  8041e4:	0f b6 c9             	movzbl %cl,%ecx
  8041e7:	66 69 c1 e8 03       	imul   $0x3e8,%cx,%ax
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8041ec:	0f b7 d0             	movzwl %ax,%edx
  8041ef:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8041f5:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8041fa:	89 d0                	mov    %edx,%eax
  8041fc:	f7 e9                	imul   %ecx
  8041fe:	c1 fa 05             	sar    $0x5,%edx
  804201:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  804205:	89 34 24             	mov    %esi,(%esp)
  804208:	e8 09 0b 00 00       	call   804d16 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  80420d:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  804214:	00 
  804215:	89 34 24             	mov    %esi,(%esp)
  804218:	e8 2a 09 00 00       	call   804b47 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  80421d:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  804224:	00 
  804225:	89 34 24             	mov    %esi,(%esp)
  804228:	e8 70 0a 00 00       	call   804c9d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  80422d:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  804234:	00 
  804235:	89 34 24             	mov    %esi,(%esp)
  804238:	e8 7b 0a 00 00       	call   804cb8 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  80423d:	89 f8                	mov    %edi,%eax
  80423f:	83 c4 2c             	add    $0x2c,%esp
  804242:	5b                   	pop    %ebx
  804243:	5e                   	pop    %esi
  804244:	5f                   	pop    %edi
  804245:	5d                   	pop    %ebp
  804246:	c3                   	ret    

00804247 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  804247:	55                   	push   %ebp
  804248:	89 e5                	mov    %esp,%ebp
  80424a:	53                   	push   %ebx
  80424b:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  80424e:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  804254:	e9 c3 00 00 00       	jmp    80431c <dhcp_fine_tmr+0xd5>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  804259:	8b 43 20             	mov    0x20(%ebx),%eax
  80425c:	85 c0                	test   %eax,%eax
  80425e:	0f 84 b6 00 00 00    	je     80431a <dhcp_fine_tmr+0xd3>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  804264:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  804268:	66 83 fa 01          	cmp    $0x1,%dx
  80426c:	76 0c                	jbe    80427a <dhcp_fine_tmr+0x33>
        netif->dhcp->request_timeout--;
  80426e:	83 ea 01             	sub    $0x1,%edx
  804271:	66 89 50 26          	mov    %dx,0x26(%eax)
  804275:	e9 a0 00 00 00       	jmp    80431a <dhcp_fine_tmr+0xd3>
      }
      else if (netif->dhcp->request_timeout == 1) {
  80427a:	66 83 fa 01          	cmp    $0x1,%dx
  80427e:	0f 85 96 00 00 00    	jne    80431a <dhcp_fine_tmr+0xd3>
        netif->dhcp->request_timeout--;
  804284:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  80428a:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80428d:	0f b6 02             	movzbl (%edx),%eax
  804290:	3c 06                	cmp    $0x6,%al
  804292:	74 04                	je     804298 <dhcp_fine_tmr+0x51>
  804294:	3c 0c                	cmp    $0xc,%al
  804296:	75 0a                	jne    8042a2 <dhcp_fine_tmr+0x5b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  804298:	89 d8                	mov    %ebx,%eax
  80429a:	e8 a4 f0 ff ff       	call   803343 <dhcp_discover>
  80429f:	90                   	nop
  8042a0:	eb 78                	jmp    80431a <dhcp_fine_tmr+0xd3>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  8042a2:	3c 01                	cmp    $0x1,%al
  8042a4:	75 20                	jne    8042c6 <dhcp_fine_tmr+0x7f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  8042a6:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  8042aa:	77 09                	ja     8042b5 <dhcp_fine_tmr+0x6e>
      dhcp_select(netif);
  8042ac:	89 d8                	mov    %ebx,%eax
  8042ae:	e8 e9 f1 ff ff       	call   80349c <dhcp_select>
  8042b3:	eb 65                	jmp    80431a <dhcp_fine_tmr+0xd3>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  8042b5:	89 1c 24             	mov    %ebx,(%esp)
  8042b8:	e8 21 fe ff ff       	call   8040de <dhcp_release>
      dhcp_discover(netif);
  8042bd:	89 d8                	mov    %ebx,%eax
  8042bf:	e8 7f f0 ff ff       	call   803343 <dhcp_discover>
  8042c4:	eb 54                	jmp    80431a <dhcp_fine_tmr+0xd3>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8042c6:	3c 08                	cmp    $0x8,%al
  8042c8:	75 1a                	jne    8042e4 <dhcp_fine_tmr+0x9d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  8042ca:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  8042ce:	66 90                	xchg   %ax,%ax
  8042d0:	77 09                	ja     8042db <dhcp_fine_tmr+0x94>
      dhcp_check(netif);
  8042d2:	89 d8                	mov    %ebx,%eax
  8042d4:	e8 59 f3 ff ff       	call   803632 <dhcp_check>
  8042d9:	eb 3f                	jmp    80431a <dhcp_fine_tmr+0xd3>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  8042db:	89 d8                	mov    %ebx,%eax
  8042dd:	e8 8d f3 ff ff       	call   80366f <dhcp_bind>
  8042e2:	eb 36                	jmp    80431a <dhcp_fine_tmr+0xd3>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  8042e4:	3c 05                	cmp    $0x5,%al
  8042e6:	75 0f                	jne    8042f7 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  8042e8:	89 1c 24             	mov    %ebx,(%esp)
  8042eb:	90                   	nop
  8042ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8042f0:	e8 5a fc ff ff       	call   803f4f <dhcp_renew>
  8042f5:	eb 23                	jmp    80431a <dhcp_fine_tmr+0xd3>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  8042f7:	3c 04                	cmp    $0x4,%al
  8042f9:	75 1f                	jne    80431a <dhcp_fine_tmr+0xd3>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  8042fb:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  8042ff:	90                   	nop
  804300:	77 09                	ja     80430b <dhcp_fine_tmr+0xc4>
      dhcp_rebind(netif);
  804302:	89 d8                	mov    %ebx,%eax
  804304:	e8 2d ef ff ff       	call   803236 <dhcp_rebind>
  804309:	eb 0f                	jmp    80431a <dhcp_fine_tmr+0xd3>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  80430b:	89 1c 24             	mov    %ebx,(%esp)
  80430e:	e8 cb fd ff ff       	call   8040de <dhcp_release>
      dhcp_discover(netif);
  804313:	89 d8                	mov    %ebx,%eax
  804315:	e8 29 f0 ff ff       	call   803343 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  80431a:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  80431c:	85 db                	test   %ebx,%ebx
  80431e:	0f 85 35 ff ff ff    	jne    804259 <dhcp_fine_tmr+0x12>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  804324:	83 c4 14             	add    $0x14,%esp
  804327:	5b                   	pop    %ebx
  804328:	5d                   	pop    %ebp
  804329:	c3                   	ret    

0080432a <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  80432a:	55                   	push   %ebp
  80432b:	89 e5                	mov    %esp,%ebp
  80432d:	56                   	push   %esi
  80432e:	53                   	push   %ebx
  80432f:	83 ec 10             	sub    $0x10,%esp
  804332:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  804335:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  804338:	85 f6                	test   %esi,%esi
  80433a:	75 1c                	jne    804358 <dhcp_stop+0x2e>
  80433c:	c7 44 24 08 b4 26 81 	movl   $0x8126b4,0x8(%esp)
  804343:	00 
  804344:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  80434b:	00 
  80434c:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  804353:	e8 42 ad 00 00       	call   80f09a <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  804358:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  80435c:	85 db                	test   %ebx,%ebx
  80435e:	74 42                	je     8043a2 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  804360:	8b 43 08             	mov    0x8(%ebx),%eax
  804363:	85 c0                	test   %eax,%eax
  804365:	74 0f                	je     804376 <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  804367:	89 04 24             	mov    %eax,(%esp)
  80436a:	e8 9f 54 00 00       	call   80980e <udp_remove>
      dhcp->pcb = NULL;
  80436f:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  804376:	8b 43 0c             	mov    0xc(%ebx),%eax
  804379:	85 c0                	test   %eax,%eax
  80437b:	74 0f                	je     80438c <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  80437d:	89 04 24             	mov    %eax,(%esp)
  804380:	e8 9f 0a 00 00       	call   804e24 <pbuf_free>
      dhcp->p = NULL;
  804385:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  80438c:	89 d8                	mov    %ebx,%eax
  80438e:	e8 69 f4 ff ff       	call   8037fc <dhcp_free_reply>
    mem_free((void *)dhcp);
  804393:	89 1c 24             	mov    %ebx,(%esp)
  804396:	e8 7a 01 00 00       	call   804515 <mem_free>
    netif->dhcp = NULL;
  80439b:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8043a2:	83 c4 10             	add    $0x10,%esp
  8043a5:	5b                   	pop    %ebx
  8043a6:	5e                   	pop    %esi
  8043a7:	5d                   	pop    %ebp
  8043a8:	c3                   	ret    

008043a9 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  8043a9:	55                   	push   %ebp
  8043aa:	89 e5                	mov    %esp,%ebp
  8043ac:	56                   	push   %esi
  8043ad:	53                   	push   %ebx
  8043ae:	83 ec 10             	sub    $0x10,%esp
  8043b1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  8043b4:	85 db                	test   %ebx,%ebx
  8043b6:	75 1c                	jne    8043d4 <dhcp_start+0x2b>
  8043b8:	c7 44 24 08 62 26 81 	movl   $0x812662,0x8(%esp)
  8043bf:	00 
  8043c0:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8043c7:	00 
  8043c8:	c7 04 24 42 26 81 00 	movl   $0x812642,(%esp)
  8043cf:	e8 c6 ac 00 00       	call   80f09a <_panic>
  dhcp = netif->dhcp;
  8043d4:	8b 73 20             	mov    0x20(%ebx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  8043d7:	80 63 2e f7          	andb   $0xf7,0x2e(%ebx)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  8043db:	85 f6                	test   %esi,%esi
  8043dd:	75 19                	jne    8043f8 <dhcp_start+0x4f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  8043df:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  8043e6:	e8 04 04 00 00       	call   8047ef <mem_malloc>
  8043eb:	89 c6                	mov    %eax,%esi
    if (dhcp == NULL) {
  8043ed:	85 c0                	test   %eax,%eax
  8043ef:	0f 84 ac 00 00 00    	je     8044a1 <dhcp_start+0xf8>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8043f5:	89 43 20             	mov    %eax,0x20(%ebx)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8043f8:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8043ff:	00 
  804400:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804407:	00 
  804408:	89 34 24             	mov    %esi,(%esp)
  80440b:	e8 f7 b4 00 00       	call   80f907 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  804410:	e8 3f 54 00 00       	call   809854 <udp_new>
  804415:	89 46 08             	mov    %eax,0x8(%esi)
  if (dhcp->pcb == NULL) {
  804418:	85 c0                	test   %eax,%eax
  80441a:	75 16                	jne    804432 <dhcp_start+0x89>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  80441c:	89 34 24             	mov    %esi,(%esp)
  80441f:	e8 f1 00 00 00       	call   804515 <mem_free>
    netif->dhcp = dhcp = NULL;
  804424:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
    return ERR_MEM;
  80442b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804430:	eb 74                	jmp    8044a6 <dhcp_start+0xfd>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  804432:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  804439:	00 
  80443a:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  804441:	00 
  804442:	89 04 24             	mov    %eax,(%esp)
  804445:	e8 27 50 00 00       	call   809471 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80444a:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  804451:	00 
  804452:	c7 44 24 04 00 2f 81 	movl   $0x812f00,0x4(%esp)
  804459:	00 
  80445a:	8b 46 08             	mov    0x8(%esi),%eax
  80445d:	89 04 24             	mov    %eax,(%esp)
  804460:	e8 00 53 00 00       	call   809765 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  804465:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  804469:	c7 44 24 04 3d 38 80 	movl   $0x80383d,0x4(%esp)
  804470:	00 
  804471:	8b 46 08             	mov    0x8(%esi),%eax
  804474:	89 04 24             	mov    %eax,(%esp)
  804477:	e8 7e 53 00 00       	call   8097fa <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  80447c:	89 d8                	mov    %ebx,%eax
  80447e:	e8 c0 ee ff ff       	call   803343 <dhcp_discover>
  if (result != ERR_OK) {
  804483:	84 c0                	test   %al,%al
  804485:	74 0f                	je     804496 <dhcp_start+0xed>
    /* free resources allocated above */
    dhcp_stop(netif);
  804487:	89 1c 24             	mov    %ebx,(%esp)
  80448a:	e8 9b fe ff ff       	call   80432a <dhcp_stop>
    return ERR_MEM;
  80448f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804494:	eb 10                	jmp    8044a6 <dhcp_start+0xfd>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  804496:	80 4b 2e 08          	orb    $0x8,0x2e(%ebx)
  return result;
  80449a:	b8 00 00 00 00       	mov    $0x0,%eax
  80449f:	eb 05                	jmp    8044a6 <dhcp_start+0xfd>
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  8044a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  return result;
}
  8044a6:	83 c4 10             	add    $0x10,%esp
  8044a9:	5b                   	pop    %ebx
  8044aa:	5e                   	pop    %esi
  8044ab:	5d                   	pop    %ebp
  8044ac:	c3                   	ret    

008044ad <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  8044ad:	55                   	push   %ebp
  8044ae:	89 e5                	mov    %esp,%ebp
  8044b0:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  8044b3:	b8 43 63 81 00       	mov    $0x816343,%eax
  8044b8:	83 e0 fc             	and    $0xfffffffc,%eax
  8044bb:	a3 2c 63 81 00       	mov    %eax,0x81632c
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  8044c0:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  8044c6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  8044cd:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  8044d1:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  8044d7:	89 15 28 63 81 00    	mov    %edx,0x816328
  ram_end->used = 1;
  8044dd:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  8044e4:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  8044eb:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  8044ee:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  8044f5:	00 22 00 

  mem_sem = sys_sem_new(1);
  8044f8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8044ff:	e8 4a 61 00 00       	call   80a64e <sys_sem_new>
  804504:	a3 20 63 81 00       	mov    %eax,0x816320

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  804509:	a1 2c 63 81 00       	mov    0x81632c,%eax
  80450e:	a3 24 63 81 00       	mov    %eax,0x816324

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  804513:	c9                   	leave  
  804514:	c3                   	ret    

00804515 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  804515:	55                   	push   %ebp
  804516:	89 e5                	mov    %esp,%ebp
  804518:	56                   	push   %esi
  804519:	53                   	push   %ebx
  80451a:	83 ec 10             	sub    $0x10,%esp
  80451d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  804520:	85 db                	test   %ebx,%ebx
  804522:	0f 84 6f 01 00 00    	je     804697 <mem_free+0x182>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  804528:	f6 c3 03             	test   $0x3,%bl
  80452b:	74 1c                	je     804549 <mem_free+0x34>
  80452d:	c7 44 24 08 d0 26 81 	movl   $0x8126d0,0x8(%esp)
  804534:	00 
  804535:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80453c:	00 
  80453d:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804544:	e8 51 ab 00 00       	call   80f09a <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  804549:	3b 1d 2c 63 81 00    	cmp    0x81632c,%ebx
  80454f:	72 08                	jb     804559 <mem_free+0x44>
  804551:	3b 1d 28 63 81 00    	cmp    0x816328,%ebx
  804557:	72 1c                	jb     804575 <mem_free+0x60>
  804559:	c7 44 24 08 db 27 81 	movl   $0x8127db,0x8(%esp)
  804560:	00 
  804561:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  804568:	00 
  804569:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804570:	e8 25 ab 00 00       	call   80f09a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804575:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80457c:	00 
  80457d:	a1 20 63 81 00       	mov    0x816320,%eax
  804582:	89 04 24             	mov    %eax,(%esp)
  804585:	e8 1b 64 00 00       	call   80a9a5 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  80458a:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  80458d:	80 7b fc 00          	cmpb   $0x0,-0x4(%ebx)
  804591:	75 1c                	jne    8045af <mem_free+0x9a>
  804593:	c7 44 24 08 f2 27 81 	movl   $0x8127f2,0x8(%esp)
  80459a:	00 
  80459b:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8045a2:	00 
  8045a3:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  8045aa:	e8 eb aa 00 00       	call   80f09a <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  8045af:	c6 43 fc 00          	movb   $0x0,-0x4(%ebx)

  if (mem < lfree) {
  8045b3:	3b 05 24 63 81 00    	cmp    0x816324,%eax
  8045b9:	73 05                	jae    8045c0 <mem_free+0xab>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  8045bb:	a3 24 63 81 00       	mov    %eax,0x816324
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  8045c0:	8b 15 2c 63 81 00    	mov    0x81632c,%edx
  8045c6:	39 d0                	cmp    %edx,%eax
  8045c8:	73 1c                	jae    8045e6 <mem_free+0xd1>
  8045ca:	c7 44 24 08 06 28 81 	movl   $0x812806,0x8(%esp)
  8045d1:	00 
  8045d2:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  8045d9:	00 
  8045da:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  8045e1:	e8 b4 aa 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  8045e6:	8b 35 28 63 81 00    	mov    0x816328,%esi
  8045ec:	39 f0                	cmp    %esi,%eax
  8045ee:	72 1c                	jb     80460c <mem_free+0xf7>
  8045f0:	c7 44 24 08 1d 28 81 	movl   $0x81281d,0x8(%esp)
  8045f7:	00 
  8045f8:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  8045ff:	00 
  804600:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804607:	e8 8e aa 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  80460c:	8b 4b f4             	mov    -0xc(%ebx),%ecx
  80460f:	81 f9 00 00 22 00    	cmp    $0x220000,%ecx
  804615:	76 1c                	jbe    804633 <mem_free+0x11e>
  804617:	c7 44 24 08 f4 26 81 	movl   $0x8126f4,0x8(%esp)
  80461e:	00 
  80461f:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  804626:	00 
  804627:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  80462e:	e8 67 aa 00 00       	call   80f09a <_panic>

  nmem = (struct mem *)&ram[mem->next];
  804633:	01 d1                	add    %edx,%ecx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  804635:	39 c8                	cmp    %ecx,%eax
  804637:	74 26                	je     80465f <mem_free+0x14a>
  804639:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  80463d:	75 20                	jne    80465f <mem_free+0x14a>
  80463f:	39 ce                	cmp    %ecx,%esi
  804641:	74 1c                	je     80465f <mem_free+0x14a>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  804643:	3b 0d 24 63 81 00    	cmp    0x816324,%ecx
  804649:	75 05                	jne    804650 <mem_free+0x13b>
      lfree = mem;
  80464b:	a3 24 63 81 00       	mov    %eax,0x816324
    }
    mem->next = nmem->next;
  804650:	8b 31                	mov    (%ecx),%esi
  804652:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  804655:	8b 09                	mov    (%ecx),%ecx
  804657:	89 c6                	mov    %eax,%esi
  804659:	29 d6                	sub    %edx,%esi
  80465b:	89 74 0a 04          	mov    %esi,0x4(%edx,%ecx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80465f:	89 d1                	mov    %edx,%ecx
  804661:	03 4b f8             	add    -0x8(%ebx),%ecx
  if (pmem != mem && pmem->used == 0) {
  804664:	39 c8                	cmp    %ecx,%eax
  804666:	74 22                	je     80468a <mem_free+0x175>
  804668:	80 79 08 00          	cmpb   $0x0,0x8(%ecx)
  80466c:	75 1c                	jne    80468a <mem_free+0x175>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  80466e:	3b 05 24 63 81 00    	cmp    0x816324,%eax
  804674:	75 06                	jne    80467c <mem_free+0x167>
      lfree = pmem;
  804676:	89 0d 24 63 81 00    	mov    %ecx,0x816324
    }
    pmem->next = mem->next;
  80467c:	8b 43 f4             	mov    -0xc(%ebx),%eax
  80467f:	89 01                	mov    %eax,(%ecx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  804681:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804684:	29 d1                	sub    %edx,%ecx
  804686:	89 4c 02 04          	mov    %ecx,0x4(%edx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  80468a:	a1 20 63 81 00       	mov    0x816320,%eax
  80468f:	89 04 24             	mov    %eax,(%esp)
  804692:	e8 99 62 00 00       	call   80a930 <sys_sem_signal>
}
  804697:	83 c4 10             	add    $0x10,%esp
  80469a:	5b                   	pop    %ebx
  80469b:	5e                   	pop    %esi
  80469c:	5d                   	pop    %ebp
  80469d:	c3                   	ret    

0080469e <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  80469e:	55                   	push   %ebp
  80469f:	89 e5                	mov    %esp,%ebp
  8046a1:	57                   	push   %edi
  8046a2:	56                   	push   %esi
  8046a3:	53                   	push   %ebx
  8046a4:	83 ec 1c             	sub    $0x1c,%esp
  8046a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8046aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8046ad:	8d 70 03             	lea    0x3(%eax),%esi
  8046b0:	83 e6 fc             	and    $0xfffffffc,%esi

  if(newsize < MIN_SIZE_ALIGNED) {
  8046b3:	83 fe 0b             	cmp    $0xb,%esi
  8046b6:	76 0d                	jbe    8046c5 <mem_realloc+0x27>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8046b8:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  8046be:	76 0a                	jbe    8046ca <mem_realloc+0x2c>
  8046c0:	e9 1d 01 00 00       	jmp    8047e2 <mem_realloc+0x144>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  8046c5:	be 0c 00 00 00       	mov    $0xc,%esi

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  8046ca:	a1 2c 63 81 00       	mov    0x81632c,%eax
  8046cf:	39 d8                	cmp    %ebx,%eax
  8046d1:	77 08                	ja     8046db <mem_realloc+0x3d>
  8046d3:	3b 1d 28 63 81 00    	cmp    0x816328,%ebx
  8046d9:	72 1c                	jb     8046f7 <mem_realloc+0x59>
  8046db:	c7 44 24 08 37 28 81 	movl   $0x812837,0x8(%esp)
  8046e2:	00 
  8046e3:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  8046ea:	00 
  8046eb:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  8046f2:	e8 a3 a9 00 00       	call   80f09a <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8046f7:	8d 53 f4             	lea    -0xc(%ebx),%edx
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  8046fa:	29 c2                	sub    %eax,%edx
  8046fc:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  8046ff:	8b 43 f4             	mov    -0xc(%ebx),%eax
  804702:	8d 78 f4             	lea    -0xc(%eax),%edi
  804705:	29 d7                	sub    %edx,%edi
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  804707:	39 f7                	cmp    %esi,%edi
  804709:	73 1c                	jae    804727 <mem_realloc+0x89>
  80470b:	c7 44 24 08 20 27 81 	movl   $0x812720,0x8(%esp)
  804712:	00 
  804713:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80471a:	00 
  80471b:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804722:	e8 73 a9 00 00       	call   80f09a <_panic>
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
    /* No change in size, simply return */
    return rmem;
  804727:	89 d8                	mov    %ebx,%eax
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  804729:	39 fe                	cmp    %edi,%esi
  80472b:	0f 84 b6 00 00 00    	je     8047e7 <mem_realloc+0x149>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  804731:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804738:	00 
  804739:	a1 20 63 81 00       	mov    0x816320,%eax
  80473e:	89 04 24             	mov    %eax,(%esp)
  804741:	e8 5f 62 00 00       	call   80a9a5 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  804746:	a1 2c 63 81 00       	mov    0x81632c,%eax
  80474b:	89 c2                	mov    %eax,%edx
  80474d:	03 53 f4             	add    -0xc(%ebx),%edx
  if(mem2->used == 0) {
  804750:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  804754:	75 3c                	jne    804792 <mem_realloc+0xf4>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  804756:	8b 0a                	mov    (%edx),%ecx
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804758:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80475b:	8d 74 3e 0c          	lea    0xc(%esi,%edi,1),%esi
    if (lfree == mem2) {
  80475f:	39 15 24 63 81 00    	cmp    %edx,0x816324
  804765:	75 09                	jne    804770 <mem_realloc+0xd2>
      lfree = (struct mem *)&ram[ptr2];
  804767:	8d 14 30             	lea    (%eax,%esi,1),%edx
  80476a:	89 15 24 63 81 00    	mov    %edx,0x816324
    }
    mem2 = (struct mem *)&ram[ptr2];
  804770:	8d 14 30             	lea    (%eax,%esi,1),%edx
    mem2->used = 0;
  804773:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  804777:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  804779:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80477c:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  80477f:	89 73 f4             	mov    %esi,-0xc(%ebx)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  804782:	8b 12                	mov    (%edx),%edx
  804784:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80478a:	74 45                	je     8047d1 <mem_realloc+0x133>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80478c:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  804790:	eb 3f                	jmp    8047d1 <mem_realloc+0x133>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  804792:	8d 56 18             	lea    0x18(%esi),%edx
  804795:	39 d7                	cmp    %edx,%edi
  804797:	72 38                	jb     8047d1 <mem_realloc+0x133>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  804799:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80479c:	8d 4c 0e 0c          	lea    0xc(%esi,%ecx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  8047a0:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  8047a3:	3b 15 24 63 81 00    	cmp    0x816324,%edx
  8047a9:	73 06                	jae    8047b1 <mem_realloc+0x113>
      lfree = mem2;
  8047ab:	89 15 24 63 81 00    	mov    %edx,0x816324
    }
    mem2->used = 0;
  8047b1:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  8047b5:	8b 73 f4             	mov    -0xc(%ebx),%esi
  8047b8:	89 32                	mov    %esi,(%edx)
    mem2->prev = ptr;
  8047ba:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  8047bd:	89 7a 04             	mov    %edi,0x4(%edx)
    mem->next = ptr2;
  8047c0:	89 4b f4             	mov    %ecx,-0xc(%ebx)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8047c3:	8b 12                	mov    (%edx),%edx
  8047c5:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8047cb:	74 04                	je     8047d1 <mem_realloc+0x133>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8047cd:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8047d1:	a1 20 63 81 00       	mov    0x816320,%eax
  8047d6:	89 04 24             	mov    %eax,(%esp)
  8047d9:	e8 52 61 00 00       	call   80a930 <sys_sem_signal>
  return rmem;
  8047de:	89 d8                	mov    %ebx,%eax
  8047e0:	eb 05                	jmp    8047e7 <mem_realloc+0x149>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  8047e2:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  8047e7:	83 c4 1c             	add    $0x1c,%esp
  8047ea:	5b                   	pop    %ebx
  8047eb:	5e                   	pop    %esi
  8047ec:	5f                   	pop    %edi
  8047ed:	5d                   	pop    %ebp
  8047ee:	c3                   	ret    

008047ef <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8047ef:	55                   	push   %ebp
  8047f0:	89 e5                	mov    %esp,%ebp
  8047f2:	57                   	push   %edi
  8047f3:	56                   	push   %esi
  8047f4:	53                   	push   %ebx
  8047f5:	83 ec 1c             	sub    $0x1c,%esp
  8047f8:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8047fb:	85 f6                	test   %esi,%esi
  8047fd:	0f 84 69 01 00 00    	je     80496c <mem_malloc+0x17d>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  804803:	83 c6 03             	add    $0x3,%esi
  804806:	83 e6 fc             	and    $0xfffffffc,%esi

  if(size < MIN_SIZE_ALIGNED) {
  804809:	83 fe 0b             	cmp    $0xb,%esi
  80480c:	76 0d                	jbe    80481b <mem_malloc+0x2c>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  80480e:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  804814:	76 0a                	jbe    804820 <mem_malloc+0x31>
  804816:	e9 58 01 00 00       	jmp    804973 <mem_malloc+0x184>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  80481b:	be 0c 00 00 00       	mov    $0xc,%esi
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  804820:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804827:	00 
  804828:	a1 20 63 81 00       	mov    0x816320,%eax
  80482d:	89 04 24             	mov    %eax,(%esp)
  804830:	e8 70 61 00 00       	call   80a9a5 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804835:	8b 15 2c 63 81 00    	mov    0x81632c,%edx
  80483b:	a1 24 63 81 00       	mov    0x816324,%eax
  804840:	29 d0                	sub    %edx,%eax
  804842:	b9 00 00 22 00       	mov    $0x220000,%ecx
  804847:	29 f1                	sub    %esi,%ecx
  804849:	e9 02 01 00 00       	jmp    804950 <mem_malloc+0x161>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  80484e:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804851:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  804855:	0f 85 f3 00 00 00    	jne    80494e <mem_malloc+0x15f>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  80485b:	8b 3b                	mov    (%ebx),%edi
  80485d:	83 ef 0c             	sub    $0xc,%edi
  804860:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  804862:	39 f7                	cmp    %esi,%edi
  804864:	0f 82 e4 00 00 00    	jb     80494e <mem_malloc+0x15f>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  80486a:	8d 4e 18             	lea    0x18(%esi),%ecx
  80486d:	39 f9                	cmp    %edi,%ecx
  80486f:	77 2c                	ja     80489d <mem_malloc+0xae>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  804871:	8d 4c 30 0c          	lea    0xc(%eax,%esi,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  804875:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  804878:	01 d1                	add    %edx,%ecx
          mem2->used = 0;
  80487a:	c6 41 08 00          	movb   $0x0,0x8(%ecx)
          mem2->next = mem->next;
  80487e:	8b 3b                	mov    (%ebx),%edi
  804880:	89 39                	mov    %edi,(%ecx)
          mem2->prev = ptr;
  804882:	89 41 04             	mov    %eax,0x4(%ecx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  804885:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  804888:	89 3b                	mov    %edi,(%ebx)
          mem->used = 1;
  80488a:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80488e:	8b 01                	mov    (%ecx),%eax
  804890:	3d 00 00 22 00       	cmp    $0x220000,%eax
  804895:	74 0a                	je     8048a1 <mem_malloc+0xb2>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  804897:	89 7c 02 04          	mov    %edi,0x4(%edx,%eax,1)
  80489b:	eb 04                	jmp    8048a1 <mem_malloc+0xb2>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80489d:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  8048a1:	3b 1d 24 63 81 00    	cmp    0x816324,%ebx
  8048a7:	75 2c                	jne    8048d5 <mem_malloc+0xe6>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8048a9:	8b 15 28 63 81 00    	mov    0x816328,%edx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8048af:	8b 0d 2c 63 81 00    	mov    0x81632c,%ecx
  8048b5:	89 d8                	mov    %ebx,%eax
  8048b7:	eb 06                	jmp    8048bf <mem_malloc+0xd0>
  8048b9:	89 cf                	mov    %ecx,%edi
  8048bb:	03 38                	add    (%eax),%edi
  8048bd:	89 f8                	mov    %edi,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8048bf:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  8048c3:	75 07                	jne    8048cc <mem_malloc+0xdd>
  8048c5:	a3 24 63 81 00       	mov    %eax,0x816324
  8048ca:	eb 09                	jmp    8048d5 <mem_malloc+0xe6>
  8048cc:	39 c2                	cmp    %eax,%edx
  8048ce:	75 e9                	jne    8048b9 <mem_malloc+0xca>
  8048d0:	a3 24 63 81 00       	mov    %eax,0x816324
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  8048d5:	a1 20 63 81 00       	mov    0x816320,%eax
  8048da:	89 04 24             	mov    %eax,(%esp)
  8048dd:	e8 4e 60 00 00       	call   80a930 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  8048e2:	8d 44 33 0c          	lea    0xc(%ebx,%esi,1),%eax
  8048e6:	39 05 28 63 81 00    	cmp    %eax,0x816328
  8048ec:	73 1c                	jae    80490a <mem_malloc+0x11b>
  8048ee:	c7 44 24 08 44 27 81 	movl   $0x812744,0x8(%esp)
  8048f5:	00 
  8048f6:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  8048fd:	00 
  8048fe:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804905:	e8 90 a7 00 00       	call   80f09a <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  80490a:	8d 43 0c             	lea    0xc(%ebx),%eax
  80490d:	a8 03                	test   $0x3,%al
  80490f:	74 1c                	je     80492d <mem_malloc+0x13e>
  804911:	c7 44 24 08 74 27 81 	movl   $0x812774,0x8(%esp)
  804918:	00 
  804919:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  804920:	00 
  804921:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804928:	e8 6d a7 00 00       	call   80f09a <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  80492d:	f6 c3 03             	test   $0x3,%bl
  804930:	74 46                	je     804978 <mem_malloc+0x189>
  804932:	c7 44 24 08 a4 27 81 	movl   $0x8127a4,0x8(%esp)
  804939:	00 
  80493a:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  804941:	00 
  804942:	c7 04 24 c7 27 81 00 	movl   $0x8127c7,(%esp)
  804949:	e8 4c a7 00 00       	call   80f09a <_panic>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80494e:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  804950:	39 c8                	cmp    %ecx,%eax
  804952:	0f 82 f6 fe ff ff    	jb     80484e <mem_malloc+0x5f>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  804958:	a1 20 63 81 00       	mov    0x816320,%eax
  80495d:	89 04 24             	mov    %eax,(%esp)
  804960:	e8 cb 5f 00 00       	call   80a930 <sys_sem_signal>
  return NULL;
  804965:	b8 00 00 00 00       	mov    $0x0,%eax
  80496a:	eb 0c                	jmp    804978 <mem_malloc+0x189>
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  80496c:	b8 00 00 00 00       	mov    $0x0,%eax
  804971:	eb 05                	jmp    804978 <mem_malloc+0x189>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  804973:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  804978:	83 c4 1c             	add    $0x1c,%esp
  80497b:	5b                   	pop    %ebx
  80497c:	5e                   	pop    %esi
  80497d:	5f                   	pop    %edi
  80497e:	5d                   	pop    %ebp
  80497f:	c3                   	ret    

00804980 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  804980:	55                   	push   %ebp
  804981:	89 e5                	mov    %esp,%ebp
  804983:	56                   	push   %esi
  804984:	53                   	push   %ebx
  804985:	83 ec 10             	sub    $0x10,%esp
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  804988:	8b 75 0c             	mov    0xc(%ebp),%esi
  80498b:	0f af 75 08          	imul   0x8(%ebp),%esi
  80498f:	89 34 24             	mov    %esi,(%esp)
  804992:	e8 58 fe ff ff       	call   8047ef <mem_malloc>
  804997:	89 c3                	mov    %eax,%ebx
  if (p) {
  804999:	85 c0                	test   %eax,%eax
  80499b:	74 14                	je     8049b1 <mem_calloc+0x31>
    /* zero the memory */
    memset(p, 0, count * size);
  80499d:	89 74 24 08          	mov    %esi,0x8(%esp)
  8049a1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8049a8:	00 
  8049a9:	89 04 24             	mov    %eax,(%esp)
  8049ac:	e8 56 af 00 00       	call   80f907 <memset>
  }
  return p;
}
  8049b1:	89 d8                	mov    %ebx,%eax
  8049b3:	83 c4 10             	add    $0x10,%esp
  8049b6:	5b                   	pop    %ebx
  8049b7:	5e                   	pop    %esi
  8049b8:	5d                   	pop    %ebp
  8049b9:	c3                   	ret    

008049ba <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  8049ba:	55                   	push   %ebp
  8049bb:	89 e5                	mov    %esp,%ebp
  8049bd:	56                   	push   %esi
  8049be:	53                   	push   %ebx
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  8049bf:	b8 63 63 a3 00       	mov    $0xa36363,%eax
  8049c4:	83 e0 fc             	and    $0xfffffffc,%eax
  8049c7:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  8049cc:	c7 84 12 e0 53 b3 00 	movl   $0x0,0xb353e0(%edx,%edx,1)
  8049d3:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8049d7:	0f b7 b2 c8 28 81 00 	movzwl 0x8128c8(%edx),%esi
  8049de:	b9 00 00 00 00       	mov    $0x0,%ecx
  8049e3:	eb 1c                	jmp    804a01 <memp_init+0x47>
      memp->next = memp_tab[i];
  8049e5:	8b 9c 12 e0 53 b3 00 	mov    0xb353e0(%edx,%edx,1),%ebx
  8049ec:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
  8049ee:	89 84 12 e0 53 b3 00 	mov    %eax,0xb353e0(%edx,%edx,1)
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  8049f5:	0f b7 9a e4 28 81 00 	movzwl 0x8128e4(%edx),%ebx
  8049fc:	01 d8                	add    %ebx,%eax
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  8049fe:	83 c1 01             	add    $0x1,%ecx
  804a01:	66 39 f1             	cmp    %si,%cx
  804a04:	75 df                	jne    8049e5 <memp_init+0x2b>
  804a06:	83 c2 02             	add    $0x2,%edx
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  804a09:	83 fa 1c             	cmp    $0x1c,%edx
  804a0c:	75 be                	jne    8049cc <memp_init+0x12>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  804a0e:	5b                   	pop    %ebx
  804a0f:	5e                   	pop    %esi
  804a10:	5d                   	pop    %ebp
  804a11:	c3                   	ret    

00804a12 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  804a12:	55                   	push   %ebp
  804a13:	89 e5                	mov    %esp,%ebp
  804a15:	83 ec 18             	sub    $0x18,%esp
  804a18:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  804a1b:	83 fa 0d             	cmp    $0xd,%edx
  804a1e:	76 1c                	jbe    804a3c <memp_malloc+0x2a>
  804a20:	c7 44 24 08 51 28 81 	movl   $0x812851,0x8(%esp)
  804a27:	00 
  804a28:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  804a2f:	00 
  804a30:	c7 04 24 6e 28 81 00 	movl   $0x81286e,(%esp)
  804a37:	e8 5e a6 00 00       	call   80f09a <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  804a3c:	8b 04 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%eax
  
  if (memp != NULL) {    
  804a43:	85 c0                	test   %eax,%eax
  804a45:	74 29                	je     804a70 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  804a47:	8b 08                	mov    (%eax),%ecx
  804a49:	89 0c 95 e0 53 b3 00 	mov    %ecx,0xb353e0(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  804a50:	a8 03                	test   $0x3,%al
  804a52:	74 1c                	je     804a70 <memp_malloc+0x5e>
  804a54:	c7 44 24 08 84 28 81 	movl   $0x812884,0x8(%esp)
  804a5b:	00 
  804a5c:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  804a63:	00 
  804a64:	c7 04 24 6e 28 81 00 	movl   $0x81286e,(%esp)
  804a6b:	e8 2a a6 00 00       	call   80f09a <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  804a70:	c9                   	leave  
  804a71:	c3                   	ret    

00804a72 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  804a72:	55                   	push   %ebp
  804a73:	89 e5                	mov    %esp,%ebp
  804a75:	83 ec 18             	sub    $0x18,%esp
  804a78:	8b 55 08             	mov    0x8(%ebp),%edx
  804a7b:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  804a7e:	85 c0                	test   %eax,%eax
  804a80:	74 30                	je     804ab2 <memp_free+0x40>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  804a82:	a8 03                	test   $0x3,%al
  804a84:	74 1c                	je     804aa2 <memp_free+0x30>
  804a86:	c7 44 24 08 a8 28 81 	movl   $0x8128a8,0x8(%esp)
  804a8d:	00 
  804a8e:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  804a95:	00 
  804a96:	c7 04 24 6e 28 81 00 	movl   $0x81286e,(%esp)
  804a9d:	e8 f8 a5 00 00       	call   80f09a <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  804aa2:	8b 0c 95 e0 53 b3 00 	mov    0xb353e0(,%edx,4),%ecx
  804aa9:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  804aab:	89 04 95 e0 53 b3 00 	mov    %eax,0xb353e0(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  804ab2:	c9                   	leave  
  804ab3:	c3                   	ret    
  804ab4:	66 90                	xchg   %ax,%ax
  804ab6:	66 90                	xchg   %ax,%ax
  804ab8:	66 90                	xchg   %ax,%ax
  804aba:	66 90                	xchg   %ax,%ax
  804abc:	66 90                	xchg   %ax,%ax
  804abe:	66 90                	xchg   %ax,%ax

00804ac0 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  804ac0:	55                   	push   %ebp
  804ac1:	89 e5                	mov    %esp,%ebp
  804ac3:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  804ac6:	85 c9                	test   %ecx,%ecx
  804ac8:	74 3c                	je     804b06 <netif_remove+0x46>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  804aca:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804acf:	39 c8                	cmp    %ecx,%eax
  804ad1:	75 19                	jne    804aec <netif_remove+0x2c>
    netif_list = netif->next;
  804ad3:	8b 00                	mov    (%eax),%eax
  804ad5:	a3 54 c2 b3 00       	mov    %eax,0xb3c254
  804ada:	eb 18                	jmp    804af4 <netif_remove+0x34>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  804adc:	8b 10                	mov    (%eax),%edx
  804ade:	39 ca                	cmp    %ecx,%edx
  804ae0:	74 04                	je     804ae6 <netif_remove+0x26>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804ae2:	89 d0                	mov    %edx,%eax
  804ae4:	eb 06                	jmp    804aec <netif_remove+0x2c>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  804ae6:	8b 11                	mov    (%ecx),%edx
  804ae8:	89 10                	mov    %edx,(%eax)
  804aea:	eb 08                	jmp    804af4 <netif_remove+0x34>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  804aec:	85 c0                	test   %eax,%eax
  804aee:	66 90                	xchg   %ax,%ax
  804af0:	75 ea                	jne    804adc <netif_remove+0x1c>
  804af2:	eb 12                	jmp    804b06 <netif_remove+0x46>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  804af4:	39 0d 58 c2 b3 00    	cmp    %ecx,0xb3c258
  804afa:	75 0a                	jne    804b06 <netif_remove+0x46>
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804afc:	c7 05 58 c2 b3 00 00 	movl   $0x0,0xb3c258
  804b03:	00 00 00 
  /* this netif is default? */
  if (netif_default == netif)
    /* reset default netif */
    netif_set_default(NULL);
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  804b06:	5d                   	pop    %ebp
  804b07:	c3                   	ret    

00804b08 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  804b08:	55                   	push   %ebp
  804b09:	89 e5                	mov    %esp,%ebp
  804b0b:	53                   	push   %ebx
  804b0c:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  804b0f:	85 c9                	test   %ecx,%ecx
  804b11:	74 2c                	je     804b3f <netif_find+0x37>
    return NULL;
  }

  num = name[2] - '0';
  804b13:	0f b6 41 02          	movzbl 0x2(%ecx),%eax
  804b17:	8d 50 d0             	lea    -0x30(%eax),%edx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804b1a:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804b1f:	eb 18                	jmp    804b39 <netif_find+0x31>
    if (num == netif->num &&
  804b21:	38 50 31             	cmp    %dl,0x31(%eax)
  804b24:	75 11                	jne    804b37 <netif_find+0x2f>
  804b26:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  804b2a:	38 19                	cmp    %bl,(%ecx)
  804b2c:	75 09                	jne    804b37 <netif_find+0x2f>
       name[0] == netif->name[0] &&
  804b2e:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  804b32:	38 59 01             	cmp    %bl,0x1(%ecx)
  804b35:	74 0d                	je     804b44 <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  804b37:	8b 00                	mov    (%eax),%eax
  804b39:	85 c0                	test   %eax,%eax
  804b3b:	75 e4                	jne    804b21 <netif_find+0x19>
  804b3d:	eb 05                	jmp    804b44 <netif_find+0x3c>
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  804b3f:	b8 00 00 00 00       	mov    $0x0,%eax
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  804b44:	5b                   	pop    %ebx
  804b45:	5d                   	pop    %ebp
  804b46:	c3                   	ret    

00804b47 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  804b47:	55                   	push   %ebp
  804b48:	89 e5                	mov    %esp,%ebp
  804b4a:	57                   	push   %edi
  804b4b:	56                   	push   %esi
  804b4c:	53                   	push   %ebx
  804b4d:	83 ec 1c             	sub    $0x1c,%esp
  804b50:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804b53:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  804b56:	8b 43 04             	mov    0x4(%ebx),%eax
  804b59:	39 06                	cmp    %eax,(%esi)
  804b5b:	74 53                	je     804bb0 <netif_set_ipaddr+0x69>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  804b5d:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
    while (pcb != NULL) {
  804b62:	eb 19                	jmp    804b7d <netif_set_ipaddr+0x36>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  804b64:	8b 4b 04             	mov    0x4(%ebx),%ecx
  804b67:	39 08                	cmp    %ecx,(%eax)
  804b69:	75 0f                	jne    804b7a <netif_set_ipaddr+0x33>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  804b6b:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  804b6e:	89 04 24             	mov    %eax,(%esp)
  804b71:	e8 93 16 00 00       	call   806209 <tcp_abort>
        pcb = next;
  804b76:	89 f8                	mov    %edi,%eax
  804b78:	eb 03                	jmp    804b7d <netif_set_ipaddr+0x36>
      } else {
        pcb = pcb->next;
  804b7a:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  804b7d:	85 c0                	test   %eax,%eax
  804b7f:	75 e3                	jne    804b64 <netif_set_ipaddr+0x1d>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804b81:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  804b86:	eb 24                	jmp    804bac <netif_set_ipaddr+0x65>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  804b88:	85 c0                	test   %eax,%eax
  804b8a:	74 1d                	je     804ba9 <netif_set_ipaddr+0x62>
  804b8c:	8b 10                	mov    (%eax),%edx
  804b8e:	85 d2                	test   %edx,%edx
  804b90:	74 17                	je     804ba9 <netif_set_ipaddr+0x62>
  804b92:	3b 53 04             	cmp    0x4(%ebx),%edx
  804b95:	75 12                	jne    804ba9 <netif_set_ipaddr+0x62>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  804b97:	85 f6                	test   %esi,%esi
  804b99:	74 07                	je     804ba2 <netif_set_ipaddr+0x5b>
  804b9b:	8b 16                	mov    (%esi),%edx
  804b9d:	8d 76 00             	lea    0x0(%esi),%esi
  804ba0:	eb 05                	jmp    804ba7 <netif_set_ipaddr+0x60>
  804ba2:	ba 00 00 00 00       	mov    $0x0,%edx
  804ba7:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  804ba9:	8b 40 0c             	mov    0xc(%eax),%eax
  804bac:	85 c0                	test   %eax,%eax
  804bae:	75 d8                	jne    804b88 <netif_set_ipaddr+0x41>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  804bb0:	85 f6                	test   %esi,%esi
  804bb2:	74 04                	je     804bb8 <netif_set_ipaddr+0x71>
  804bb4:	8b 06                	mov    (%esi),%eax
  804bb6:	eb 05                	jmp    804bbd <netif_set_ipaddr+0x76>
  804bb8:	b8 00 00 00 00       	mov    $0x0,%eax
  804bbd:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  804bc0:	83 c4 1c             	add    $0x1c,%esp
  804bc3:	5b                   	pop    %ebx
  804bc4:	5e                   	pop    %esi
  804bc5:	5f                   	pop    %edi
  804bc6:	5d                   	pop    %ebp
  804bc7:	c3                   	ret    

00804bc8 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  804bc8:	55                   	push   %ebp
  804bc9:	89 e5                	mov    %esp,%ebp
  804bcb:	57                   	push   %edi
  804bcc:	56                   	push   %esi
  804bcd:	53                   	push   %ebx
  804bce:	83 ec 1c             	sub    $0x1c,%esp
  804bd1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  804bd4:	8b 7d 10             	mov    0x10(%ebp),%edi
  804bd7:	8b 75 14             	mov    0x14(%ebp),%esi
  netif_set_ipaddr(netif, ipaddr);
  804bda:	8b 45 0c             	mov    0xc(%ebp),%eax
  804bdd:	89 44 24 04          	mov    %eax,0x4(%esp)
  804be1:	89 1c 24             	mov    %ebx,(%esp)
  804be4:	e8 5e ff ff ff       	call   804b47 <netif_set_ipaddr>
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804be9:	85 ff                	test   %edi,%edi
  804beb:	74 04                	je     804bf1 <netif_set_addr+0x29>
  804bed:	8b 07                	mov    (%edi),%eax
  804bef:	eb 05                	jmp    804bf6 <netif_set_addr+0x2e>
  804bf1:	b8 00 00 00 00       	mov    $0x0,%eax
  804bf6:	89 43 08             	mov    %eax,0x8(%ebx)
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  ip_addr_set(&(netif->gw), gw);
  804bf9:	85 f6                	test   %esi,%esi
  804bfb:	74 04                	je     804c01 <netif_set_addr+0x39>
  804bfd:	8b 06                	mov    (%esi),%eax
  804bff:	eb 05                	jmp    804c06 <netif_set_addr+0x3e>
  804c01:	b8 00 00 00 00       	mov    $0x0,%eax
  804c06:	89 43 0c             	mov    %eax,0xc(%ebx)
    struct ip_addr *gw)
{
  netif_set_ipaddr(netif, ipaddr);
  netif_set_netmask(netif, netmask);
  netif_set_gw(netif, gw);
}
  804c09:	83 c4 1c             	add    $0x1c,%esp
  804c0c:	5b                   	pop    %ebx
  804c0d:	5e                   	pop    %esi
  804c0e:	5f                   	pop    %edi
  804c0f:	5d                   	pop    %ebp
  804c10:	c3                   	ret    

00804c11 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  804c11:	55                   	push   %ebp
  804c12:	89 e5                	mov    %esp,%ebp
  804c14:	53                   	push   %ebx
  804c15:	83 ec 14             	sub    $0x14,%esp
  804c18:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  804c1b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  804c22:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  804c29:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  804c30:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  804c34:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  804c3b:	8b 45 18             	mov    0x18(%ebp),%eax
  804c3e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  804c41:	0f b6 05 18 54 b3 00 	movzbl 0xb35418,%eax
  804c48:	8d 50 01             	lea    0x1(%eax),%edx
  804c4b:	88 15 18 54 b3 00    	mov    %dl,0xb35418
  804c51:	88 43 31             	mov    %al,0x31(%ebx)
  netif->input = input;
  804c54:	8b 45 20             	mov    0x20(%ebp),%eax
  804c57:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  804c5a:	8b 45 14             	mov    0x14(%ebp),%eax
  804c5d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804c61:	8b 45 10             	mov    0x10(%ebp),%eax
  804c64:	89 44 24 08          	mov    %eax,0x8(%esp)
  804c68:	8b 45 0c             	mov    0xc(%ebp),%eax
  804c6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  804c6f:	89 1c 24             	mov    %ebx,(%esp)
  804c72:	e8 51 ff ff ff       	call   804bc8 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  804c77:	89 1c 24             	mov    %ebx,(%esp)
  804c7a:	ff 55 1c             	call   *0x1c(%ebp)
  804c7d:	84 c0                	test   %al,%al
  804c7f:	75 11                	jne    804c92 <netif_add+0x81>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  804c81:	a1 54 c2 b3 00       	mov    0xb3c254,%eax
  804c86:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  804c88:	89 1d 54 c2 b3 00    	mov    %ebx,0xb3c254
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  804c8e:	89 d8                	mov    %ebx,%eax
  804c90:	eb 05                	jmp    804c97 <netif_add+0x86>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  804c92:	b8 00 00 00 00       	mov    $0x0,%eax
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  804c97:	83 c4 14             	add    $0x14,%esp
  804c9a:	5b                   	pop    %ebx
  804c9b:	5d                   	pop    %ebp
  804c9c:	c3                   	ret    

00804c9d <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  804c9d:	55                   	push   %ebp
  804c9e:	89 e5                	mov    %esp,%ebp
  804ca0:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&(netif->gw), gw);
  804ca3:	85 c0                	test   %eax,%eax
  804ca5:	74 04                	je     804cab <netif_set_gw+0xe>
  804ca7:	8b 10                	mov    (%eax),%edx
  804ca9:	eb 05                	jmp    804cb0 <netif_set_gw+0x13>
  804cab:	ba 00 00 00 00       	mov    $0x0,%edx
  804cb0:	8b 45 08             	mov    0x8(%ebp),%eax
  804cb3:	89 50 0c             	mov    %edx,0xc(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  804cb6:	5d                   	pop    %ebp
  804cb7:	c3                   	ret    

00804cb8 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  804cb8:	55                   	push   %ebp
  804cb9:	89 e5                	mov    %esp,%ebp
  804cbb:	8b 45 0c             	mov    0xc(%ebp),%eax
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  804cbe:	85 c0                	test   %eax,%eax
  804cc0:	74 04                	je     804cc6 <netif_set_netmask+0xe>
  804cc2:	8b 10                	mov    (%eax),%edx
  804cc4:	eb 05                	jmp    804ccb <netif_set_netmask+0x13>
  804cc6:	ba 00 00 00 00       	mov    $0x0,%edx
  804ccb:	8b 45 08             	mov    0x8(%ebp),%eax
  804cce:	89 50 08             	mov    %edx,0x8(%eax)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  804cd1:	5d                   	pop    %ebp
  804cd2:	c3                   	ret    

00804cd3 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  804cd3:	55                   	push   %ebp
  804cd4:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  804cd6:	8b 45 08             	mov    0x8(%ebp),%eax
  804cd9:	a3 58 c2 b3 00       	mov    %eax,0xb3c258
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  804cde:	5d                   	pop    %ebp
  804cdf:	c3                   	ret    

00804ce0 <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  804ce0:	55                   	push   %ebp
  804ce1:	89 e5                	mov    %esp,%ebp
  804ce3:	83 ec 18             	sub    $0x18,%esp
  804ce6:	8b 55 08             	mov    0x8(%ebp),%edx
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  804ce9:	0f b6 42 2e          	movzbl 0x2e(%edx),%eax
  804ced:	a8 01                	test   $0x1,%al
  804cef:	75 23                	jne    804d14 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  804cf1:	89 c1                	mov    %eax,%ecx
  804cf3:	83 c9 01             	or     $0x1,%ecx
  804cf6:	88 4a 2e             	mov    %cl,0x2e(%edx)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  804cf9:	a8 20                	test   $0x20,%al
  804cfb:	74 17                	je     804d14 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  804cfd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804d04:	00 
  804d05:	8d 42 04             	lea    0x4(%edx),%eax
  804d08:	89 44 24 04          	mov    %eax,0x4(%esp)
  804d0c:	89 14 24             	mov    %edx,(%esp)
  804d0f:	e8 20 54 00 00       	call   80a134 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  804d14:	c9                   	leave  
  804d15:	c3                   	ret    

00804d16 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  804d16:	55                   	push   %ebp
  804d17:	89 e5                	mov    %esp,%ebp
  804d19:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  804d1c:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  804d20:	f6 c2 01             	test   $0x1,%dl
  804d23:	74 06                	je     804d2b <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  804d25:	83 e2 fe             	and    $0xfffffffe,%edx
  804d28:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  804d2b:	5d                   	pop    %ebp
  804d2c:	c3                   	ret    

00804d2d <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  804d2d:	55                   	push   %ebp
  804d2e:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  804d30:	8b 45 08             	mov    0x8(%ebp),%eax
  804d33:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  804d37:	83 e0 01             	and    $0x1,%eax
}
  804d3a:	5d                   	pop    %ebp
  804d3b:	c3                   	ret    
  804d3c:	66 90                	xchg   %ax,%ax
  804d3e:	66 90                	xchg   %ax,%ax

00804d40 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  804d40:	55                   	push   %ebp
  804d41:	89 e5                	mov    %esp,%ebp
  804d43:	56                   	push   %esi
  804d44:	53                   	push   %ebx
  804d45:	83 ec 10             	sub    $0x10,%esp
  804d48:	8b 55 08             	mov    0x8(%ebp),%edx
  804d4b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  804d4e:	85 d2                	test   %edx,%edx
  804d50:	75 1c                	jne    804d6e <pbuf_header+0x2e>
  804d52:	c7 44 24 08 c4 29 81 	movl   $0x8129c4,0x8(%esp)
  804d59:	00 
  804d5a:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  804d61:	00 
  804d62:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804d69:	e8 2c a3 00 00       	call   80f09a <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  804d6e:	66 85 c9             	test   %cx,%cx
  804d71:	0f 84 a1 00 00 00    	je     804e18 <pbuf_header+0xd8>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  804d77:	89 cb                	mov    %ecx,%ebx

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  804d79:	66 85 c9             	test   %cx,%cx
  804d7c:	79 24                	jns    804da2 <pbuf_header+0x62>
    increment_magnitude = -header_size_increment;
  804d7e:	f7 db                	neg    %ebx
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  804d80:	66 3b 5a 0a          	cmp    0xa(%edx),%bx
  804d84:	76 1c                	jbe    804da2 <pbuf_header+0x62>
  804d86:	c7 44 24 08 15 29 81 	movl   $0x812915,0x8(%esp)
  804d8d:	00 
  804d8e:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  804d95:	00 
  804d96:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804d9d:	e8 f8 a2 00 00       	call   80f09a <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  804da2:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  804da6:	8b 72 04             	mov    0x4(%edx),%esi

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  804da9:	66 83 f8 03          	cmp    $0x3,%ax
  804dad:	74 05                	je     804db4 <pbuf_header+0x74>
  804daf:	66 85 c0             	test   %ax,%ax
  804db2:	75 13                	jne    804dc7 <pbuf_header+0x87>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804db4:	0f bf c1             	movswl %cx,%eax
  804db7:	29 c6                	sub    %eax,%esi
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804db9:	8d 5a 10             	lea    0x10(%edx),%ebx
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
  804dbc:	b8 01 00 00 00       	mov    $0x1,%eax
  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  804dc1:	39 de                	cmp    %ebx,%esi
  804dc3:	73 41                	jae    804e06 <pbuf_header+0xc6>
  804dc5:	eb 56                	jmp    804e1d <pbuf_header+0xdd>
      p->payload = payload;
      /* bail out unsuccesfully */
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  804dc7:	83 e8 01             	sub    $0x1,%eax
  804dca:	66 83 f8 01          	cmp    $0x1,%ax
  804dce:	77 1a                	ja     804dea <pbuf_header+0xaa>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  804dd0:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  804dd5:	66 85 c9             	test   %cx,%cx
  804dd8:	79 43                	jns    804e1d <pbuf_header+0xdd>
  804dda:	66 3b 5a 0a          	cmp    0xa(%edx),%bx
  804dde:	77 3d                	ja     804e1d <pbuf_header+0xdd>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  804de0:	0f bf c1             	movswl %cx,%eax
  804de3:	29 c6                	sub    %eax,%esi
  804de5:	89 72 04             	mov    %esi,0x4(%edx)
  804de8:	eb 1f                	jmp    804e09 <pbuf_header+0xc9>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  804dea:	c7 44 24 08 33 29 81 	movl   $0x812933,0x8(%esp)
  804df1:	00 
  804df2:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  804df9:	00 
  804dfa:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804e01:	e8 94 a2 00 00       	call   80f09a <_panic>
  payload = p->payload;

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  804e06:	89 72 04             	mov    %esi,0x4(%edx)
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  804e09:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  804e0d:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  804e11:	b8 00 00 00 00       	mov    $0x0,%eax
  804e16:	eb 05                	jmp    804e1d <pbuf_header+0xdd>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  804e18:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  804e1d:	83 c4 10             	add    $0x10,%esp
  804e20:	5b                   	pop    %ebx
  804e21:	5e                   	pop    %esi
  804e22:	5d                   	pop    %ebp
  804e23:	c3                   	ret    

00804e24 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  804e24:	55                   	push   %ebp
  804e25:	89 e5                	mov    %esp,%ebp
  804e27:	56                   	push   %esi
  804e28:	53                   	push   %ebx
  804e29:	83 ec 10             	sub    $0x10,%esp
  804e2c:	8b 55 08             	mov    0x8(%ebp),%edx
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  804e2f:	85 d2                	test   %edx,%edx
  804e31:	75 1c                	jne    804e4f <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  804e33:	c7 44 24 08 c4 29 81 	movl   $0x8129c4,0x8(%esp)
  804e3a:	00 
  804e3b:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  804e42:	00 
  804e43:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804e4a:	e8 4b a2 00 00       	call   80f09a <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804e4f:	80 7a 0c 03          	cmpb   $0x3,0xc(%edx)
  804e53:	0f 86 99 00 00 00    	jbe    804ef2 <pbuf_free+0xce>
  804e59:	c7 44 24 08 41 29 81 	movl   $0x812941,0x8(%esp)
  804e60:	00 
  804e61:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  804e68:	00 
  804e69:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804e70:	e8 25 a2 00 00       	call   80f09a <_panic>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  804e75:	89 f2                	mov    %esi,%edx
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  804e77:	0f b7 4a 0e          	movzwl 0xe(%edx),%ecx
  804e7b:	66 85 c9             	test   %cx,%cx
  804e7e:	75 1c                	jne    804e9c <pbuf_free+0x78>
  804e80:	c7 44 24 08 56 29 81 	movl   $0x812956,0x8(%esp)
  804e87:	00 
  804e88:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  804e8f:	00 
  804e90:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804e97:	e8 fe a1 00 00       	call   80f09a <_panic>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  804e9c:	83 e9 01             	sub    $0x1,%ecx
  804e9f:	66 89 4a 0e          	mov    %cx,0xe(%edx)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  804ea3:	66 85 c9             	test   %cx,%cx
  804ea6:	75 54                	jne    804efc <pbuf_free+0xd8>
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  804ea8:	8b 32                	mov    (%edx),%esi
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  804eaa:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  804eae:	66 83 f8 03          	cmp    $0x3,%ax
  804eb2:	75 12                	jne    804ec6 <pbuf_free+0xa2>
        memp_free(MEMP_PBUF_POOL, p);
  804eb4:	89 54 24 04          	mov    %edx,0x4(%esp)
  804eb8:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804ebf:	e8 ae fb ff ff       	call   804a72 <memp_free>
  804ec4:	eb 23                	jmp    804ee9 <pbuf_free+0xc5>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  804ec6:	83 e8 01             	sub    $0x1,%eax
  804ec9:	66 83 f8 01          	cmp    $0x1,%ax
  804ecd:	77 12                	ja     804ee1 <pbuf_free+0xbd>
        memp_free(MEMP_PBUF, p);
  804ecf:	89 54 24 04          	mov    %edx,0x4(%esp)
  804ed3:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  804eda:	e8 93 fb ff ff       	call   804a72 <memp_free>
  804edf:	eb 08                	jmp    804ee9 <pbuf_free+0xc5>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  804ee1:	89 14 24             	mov    %edx,(%esp)
  804ee4:	e8 2c f6 ff ff       	call   804515 <mem_free>
      }
      count++;
  804ee9:	83 c3 01             	add    $0x1,%ebx
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  804eec:	85 f6                	test   %esi,%esi
  804eee:	75 85                	jne    804e75 <pbuf_free+0x51>
  804ef0:	eb 0a                	jmp    804efc <pbuf_free+0xd8>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  804ef2:	bb 00 00 00 00       	mov    $0x0,%ebx
  804ef7:	e9 7b ff ff ff       	jmp    804e77 <pbuf_free+0x53>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  804efc:	89 d8                	mov    %ebx,%eax
  804efe:	83 c4 10             	add    $0x10,%esp
  804f01:	5b                   	pop    %ebx
  804f02:	5e                   	pop    %esi
  804f03:	5d                   	pop    %ebp
  804f04:	c3                   	ret    

00804f05 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  804f05:	55                   	push   %ebp
  804f06:	89 e5                	mov    %esp,%ebp
  804f08:	57                   	push   %edi
  804f09:	56                   	push   %esi
  804f0a:	53                   	push   %ebx
  804f0b:	83 ec 1c             	sub    $0x1c,%esp
  804f0e:	8b 45 08             	mov    0x8(%ebp),%eax
  804f11:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  804f14:	83 f8 01             	cmp    $0x1,%eax
  804f17:	74 11                	je     804f2a <pbuf_alloc+0x25>
  804f19:	83 f8 01             	cmp    $0x1,%eax
  804f1c:	72 14                	jb     804f32 <pbuf_alloc+0x2d>
  804f1e:	83 f8 02             	cmp    $0x2,%eax
  804f21:	74 19                	je     804f3c <pbuf_alloc+0x37>
  804f23:	83 f8 03             	cmp    $0x3,%eax
  804f26:	74 3a                	je     804f62 <pbuf_alloc+0x5d>
  804f28:	eb 1c                	jmp    804f46 <pbuf_alloc+0x41>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f2a:	bf 00 00 00 00       	mov    $0x0,%edi
  804f2f:	90                   	nop
  804f30:	eb 05                	jmp    804f37 <pbuf_alloc+0x32>
  switch (layer) {
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  804f32:	bf 14 00 00 00       	mov    $0x14,%edi
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  804f37:	83 c7 14             	add    $0x14,%edi
  804f3a:	eb 05                	jmp    804f41 <pbuf_alloc+0x3c>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f3c:	bf 00 00 00 00       	mov    $0x0,%edi
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  804f41:	83 c7 0e             	add    $0xe,%edi
    break;
  804f44:	eb 21                	jmp    804f67 <pbuf_alloc+0x62>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  804f46:	c7 44 24 08 6c 29 81 	movl   $0x81296c,0x8(%esp)
  804f4d:	00 
  804f4e:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  804f55:	00 
  804f56:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804f5d:	e8 38 a1 00 00       	call   80f09a <_panic>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  804f62:	bf 00 00 00 00       	mov    $0x0,%edi
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  804f67:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  804f6b:	77 0f                	ja     804f7c <pbuf_alloc+0x77>
  804f6d:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
  804f71:	0f 82 6a 01 00 00    	jb     8050e1 <pbuf_alloc+0x1dc>
  804f77:	e9 a5 01 00 00       	jmp    805121 <pbuf_alloc+0x21c>
  804f7c:	83 7d 10 03          	cmpl   $0x3,0x10(%ebp)
  804f80:	0f 85 cb 01 00 00    	jne    805151 <pbuf_alloc+0x24c>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  804f86:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  804f8d:	e8 80 fa ff ff       	call   804a12 <memp_malloc>
  804f92:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  804f94:	85 c0                	test   %eax,%eax
  804f96:	0f 84 df 01 00 00    	je     80517b <pbuf_alloc+0x276>
      return NULL;
    }
    p->type = type;
  804f9c:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  804fa0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  804fa6:	0f b7 ff             	movzwl %di,%edi
  804fa9:	8d 54 38 13          	lea    0x13(%eax,%edi,1),%edx
  804fad:	83 e2 fc             	and    $0xfffffffc,%edx
  804fb0:	89 50 04             	mov    %edx,0x4(%eax)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  804fb3:	66 89 58 08          	mov    %bx,0x8(%eax)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  804fb7:	0f b7 db             	movzwl %bx,%ebx
  804fba:	83 c7 03             	add    $0x3,%edi
  804fbd:	83 e7 fc             	and    $0xfffffffc,%edi
  804fc0:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  804fc5:	29 f8                	sub    %edi,%eax
  804fc7:	39 d8                	cmp    %ebx,%eax
  804fc9:	0f 4f c3             	cmovg  %ebx,%eax
  804fcc:	66 89 46 0a          	mov    %ax,0xa(%esi)
  804fd0:	0f b7 c0             	movzwl %ax,%eax
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  804fd3:	8d be e0 07 00 00    	lea    0x7e0(%esi),%edi
  804fd9:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  804fdc:	01 c2                	add    %eax,%edx
  804fde:	39 d7                	cmp    %edx,%edi
  804fe0:	73 1c                	jae    804ffe <pbuf_alloc+0xf9>
  804fe2:	c7 44 24 08 84 2a 81 	movl   $0x812a84,0x8(%esp)
  804fe9:	00 
  804fea:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  804ff1:	00 
  804ff2:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  804ff9:	e8 9c a0 00 00       	call   80f09a <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  804ffe:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  805004:	29 c3                	sub    %eax,%ebx
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  805006:	89 f7                	mov    %esi,%edi
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  805008:	e9 c7 00 00 00       	jmp    8050d4 <pbuf_alloc+0x1cf>
      q = memp_malloc(MEMP_PBUF_POOL);
  80500d:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  805014:	e8 f9 f9 ff ff       	call   804a12 <memp_malloc>
      if (q == NULL) {
  805019:	85 c0                	test   %eax,%eax
  80501b:	75 12                	jne    80502f <pbuf_alloc+0x12a>
        /* free chain so far allocated */
        pbuf_free(p);
  80501d:	89 34 24             	mov    %esi,(%esp)
  805020:	e8 ff fd ff ff       	call   804e24 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  805025:	b8 00 00 00 00       	mov    $0x0,%eax
  80502a:	e9 5f 01 00 00       	jmp    80518e <pbuf_alloc+0x289>
      }
      q->type = type;
  80502f:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  805033:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  805037:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80503d:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80503f:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  805045:	7e 1c                	jle    805063 <pbuf_alloc+0x15e>
  805047:	c7 44 24 08 87 29 81 	movl   $0x812987,0x8(%esp)
  80504e:	00 
  80504f:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  805056:	00 
  805057:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80505e:	e8 37 a0 00 00       	call   80f09a <_panic>
      q->tot_len = (u16_t)rem_len;
  805063:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  805067:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  80506c:	b9 d0 07 00 00       	mov    $0x7d0,%ecx
  805071:	0f 46 cb             	cmovbe %ebx,%ecx
  805074:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  805078:	8d 50 10             	lea    0x10(%eax),%edx
  80507b:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  80507e:	f6 c2 03             	test   $0x3,%dl
  805081:	74 1c                	je     80509f <pbuf_alloc+0x19a>
  805083:	c7 44 24 08 b8 2a 81 	movl   $0x812ab8,0x8(%esp)
  80508a:	00 
  80508b:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  805092:	00 
  805093:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80509a:	e8 fb 9f 00 00       	call   80f09a <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  80509f:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8050a3:	03 56 04             	add    0x4(%esi),%edx
  8050a6:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8050a9:	73 1c                	jae    8050c7 <pbuf_alloc+0x1c2>
  8050ab:	c7 44 24 08 84 2a 81 	movl   $0x812a84,0x8(%esp)
  8050b2:	00 
  8050b3:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  8050ba:	00 
  8050bb:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  8050c2:	e8 d3 9f 00 00       	call   80f09a <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  8050c7:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  8050cd:	0f b7 c9             	movzwl %cx,%ecx
  8050d0:	29 cb                	sub    %ecx,%ebx
      /* remember this pbuf for linkage in next iteration */
      r = q;
  8050d2:	89 c7                	mov    %eax,%edi
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  8050d4:	85 db                	test   %ebx,%ebx
  8050d6:	0f 8f 31 ff ff ff    	jg     80500d <pbuf_alloc+0x108>
  8050dc:	e9 8c 00 00 00       	jmp    80516d <pbuf_alloc+0x268>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  8050e1:	0f b7 ff             	movzwl %di,%edi
  8050e4:	8d 57 13             	lea    0x13(%edi),%edx
  8050e7:	83 e2 fc             	and    $0xfffffffc,%edx
  8050ea:	0f b7 c3             	movzwl %bx,%eax
  8050ed:	83 c0 03             	add    $0x3,%eax
  8050f0:	83 e0 fc             	and    $0xfffffffc,%eax
  8050f3:	01 d0                	add    %edx,%eax
  8050f5:	89 04 24             	mov    %eax,(%esp)
  8050f8:	e8 f2 f6 ff ff       	call   8047ef <mem_malloc>
  8050fd:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  8050ff:	85 c0                	test   %eax,%eax
  805101:	74 7f                	je     805182 <pbuf_alloc+0x27d>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  805103:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  805107:	83 e0 fc             	and    $0xfffffffc,%eax
  80510a:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  80510d:	66 89 5e 08          	mov    %bx,0x8(%esi)
  805111:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  805115:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  80511b:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  80511f:	eb 4c                	jmp    80516d <pbuf_alloc+0x268>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  805121:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  805128:	e8 e5 f8 ff ff       	call   804a12 <memp_malloc>
  80512d:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80512f:	85 c0                	test   %eax,%eax
  805131:	74 56                	je     805189 <pbuf_alloc+0x284>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  805133:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  80513a:	66 89 58 08          	mov    %bx,0x8(%eax)
  80513e:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  805142:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  805148:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
  80514c:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  80514f:	eb 1c                	jmp    80516d <pbuf_alloc+0x268>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  805151:	c7 44 24 08 9b 29 81 	movl   $0x81299b,0x8(%esp)
  805158:	00 
  805159:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  805160:	00 
  805161:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805168:	e8 2d 9f 00 00       	call   80f09a <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80516d:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  805173:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
  805177:	89 f0                	mov    %esi,%eax
  805179:	eb 13                	jmp    80518e <pbuf_alloc+0x289>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
      return NULL;
  80517b:	b8 00 00 00 00       	mov    $0x0,%eax
  805180:	eb 0c                	jmp    80518e <pbuf_alloc+0x289>
    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
    if (p == NULL) {
      return NULL;
  805182:	b8 00 00 00 00       	mov    $0x0,%eax
  805187:	eb 05                	jmp    80518e <pbuf_alloc+0x289>
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
    if (p == NULL) {
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
  805189:	b8 00 00 00 00       	mov    $0x0,%eax
  p->ref = 1;
  /* set flags */
  p->flags = 0;
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  80518e:	83 c4 1c             	add    $0x1c,%esp
  805191:	5b                   	pop    %ebx
  805192:	5e                   	pop    %esi
  805193:	5f                   	pop    %edi
  805194:	5d                   	pop    %ebp
  805195:	c3                   	ret    

00805196 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  805196:	55                   	push   %ebp
  805197:	89 e5                	mov    %esp,%ebp
  805199:	56                   	push   %esi
  80519a:	53                   	push   %ebx
  80519b:	83 ec 10             	sub    $0x10,%esp
  80519e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8051a1:	8b 55 0c             	mov    0xc(%ebp),%edx
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  8051a4:	85 db                	test   %ebx,%ebx
  8051a6:	75 1c                	jne    8051c4 <pbuf_realloc+0x2e>
  8051a8:	c7 44 24 08 b6 29 81 	movl   $0x8129b6,0x8(%esp)
  8051af:	00 
  8051b0:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  8051b7:	00 
  8051b8:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  8051bf:	e8 d6 9e 00 00       	call   80f09a <_panic>
  8051c4:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  8051c6:	80 7b 0c 03          	cmpb   $0x3,0xc(%ebx)
  8051ca:	76 1c                	jbe    8051e8 <pbuf_realloc+0x52>
  8051cc:	c7 44 24 08 ce 29 81 	movl   $0x8129ce,0x8(%esp)
  8051d3:	00 
  8051d4:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  8051db:	00 
  8051dc:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  8051e3:	e8 b2 9e 00 00       	call   80f09a <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  8051e8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  8051ec:	66 39 d0             	cmp    %dx,%ax
  8051ef:	0f 86 be 00 00 00    	jbe    8052b3 <pbuf_realloc+0x11d>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  8051f5:	0f b7 d2             	movzwl %dx,%edx
  8051f8:	0f b7 c0             	movzwl %ax,%eax
  8051fb:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8051fd:	eb 4c                	jmp    80524b <pbuf_realloc+0xb5>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  8051ff:	29 c6                	sub    %eax,%esi
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  805201:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  805207:	7e 1c                	jle    805225 <pbuf_realloc+0x8f>
  805209:	c7 44 24 08 e9 29 81 	movl   $0x8129e9,0x8(%esp)
  805210:	00 
  805211:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  805218:	00 
  805219:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805220:	e8 75 9e 00 00       	call   80f09a <_panic>
    q->tot_len += (u16_t)grow;
  805225:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  805229:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  80522b:	85 db                	test   %ebx,%ebx
  80522d:	75 1c                	jne    80524b <pbuf_realloc+0xb5>
  80522f:	c7 44 24 08 fa 29 81 	movl   $0x8129fa,0x8(%esp)
  805236:	00 
  805237:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  80523e:	00 
  80523f:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805246:	e8 4f 9e 00 00       	call   80f09a <_panic>

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80524b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80524f:	66 39 c6             	cmp    %ax,%si
  805252:	77 ab                	ja     8051ff <pbuf_realloc+0x69>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  805254:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  805258:	75 3d                	jne    805297 <pbuf_realloc+0x101>
  80525a:	66 39 c6             	cmp    %ax,%si
  80525d:	74 38                	je     805297 <pbuf_realloc+0x101>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  80525f:	8b 4b 04             	mov    0x4(%ebx),%ecx
  805262:	29 d9                	sub    %ebx,%ecx
  805264:	0f b7 c6             	movzwl %si,%eax
  805267:	01 c8                	add    %ecx,%eax
  805269:	89 44 24 04          	mov    %eax,0x4(%esp)
  80526d:	89 1c 24             	mov    %ebx,(%esp)
  805270:	e8 29 f4 ff ff       	call   80469e <mem_realloc>
  805275:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  805277:	85 c0                	test   %eax,%eax
  805279:	75 1c                	jne    805297 <pbuf_realloc+0x101>
  80527b:	c7 44 24 08 12 2a 81 	movl   $0x812a12,0x8(%esp)
  805282:	00 
  805283:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  80528a:	00 
  80528b:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805292:	e8 03 9e 00 00       	call   80f09a <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  805297:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  80529b:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  80529f:	8b 03                	mov    (%ebx),%eax
  8052a1:	85 c0                	test   %eax,%eax
  8052a3:	74 08                	je     8052ad <pbuf_realloc+0x117>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  8052a5:	89 04 24             	mov    %eax,(%esp)
  8052a8:	e8 77 fb ff ff       	call   804e24 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  8052ad:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  8052b3:	83 c4 10             	add    $0x10,%esp
  8052b6:	5b                   	pop    %ebx
  8052b7:	5e                   	pop    %esi
  8052b8:	5d                   	pop    %ebp
  8052b9:	c3                   	ret    

008052ba <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  8052ba:	55                   	push   %ebp
  8052bb:	89 e5                	mov    %esp,%ebp
  8052bd:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  8052c0:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  8052c5:	eb 05                	jmp    8052cc <pbuf_clen+0x12>
    ++len;
  8052c7:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  8052ca:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  8052cc:	85 d2                	test   %edx,%edx
  8052ce:	75 f7                	jne    8052c7 <pbuf_clen+0xd>
    ++len;
    p = p->next;
  }
  return len;
}
  8052d0:	5d                   	pop    %ebp
  8052d1:	c3                   	ret    

008052d2 <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  8052d2:	55                   	push   %ebp
  8052d3:	89 e5                	mov    %esp,%ebp
  8052d5:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  8052d8:	85 c0                	test   %eax,%eax
  8052da:	74 05                	je     8052e1 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  8052dc:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  8052e1:	5d                   	pop    %ebp
  8052e2:	c3                   	ret    

008052e3 <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  8052e3:	55                   	push   %ebp
  8052e4:	89 e5                	mov    %esp,%ebp
  8052e6:	53                   	push   %ebx
  8052e7:	83 ec 14             	sub    $0x14,%esp
  8052ea:	8b 45 08             	mov    0x8(%ebp),%eax
  8052ed:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  8052f0:	85 c0                	test   %eax,%eax
  8052f2:	74 04                	je     8052f8 <pbuf_cat+0x15>
  8052f4:	85 db                	test   %ebx,%ebx
  8052f6:	75 26                	jne    80531e <pbuf_cat+0x3b>
  8052f8:	c7 44 24 08 e8 2a 81 	movl   $0x812ae8,0x8(%esp)
  8052ff:	00 
  805300:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  805307:	00 
  805308:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80530f:	e8 86 9d 00 00       	call   80f09a <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  805314:	0f b7 4b 08          	movzwl 0x8(%ebx),%ecx
  805318:	66 01 48 08          	add    %cx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80531c:	89 d0                	mov    %edx,%eax
  80531e:	8b 10                	mov    (%eax),%edx
  805320:	85 d2                	test   %edx,%edx
  805322:	75 f0                	jne    805314 <pbuf_cat+0x31>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  805324:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  805328:	66 3b 50 0a          	cmp    0xa(%eax),%dx
  80532c:	74 1c                	je     80534a <pbuf_cat+0x67>
  80532e:	c7 44 24 08 20 2b 81 	movl   $0x812b20,0x8(%esp)
  805335:	00 
  805336:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  80533d:	00 
  80533e:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805345:	e8 50 9d 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  80534a:	66 03 53 08          	add    0x8(%ebx),%dx
  80534e:	66 89 50 08          	mov    %dx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  805352:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  805354:	83 c4 14             	add    $0x14,%esp
  805357:	5b                   	pop    %ebx
  805358:	5d                   	pop    %ebp
  805359:	c3                   	ret    

0080535a <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  80535a:	55                   	push   %ebp
  80535b:	89 e5                	mov    %esp,%ebp
  80535d:	53                   	push   %ebx
  80535e:	83 ec 14             	sub    $0x14,%esp
  805361:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  805364:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805368:	8b 45 08             	mov    0x8(%ebp),%eax
  80536b:	89 04 24             	mov    %eax,(%esp)
  80536e:	e8 70 ff ff ff       	call   8052e3 <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  805373:	89 1c 24             	mov    %ebx,(%esp)
  805376:	e8 57 ff ff ff       	call   8052d2 <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  80537b:	83 c4 14             	add    $0x14,%esp
  80537e:	5b                   	pop    %ebx
  80537f:	5d                   	pop    %ebp
  805380:	c3                   	ret    

00805381 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  805381:	55                   	push   %ebp
  805382:	89 e5                	mov    %esp,%ebp
  805384:	57                   	push   %edi
  805385:	56                   	push   %esi
  805386:	53                   	push   %ebx
  805387:	83 ec 1c             	sub    $0x1c,%esp
  80538a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  80538d:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  80538f:	85 f6                	test   %esi,%esi
  805391:	0f 84 86 00 00 00    	je     80541d <pbuf_dechain+0x9c>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  805397:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80539b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80539f:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  8053a3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8053a6:	0f b7 fa             	movzwl %dx,%edi
  8053a9:	0f b7 c8             	movzwl %ax,%ecx
  8053ac:	29 cf                	sub    %ecx,%edi
  8053ae:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  8053b1:	74 1c                	je     8053cf <pbuf_dechain+0x4e>
  8053b3:	c7 44 24 08 50 2b 81 	movl   $0x812b50,0x8(%esp)
  8053ba:	00 
  8053bb:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  8053c2:	00 
  8053c3:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  8053ca:	e8 cb 9c 00 00       	call   80f09a <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  8053cf:	29 c2                	sub    %eax,%edx
  8053d1:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  8053d5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  8053db:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8053df:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  8053e3:	89 34 24             	mov    %esi,(%esp)
  8053e6:	e8 39 fa ff ff       	call   804e24 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  8053eb:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  8053ef:	66 39 4b 08          	cmp    %cx,0x8(%ebx)
  8053f3:	74 1c                	je     805411 <pbuf_dechain+0x90>
  8053f5:	c7 44 24 08 2d 2a 81 	movl   $0x812a2d,0x8(%esp)
  8053fc:	00 
  8053fd:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  805404:	00 
  805405:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80540c:	e8 89 9c 00 00       	call   80f09a <_panic>
  return ((tail_gone > 0) ? NULL : q);
  805411:	84 c0                	test   %al,%al
  805413:	b8 00 00 00 00       	mov    $0x0,%eax
  805418:	0f 44 c6             	cmove  %esi,%eax
  80541b:	eb 0f                	jmp    80542c <pbuf_dechain+0xab>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  80541d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  805421:	66 39 43 08          	cmp    %ax,0x8(%ebx)
  805425:	75 ce                	jne    8053f5 <pbuf_dechain+0x74>
  return ((tail_gone > 0) ? NULL : q);
  805427:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80542c:	83 c4 1c             	add    $0x1c,%esp
  80542f:	5b                   	pop    %ebx
  805430:	5e                   	pop    %esi
  805431:	5f                   	pop    %edi
  805432:	5d                   	pop    %ebp
  805433:	c3                   	ret    

00805434 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  805434:	55                   	push   %ebp
  805435:	89 e5                	mov    %esp,%ebp
  805437:	57                   	push   %edi
  805438:	56                   	push   %esi
  805439:	53                   	push   %ebx
  80543a:	83 ec 1c             	sub    $0x1c,%esp
  80543d:	8b 75 08             	mov    0x8(%ebp),%esi
  805440:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  805443:	85 f6                	test   %esi,%esi
  805445:	74 0e                	je     805455 <pbuf_copy+0x21>
  805447:	85 db                	test   %ebx,%ebx
  805449:	74 0a                	je     805455 <pbuf_copy+0x21>
  80544b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80544f:	66 39 46 08          	cmp    %ax,0x8(%esi)
  805453:	73 1c                	jae    805471 <pbuf_copy+0x3d>
  805455:	c7 44 24 08 74 2b 81 	movl   $0x812b74,0x8(%esp)
  80545c:	00 
  80545d:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  805464:	00 
  805465:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80546c:	e8 29 9c 00 00       	call   80f09a <_panic>
  805471:	bf 00 00 00 00       	mov    $0x0,%edi
  805476:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  80547c:	66 89 7d e6          	mov    %di,-0x1a(%ebp)
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  805480:	85 f6                	test   %esi,%esi
  805482:	75 1c                	jne    8054a0 <pbuf_copy+0x6c>
  805484:	c7 44 24 08 42 2a 81 	movl   $0x812a42,0x8(%esp)
  80548b:	00 
  80548c:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  805493:	00 
  805494:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80549b:	e8 fa 9b 00 00       	call   80f09a <_panic>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  8054a0:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  8054a4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8054a8:	29 c1                	sub    %eax,%ecx
  8054aa:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  8054ae:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8054b2:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  8054b4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8054b8:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  8054bc:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  8054c0:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  8054c4:	39 d1                	cmp    %edx,%ecx
  8054c6:	0f 4c c7             	cmovl  %edi,%eax
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  8054c9:	89 c7                	mov    %eax,%edi
  8054cb:	0f b7 c0             	movzwl %ax,%eax
  8054ce:	89 44 24 08          	mov    %eax,0x8(%esp)
  8054d2:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8054d6:	03 43 04             	add    0x4(%ebx),%eax
  8054d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8054dd:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8054e1:	03 46 04             	add    0x4(%esi),%eax
  8054e4:	89 04 24             	mov    %eax,(%esp)
  8054e7:	e8 d0 a4 00 00       	call   80f9bc <memcpy>
    offset_to += len;
  8054ec:	66 01 7d e4          	add    %di,-0x1c(%ebp)
    offset_from += len;
  8054f0:	66 01 7d e6          	add    %di,-0x1a(%ebp)
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  8054f4:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8054f8:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  8054fc:	76 1c                	jbe    80551a <pbuf_copy+0xe6>
  8054fe:	c7 44 24 08 4f 2a 81 	movl   $0x812a4f,0x8(%esp)
  805505:	00 
  805506:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  80550d:	00 
  80550e:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805515:	e8 80 9b 00 00       	call   80f09a <_panic>
    if (offset_to == p_to->len) {
  80551a:	66 39 45 e4          	cmp    %ax,-0x1c(%ebp)
  80551e:	75 08                	jne    805528 <pbuf_copy+0xf4>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  805520:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  805522:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  805528:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80552c:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  805530:	76 1c                	jbe    80554e <pbuf_copy+0x11a>
  805532:	c7 44 24 08 66 2a 81 	movl   $0x812a66,0x8(%esp)
  805539:	00 
  80553a:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  805541:	00 
  805542:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805549:	e8 4c 9b 00 00       	call   80f09a <_panic>
    if (offset_from >= p_from->len) {
  80554e:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  805552:	72 08                	jb     80555c <pbuf_copy+0x128>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  805554:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  805556:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  80555c:	85 db                	test   %ebx,%ebx
  80555e:	74 2b                	je     80558b <pbuf_copy+0x157>
  805560:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805564:	66 39 43 0a          	cmp    %ax,0xa(%ebx)
  805568:	75 21                	jne    80558b <pbuf_copy+0x157>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  80556a:	83 3b 00             	cmpl   $0x0,(%ebx)
  80556d:	74 1c                	je     80558b <pbuf_copy+0x157>
  80556f:	c7 44 24 08 a4 2b 81 	movl   $0x812ba4,0x8(%esp)
  805576:	00 
  805577:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  80557e:	00 
  80557f:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  805586:	e8 0f 9b 00 00       	call   80f09a <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  80558b:	85 f6                	test   %esi,%esi
  80558d:	74 2b                	je     8055ba <pbuf_copy+0x186>
  80558f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  805593:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  805597:	75 21                	jne    8055ba <pbuf_copy+0x186>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  805599:	83 3e 00             	cmpl   $0x0,(%esi)
  80559c:	74 1c                	je     8055ba <pbuf_copy+0x186>
  80559e:	c7 44 24 08 a4 2b 81 	movl   $0x812ba4,0x8(%esp)
  8055a5:	00 
  8055a6:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  8055ad:	00 
  8055ae:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  8055b5:	e8 e0 9a 00 00       	call   80f09a <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  8055ba:	85 db                	test   %ebx,%ebx
  8055bc:	0f 85 be fe ff ff    	jne    805480 <pbuf_copy+0x4c>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  8055c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8055c7:	83 c4 1c             	add    $0x1c,%esp
  8055ca:	5b                   	pop    %ebx
  8055cb:	5e                   	pop    %esi
  8055cc:	5f                   	pop    %edi
  8055cd:	5d                   	pop    %ebp
  8055ce:	c3                   	ret    

008055cf <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  8055cf:	55                   	push   %ebp
  8055d0:	89 e5                	mov    %esp,%ebp
  8055d2:	57                   	push   %edi
  8055d3:	56                   	push   %esi
  8055d4:	53                   	push   %ebx
  8055d5:	83 ec 1c             	sub    $0x1c,%esp
  8055d8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8055db:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  8055df:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  8055e3:	85 db                	test   %ebx,%ebx
  8055e5:	75 1c                	jne    805603 <pbuf_copy_partial+0x34>
  8055e7:	c7 44 24 08 d0 2b 81 	movl   $0x812bd0,0x8(%esp)
  8055ee:	00 
  8055ef:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  8055f6:	00 
  8055f7:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  8055fe:	e8 97 9a 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  805603:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  805607:	74 0e                	je     805617 <pbuf_copy_partial+0x48>
  805609:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  80560f:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  805615:	eb 6b                	jmp    805682 <pbuf_copy_partial+0xb3>
  805617:	c7 44 24 08 f4 2b 81 	movl   $0x812bf4,0x8(%esp)
  80561e:	00 
  80561f:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  805626:	00 
  805627:	c7 04 24 00 29 81 00 	movl   $0x812900,(%esp)
  80562e:	e8 67 9a 00 00       	call   80f09a <_panic>
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  805633:	66 85 c0             	test   %ax,%ax
  805636:	74 0d                	je     805645 <pbuf_copy_partial+0x76>
  805638:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80563c:	66 39 d0             	cmp    %dx,%ax
  80563f:	72 04                	jb     805645 <pbuf_copy_partial+0x76>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  805641:	29 d0                	sub    %edx,%eax
  805643:	eb 3b                	jmp    805680 <pbuf_copy_partial+0xb1>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  805645:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  805649:	29 c7                	sub    %eax,%edi
  80564b:	66 39 f7             	cmp    %si,%di
  80564e:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  805651:	0f b7 d7             	movzwl %di,%edx
  805654:	89 54 24 08          	mov    %edx,0x8(%esp)
  805658:	0f b7 c0             	movzwl %ax,%eax
  80565b:	03 43 04             	add    0x4(%ebx),%eax
  80565e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805662:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805666:	03 45 0c             	add    0xc(%ebp),%eax
  805669:	89 04 24             	mov    %eax,(%esp)
  80566c:	e8 4b a3 00 00       	call   80f9bc <memcpy>
      copied_total += buf_copy_len;
  805671:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  805675:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  805679:	29 fe                	sub    %edi,%esi
      offset = 0;
  80567b:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  805680:	8b 1b                	mov    (%ebx),%ebx
  805682:	85 db                	test   %ebx,%ebx
  805684:	74 05                	je     80568b <pbuf_copy_partial+0xbc>
  805686:	66 85 f6             	test   %si,%si
  805689:	75 a8                	jne    805633 <pbuf_copy_partial+0x64>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  80568b:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80568f:	83 c4 1c             	add    $0x1c,%esp
  805692:	5b                   	pop    %ebx
  805693:	5e                   	pop    %esi
  805694:	5f                   	pop    %edi
  805695:	5d                   	pop    %ebp
  805696:	c3                   	ret    
  805697:	66 90                	xchg   %ax,%ax
  805699:	66 90                	xchg   %ax,%ax
  80569b:	66 90                	xchg   %ax,%ax
  80569d:	66 90                	xchg   %ax,%ax
  80569f:	90                   	nop

008056a0 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  8056a0:	55                   	push   %ebp
  8056a1:	89 e5                	mov    %esp,%ebp
  8056a3:	83 ec 18             	sub    $0x18,%esp
  8056a6:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  8056a9:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  8056ae:	8b 40 04             	mov    0x4(%eax),%eax
  8056b1:	8b 00                	mov    (%eax),%eax
  8056b3:	89 04 24             	mov    %eax,(%esp)
  8056b6:	e8 75 52 00 00       	call   80a930 <sys_sem_signal>
}
  8056bb:	c9                   	leave  
  8056bc:	c3                   	ret    

008056bd <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  8056bd:	55                   	push   %ebp
  8056be:	89 e5                	mov    %esp,%ebp
  8056c0:	57                   	push   %edi
  8056c1:	56                   	push   %esi
  8056c2:	53                   	push   %ebx
  8056c3:	83 ec 1c             	sub    $0x1c,%esp
  8056c6:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  8056c9:	e8 ce 56 00 00       	call   80ad9c <sys_arch_timeouts>
  8056ce:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  8056d0:	85 c0                	test   %eax,%eax
  8056d2:	74 06                	je     8056da <sys_mbox_fetch+0x1d>
  8056d4:	8b 00                	mov    (%eax),%eax
  8056d6:	85 c0                	test   %eax,%eax
  8056d8:	75 19                	jne    8056f3 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  8056da:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8056e1:	00 
  8056e2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8056e6:	8b 45 08             	mov    0x8(%ebp),%eax
  8056e9:	89 04 24             	mov    %eax,(%esp)
  8056ec:	e8 d7 54 00 00       	call   80abc8 <sys_arch_mbox_fetch>
  8056f1:	eb 5d                	jmp    805750 <sys_mbox_fetch+0x93>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  8056f3:	8b 40 04             	mov    0x4(%eax),%eax
  8056f6:	85 c0                	test   %eax,%eax
  8056f8:	74 18                	je     805712 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  8056fa:	89 44 24 08          	mov    %eax,0x8(%esp)
  8056fe:	89 7c 24 04          	mov    %edi,0x4(%esp)
  805702:	8b 45 08             	mov    0x8(%ebp),%eax
  805705:	89 04 24             	mov    %eax,(%esp)
  805708:	e8 bb 54 00 00       	call   80abc8 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80570d:	83 f8 ff             	cmp    $0xffffffff,%eax
  805710:	75 27                	jne    805739 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  805712:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  805714:	8b 10                	mov    (%eax),%edx
  805716:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  805718:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80571b:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80571e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805722:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  805729:	e8 44 f3 ff ff       	call   804a72 <memp_free>
      if (h != NULL) {
  80572e:	85 db                	test   %ebx,%ebx
  805730:	74 97                	je     8056c9 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  805732:	89 34 24             	mov    %esi,(%esp)
  805735:	ff d3                	call   *%ebx
  805737:	eb 90                	jmp    8056c9 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  805739:	8b 13                	mov    (%ebx),%edx
  80573b:	8b 4a 04             	mov    0x4(%edx),%ecx
  80573e:	39 c8                	cmp    %ecx,%eax
  805740:	73 07                	jae    805749 <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  805742:	29 c1                	sub    %eax,%ecx
  805744:	89 4a 04             	mov    %ecx,0x4(%edx)
  805747:	eb 07                	jmp    805750 <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  805749:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  805750:	83 c4 1c             	add    $0x1c,%esp
  805753:	5b                   	pop    %ebx
  805754:	5e                   	pop    %esi
  805755:	5f                   	pop    %edi
  805756:	5d                   	pop    %ebp
  805757:	c3                   	ret    

00805758 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  805758:	55                   	push   %ebp
  805759:	89 e5                	mov    %esp,%ebp
  80575b:	57                   	push   %edi
  80575c:	56                   	push   %esi
  80575d:	53                   	push   %ebx
  80575e:	83 ec 1c             	sub    $0x1c,%esp
  805761:	8b 75 08             	mov    0x8(%ebp),%esi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  805764:	e8 33 56 00 00       	call   80ad9c <sys_arch_timeouts>
  805769:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80576b:	85 c0                	test   %eax,%eax
  80576d:	74 06                	je     805775 <sys_sem_wait+0x1d>
  80576f:	8b 00                	mov    (%eax),%eax
  805771:	85 c0                	test   %eax,%eax
  805773:	75 12                	jne    805787 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  805775:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80577c:	00 
  80577d:	89 34 24             	mov    %esi,(%esp)
  805780:	e8 20 52 00 00       	call   80a9a5 <sys_arch_sem_wait>
  805785:	eb 56                	jmp    8057dd <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  805787:	8b 40 04             	mov    0x4(%eax),%eax
  80578a:	85 c0                	test   %eax,%eax
  80578c:	74 11                	je     80579f <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  80578e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805792:	89 34 24             	mov    %esi,(%esp)
  805795:	e8 0b 52 00 00       	call   80a9a5 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80579a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80579d:	75 27                	jne    8057c6 <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  80579f:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8057a1:	8b 10                	mov    (%eax),%edx
  8057a3:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  8057a5:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8057a8:	8b 78 0c             	mov    0xc(%eax),%edi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8057ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8057af:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8057b6:	e8 b7 f2 ff ff       	call   804a72 <memp_free>
      if (h != NULL) {
  8057bb:	85 db                	test   %ebx,%ebx
  8057bd:	74 a5                	je     805764 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8057bf:	89 3c 24             	mov    %edi,(%esp)
  8057c2:	ff d3                	call   *%ebx
  8057c4:	eb 9e                	jmp    805764 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8057c6:	8b 13                	mov    (%ebx),%edx
  8057c8:	8b 4a 04             	mov    0x4(%edx),%ecx
  8057cb:	39 c8                	cmp    %ecx,%eax
  8057cd:	73 07                	jae    8057d6 <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  8057cf:	29 c1                	sub    %eax,%ecx
  8057d1:	89 4a 04             	mov    %ecx,0x4(%edx)
  8057d4:	eb 07                	jmp    8057dd <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  8057d6:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8057dd:	83 c4 1c             	add    $0x1c,%esp
  8057e0:	5b                   	pop    %ebx
  8057e1:	5e                   	pop    %esi
  8057e2:	5f                   	pop    %edi
  8057e3:	5d                   	pop    %ebp
  8057e4:	c3                   	ret    

008057e5 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8057e5:	55                   	push   %ebp
  8057e6:	89 e5                	mov    %esp,%ebp
  8057e8:	56                   	push   %esi
  8057e9:	53                   	push   %ebx
  8057ea:	83 ec 10             	sub    $0x10,%esp
  8057ed:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  8057f0:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8057f7:	e8 16 f2 ff ff       	call   804a12 <memp_malloc>
  8057fc:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  8057fe:	85 c0                	test   %eax,%eax
  805800:	75 1c                	jne    80581e <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  805802:	c7 44 24 08 19 2c 81 	movl   $0x812c19,0x8(%esp)
  805809:	00 
  80580a:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  805811:	00 
  805812:	c7 04 24 36 2c 81 00 	movl   $0x812c36,(%esp)
  805819:	e8 7c 98 00 00       	call   80f09a <_panic>
    return;
  }
  timeout->next = NULL;
  80581e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  805824:	8b 45 0c             	mov    0xc(%ebp),%eax
  805827:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  80582a:	8b 45 10             	mov    0x10(%ebp),%eax
  80582d:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  805830:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  805833:	e8 64 55 00 00       	call   80ad9c <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  805838:	85 c0                	test   %eax,%eax
  80583a:	75 1c                	jne    805858 <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  80583c:	c7 44 24 08 4a 2c 81 	movl   $0x812c4a,0x8(%esp)
  805843:	00 
  805844:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  80584b:	00 
  80584c:	c7 04 24 36 2c 81 00 	movl   $0x812c36,(%esp)
  805853:	e8 42 98 00 00       	call   80f09a <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  805858:	8b 08                	mov    (%eax),%ecx
  80585a:	85 c9                	test   %ecx,%ecx
  80585c:	75 04                	jne    805862 <sys_timeout+0x7d>
    timeouts->next = timeout;
  80585e:	89 18                	mov    %ebx,(%eax)
    return;
  805860:	eb 35                	jmp    805897 <sys_timeout+0xb2>
  }

  if (timeouts->next->time > msecs) {
  805862:	8b 51 04             	mov    0x4(%ecx),%edx
  805865:	39 d6                	cmp    %edx,%esi
  805867:	73 0d                	jae    805876 <sys_timeout+0x91>
    timeouts->next->time -= msecs;
  805869:	29 f2                	sub    %esi,%edx
  80586b:	89 51 04             	mov    %edx,0x4(%ecx)
    timeout->next = timeouts->next;
  80586e:	8b 10                	mov    (%eax),%edx
  805870:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  805872:	89 18                	mov    %ebx,(%eax)
  805874:	eb 21                	jmp    805897 <sys_timeout+0xb2>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  805876:	8b 43 04             	mov    0x4(%ebx),%eax
  805879:	2b 41 04             	sub    0x4(%ecx),%eax
  80587c:	89 43 04             	mov    %eax,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  80587f:	8b 11                	mov    (%ecx),%edx
  805881:	85 d2                	test   %edx,%edx
  805883:	74 0c                	je     805891 <sys_timeout+0xac>
  805885:	3b 42 04             	cmp    0x4(%edx),%eax
  805888:	72 04                	jb     80588e <sys_timeout+0xa9>
  80588a:	89 d1                	mov    %edx,%ecx
  80588c:	eb e8                	jmp    805876 <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80588e:	29 42 04             	sub    %eax,0x4(%edx)
        }
        timeout->next = t->next;
  805891:	8b 01                	mov    (%ecx),%eax
  805893:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  805895:	89 19                	mov    %ebx,(%ecx)
        break;
      }
    }
  }
}
  805897:	83 c4 10             	add    $0x10,%esp
  80589a:	5b                   	pop    %ebx
  80589b:	5e                   	pop    %esi
  80589c:	5d                   	pop    %ebp
  80589d:	c3                   	ret    

0080589e <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  80589e:	55                   	push   %ebp
  80589f:	89 e5                	mov    %esp,%ebp
  8058a1:	57                   	push   %edi
  8058a2:	56                   	push   %esi
  8058a3:	53                   	push   %ebx
  8058a4:	83 ec 1c             	sub    $0x1c,%esp
  8058a7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8058aa:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  8058ad:	e8 ea 54 00 00       	call   80ad9c <sys_arch_timeouts>

  if (timeouts == NULL) {
  8058b2:	85 c0                	test   %eax,%eax
  8058b4:	75 1c                	jne    8058d2 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8058b6:	c7 44 24 08 68 2c 81 	movl   $0x812c68,0x8(%esp)
  8058bd:	00 
  8058be:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  8058c5:	00 
  8058c6:	c7 04 24 36 2c 81 00 	movl   $0x812c36,(%esp)
  8058cd:	e8 c8 97 00 00       	call   80f09a <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  8058d2:	8b 10                	mov    (%eax),%edx
  8058d4:	85 d2                	test   %edx,%edx
  8058d6:	74 4a                	je     805922 <sys_untimeout+0x84>
  8058d8:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  8058dd:	39 5a 08             	cmp    %ebx,0x8(%edx)
  8058e0:	75 32                	jne    805914 <sys_untimeout+0x76>
  8058e2:	39 72 0c             	cmp    %esi,0xc(%edx)
  8058e5:	75 2d                	jne    805914 <sys_untimeout+0x76>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  8058e7:	85 ff                	test   %edi,%edi
  8058e9:	75 07                	jne    8058f2 <sys_untimeout+0x54>
        timeouts->next = t->next;
  8058eb:	8b 0a                	mov    (%edx),%ecx
  8058ed:	89 08                	mov    %ecx,(%eax)
  8058ef:	90                   	nop
  8058f0:	eb 04                	jmp    8058f6 <sys_untimeout+0x58>
      else
        prev_t->next = t->next;
  8058f2:	8b 02                	mov    (%edx),%eax
  8058f4:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  8058f6:	8b 02                	mov    (%edx),%eax
  8058f8:	85 c0                	test   %eax,%eax
  8058fa:	74 06                	je     805902 <sys_untimeout+0x64>
        t->next->time += t->time;
  8058fc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8058ff:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  805902:	89 54 24 04          	mov    %edx,0x4(%esp)
  805906:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80590d:	e8 60 f1 ff ff       	call   804a72 <memp_free>
      return;
  805912:	eb 0e                	jmp    805922 <sys_untimeout+0x84>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  805914:	8b 0a                	mov    (%edx),%ecx
  805916:	85 c9                	test   %ecx,%ecx
  805918:	74 08                	je     805922 <sys_untimeout+0x84>
  80591a:	89 d7                	mov    %edx,%edi
  80591c:	89 ca                	mov    %ecx,%edx
  80591e:	66 90                	xchg   %ax,%ax
  805920:	eb bb                	jmp    8058dd <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  805922:	83 c4 1c             	add    $0x1c,%esp
  805925:	5b                   	pop    %ebx
  805926:	5e                   	pop    %esi
  805927:	5f                   	pop    %edi
  805928:	5d                   	pop    %ebp
  805929:	c3                   	ret    

0080592a <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  80592a:	55                   	push   %ebp
  80592b:	89 e5                	mov    %esp,%ebp
  80592d:	83 ec 28             	sub    $0x28,%esp
  805930:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  805933:	8d 4d 08             	lea    0x8(%ebp),%ecx
  805936:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  805939:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  80593f:	85 c0                	test   %eax,%eax
  805941:	74 17                	je     80595a <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  805943:	8d 55 f0             	lea    -0x10(%ebp),%edx
  805946:	89 54 24 08          	mov    %edx,0x8(%esp)
  80594a:	c7 44 24 04 a0 56 80 	movl   $0x8056a0,0x4(%esp)
  805951:	00 
  805952:	89 04 24             	mov    %eax,(%esp)
  805955:	e8 8b fe ff ff       	call   8057e5 <sys_timeout>
  }
  sys_sem_wait(sem);
  80595a:	8b 45 08             	mov    0x8(%ebp),%eax
  80595d:	89 04 24             	mov    %eax,(%esp)
  805960:	e8 f3 fd ff ff       	call   805758 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
    /* timeout */
    return 0;
  805965:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  80596a:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80596f:	75 18                	jne    805989 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  805971:	8d 45 f0             	lea    -0x10(%ebp),%eax
  805974:	89 44 24 04          	mov    %eax,0x4(%esp)
  805978:	c7 04 24 a0 56 80 00 	movl   $0x8056a0,(%esp)
  80597f:	e8 1a ff ff ff       	call   80589e <sys_untimeout>
    return 1;
  805984:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  805989:	c9                   	leave  
  80598a:	c3                   	ret    

0080598b <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80598b:	55                   	push   %ebp
  80598c:	89 e5                	mov    %esp,%ebp
  80598e:	53                   	push   %ebx
  80598f:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  805992:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805999:	e8 b0 4c 00 00       	call   80a64e <sys_sem_new>
  80599e:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  8059a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8059a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8059a7:	89 1c 24             	mov    %ebx,(%esp)
  8059aa:	e8 7b ff ff ff       	call   80592a <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  8059af:	89 1c 24             	mov    %ebx,(%esp)
  8059b2:	e8 20 4d 00 00       	call   80a6d7 <sys_sem_free>
}
  8059b7:	83 c4 14             	add    $0x14,%esp
  8059ba:	5b                   	pop    %ebx
  8059bb:	5d                   	pop    %ebp
  8059bc:	c3                   	ret    
  8059bd:	66 90                	xchg   %ax,%ax
  8059bf:	90                   	nop

008059c0 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  8059c0:	55                   	push   %ebp
  8059c1:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  8059c3:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  8059c8:	5d                   	pop    %ebp
  8059c9:	c3                   	ret    

008059ca <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  8059ca:	55                   	push   %ebp
  8059cb:	89 e5                	mov    %esp,%ebp
  8059cd:	57                   	push   %edi
  8059ce:	56                   	push   %esi
  8059cf:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059d0:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8059d6:	8b 35 70 c2 b3 00    	mov    0xb3c270,%esi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  8059dc:	8b 3d 64 c2 b3 00    	mov    0xb3c264,%edi
  8059e2:	0f b7 05 0c 50 81 00 	movzwl 0x81500c,%eax
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  8059e9:	b9 00 10 00 00       	mov    $0x1000,%ecx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  8059ee:	66 83 c0 01          	add    $0x1,%ax
    port = TCP_LOCAL_PORT_RANGE_START;
  8059f2:	0f 48 c1             	cmovs  %ecx,%eax
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059f5:	89 da                	mov    %ebx,%edx
  8059f7:	eb 09                	jmp    805a02 <tcp_new_port+0x38>
    if (pcb->local_port == port) {
  8059f9:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  8059fd:	74 ef                	je     8059ee <tcp_new_port+0x24>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8059ff:	8b 52 0c             	mov    0xc(%edx),%edx
  805a02:	85 d2                	test   %edx,%edx
  805a04:	75 f3                	jne    8059f9 <tcp_new_port+0x2f>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805a06:	89 f2                	mov    %esi,%edx
  805a08:	eb 09                	jmp    805a13 <tcp_new_port+0x49>
    if (pcb->local_port == port) {
  805a0a:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805a0e:	74 de                	je     8059ee <tcp_new_port+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  805a10:	8b 52 0c             	mov    0xc(%edx),%edx
  805a13:	85 d2                	test   %edx,%edx
  805a15:	75 f3                	jne    805a0a <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805a17:	89 fa                	mov    %edi,%edx
  805a19:	eb 09                	jmp    805a24 <tcp_new_port+0x5a>
    if (pcb->local_port == port) {
  805a1b:	66 3b 42 1c          	cmp    0x1c(%edx),%ax
  805a1f:	74 cd                	je     8059ee <tcp_new_port+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  805a21:	8b 52 0c             	mov    0xc(%edx),%edx
  805a24:	85 d2                	test   %edx,%edx
  805a26:	75 f3                	jne    805a1b <tcp_new_port+0x51>
  805a28:	66 a3 0c 50 81 00    	mov    %ax,0x81500c
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  805a2e:	5b                   	pop    %ebx
  805a2f:	5e                   	pop    %esi
  805a30:	5f                   	pop    %edi
  805a31:	5d                   	pop    %ebp
  805a32:	c3                   	ret    

00805a33 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  805a33:	55                   	push   %ebp
  805a34:	89 e5                	mov    %esp,%ebp
  805a36:	57                   	push   %edi
  805a37:	56                   	push   %esi
  805a38:	53                   	push   %ebx
  805a39:	83 ec 1c             	sub    $0x1c,%esp
  805a3c:	8b 75 08             	mov    0x8(%ebp),%esi
  805a3f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805a42:	8b 55 10             	mov    0x10(%ebp),%edx
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  805a45:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  805a49:	74 1c                	je     805a67 <tcp_bind+0x34>
  805a4b:	c7 44 24 08 88 2c 81 	movl   $0x812c88,0x8(%esp)
  805a52:	00 
  805a53:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  805a5a:	00 
  805a5b:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  805a62:	e8 33 96 00 00       	call   80f09a <_panic>
  805a67:	89 d0                	mov    %edx,%eax

  if (port == 0) {
  805a69:	66 85 d2             	test   %dx,%dx
  805a6c:	75 05                	jne    805a73 <tcp_bind+0x40>
    port = tcp_new_port();
  805a6e:	e8 57 ff ff ff       	call   8059ca <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805a73:	8b 15 64 c2 b3 00    	mov    0xb3c264,%edx
  805a79:	eb 35                	jmp    805ab0 <tcp_bind+0x7d>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805a7b:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805a7f:	75 2c                	jne    805aad <tcp_bind+0x7a>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805a81:	85 d2                	test   %edx,%edx
  805a83:	0f 84 f7 00 00 00    	je     805b80 <tcp_bind+0x14d>
  805a89:	8b 0a                	mov    (%edx),%ecx
  805a8b:	85 c9                	test   %ecx,%ecx
  805a8d:	0f 84 f4 00 00 00    	je     805b87 <tcp_bind+0x154>
  805a93:	85 db                	test   %ebx,%ebx
  805a95:	0f 84 f3 00 00 00    	je     805b8e <tcp_bind+0x15b>
          ip_addr_isany(ipaddr) ||
  805a9b:	8b 3b                	mov    (%ebx),%edi
  805a9d:	85 ff                	test   %edi,%edi
  805a9f:	0f 84 f0 00 00 00    	je     805b95 <tcp_bind+0x162>
  805aa5:	39 f9                	cmp    %edi,%ecx
  805aa7:	0f 84 ef 00 00 00    	je     805b9c <tcp_bind+0x169>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805aad:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  805ab0:	85 d2                	test   %edx,%edx
  805ab2:	75 c7                	jne    805a7b <tcp_bind+0x48>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805ab4:	8b 15 5c c2 b3 00    	mov    0xb3c25c,%edx
  805aba:	eb 35                	jmp    805af1 <tcp_bind+0xbe>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  805abc:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805ac0:	75 2c                	jne    805aee <tcp_bind+0xbb>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805ac2:	85 d2                	test   %edx,%edx
  805ac4:	0f 84 d9 00 00 00    	je     805ba3 <tcp_bind+0x170>
  805aca:	8b 0a                	mov    (%edx),%ecx
  805acc:	85 c9                	test   %ecx,%ecx
  805ace:	0f 84 d6 00 00 00    	je     805baa <tcp_bind+0x177>
  805ad4:	85 db                	test   %ebx,%ebx
  805ad6:	0f 84 d5 00 00 00    	je     805bb1 <tcp_bind+0x17e>
          ip_addr_isany(ipaddr) ||
  805adc:	8b 3b                	mov    (%ebx),%edi
  805ade:	85 ff                	test   %edi,%edi
  805ae0:	0f 84 d2 00 00 00    	je     805bb8 <tcp_bind+0x185>
  805ae6:	39 f9                	cmp    %edi,%ecx
  805ae8:	0f 84 d1 00 00 00    	je     805bbf <tcp_bind+0x18c>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  805aee:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  805af1:	85 d2                	test   %edx,%edx
  805af3:	75 c7                	jne    805abc <tcp_bind+0x89>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805af5:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  805afb:	eb 35                	jmp    805b32 <tcp_bind+0xff>
    if (cpcb->local_port == port) {
  805afd:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805b01:	75 2c                	jne    805b2f <tcp_bind+0xfc>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  805b03:	85 d2                	test   %edx,%edx
  805b05:	0f 84 bb 00 00 00    	je     805bc6 <tcp_bind+0x193>
  805b0b:	8b 0a                	mov    (%edx),%ecx
  805b0d:	85 c9                	test   %ecx,%ecx
  805b0f:	0f 84 b8 00 00 00    	je     805bcd <tcp_bind+0x19a>
  805b15:	85 db                	test   %ebx,%ebx
  805b17:	0f 84 b7 00 00 00    	je     805bd4 <tcp_bind+0x1a1>
          ip_addr_isany(ipaddr) ||
  805b1d:	8b 3b                	mov    (%ebx),%edi
  805b1f:	85 ff                	test   %edi,%edi
  805b21:	0f 84 b4 00 00 00    	je     805bdb <tcp_bind+0x1a8>
  805b27:	39 f9                	cmp    %edi,%ecx
  805b29:	0f 84 b3 00 00 00    	je     805be2 <tcp_bind+0x1af>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805b2f:	8b 52 0c             	mov    0xc(%edx),%edx
  805b32:	85 d2                	test   %edx,%edx
  805b34:	75 c7                	jne    805afd <tcp_bind+0xca>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805b36:	8b 15 70 c2 b3 00    	mov    0xb3c270,%edx
  805b3c:	eb 13                	jmp    805b51 <tcp_bind+0x11e>
    if (cpcb->local_port == port) {
  805b3e:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  805b42:	75 0a                	jne    805b4e <tcp_bind+0x11b>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  805b44:	8b 3b                	mov    (%ebx),%edi
  805b46:	39 3a                	cmp    %edi,(%edx)
  805b48:	0f 84 9b 00 00 00    	je     805be9 <tcp_bind+0x1b6>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  805b4e:	8b 52 0c             	mov    0xc(%edx),%edx
  805b51:	85 d2                	test   %edx,%edx
  805b53:	75 e9                	jne    805b3e <tcp_bind+0x10b>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  805b55:	85 db                	test   %ebx,%ebx
  805b57:	74 09                	je     805b62 <tcp_bind+0x12f>
  805b59:	83 3b 00             	cmpl   $0x0,(%ebx)
  805b5c:	74 04                	je     805b62 <tcp_bind+0x12f>
    pcb->local_ip = *ipaddr;
  805b5e:	8b 13                	mov    (%ebx),%edx
  805b60:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  805b62:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  805b66:	a1 6c c2 b3 00       	mov    0xb3c26c,%eax
  805b6b:	89 46 0c             	mov    %eax,0xc(%esi)
  805b6e:	89 35 6c c2 b3 00    	mov    %esi,0xb3c26c
  805b74:	e8 29 ca ff ff       	call   8025a2 <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  805b79:	b8 00 00 00 00       	mov    $0x0,%eax
  805b7e:	eb 6e                	jmp    805bee <tcp_bind+0x1bb>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805b80:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b85:	eb 67                	jmp    805bee <tcp_bind+0x1bb>
  805b87:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b8c:	eb 60                	jmp    805bee <tcp_bind+0x1bb>
  805b8e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b93:	eb 59                	jmp    805bee <tcp_bind+0x1bb>
  805b95:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805b9a:	eb 52                	jmp    805bee <tcp_bind+0x1bb>
  805b9c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805ba1:	eb 4b                	jmp    805bee <tcp_bind+0x1bb>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805ba3:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805ba8:	eb 44                	jmp    805bee <tcp_bind+0x1bb>
  805baa:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805baf:	eb 3d                	jmp    805bee <tcp_bind+0x1bb>
  805bb1:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bb6:	eb 36                	jmp    805bee <tcp_bind+0x1bb>
  805bb8:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bbd:	eb 2f                	jmp    805bee <tcp_bind+0x1bb>
  805bbf:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bc4:	eb 28                	jmp    805bee <tcp_bind+0x1bb>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805bc6:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bcb:	eb 21                	jmp    805bee <tcp_bind+0x1bb>
  805bcd:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bd2:	eb 1a                	jmp    805bee <tcp_bind+0x1bb>
  805bd4:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805bd9:	eb 13                	jmp    805bee <tcp_bind+0x1bb>
  805bdb:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805be0:	eb 0c                	jmp    805bee <tcp_bind+0x1bb>
  805be2:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  805be7:	eb 05                	jmp    805bee <tcp_bind+0x1bb>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  805be9:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  805bee:	83 c4 1c             	add    $0x1c,%esp
  805bf1:	5b                   	pop    %ebx
  805bf2:	5e                   	pop    %esi
  805bf3:	5f                   	pop    %edi
  805bf4:	5d                   	pop    %ebp
  805bf5:	c3                   	ret    

00805bf6 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  805bf6:	55                   	push   %ebp
  805bf7:	89 e5                	mov    %esp,%ebp
  805bf9:	56                   	push   %esi
  805bfa:	53                   	push   %ebx
  805bfb:	83 ec 10             	sub    $0x10,%esp
  805bfe:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  805c01:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  805c05:	74 1c                	je     805c23 <tcp_listen_with_backlog+0x2d>
  805c07:	c7 44 24 08 b4 2c 81 	movl   $0x812cb4,0x8(%esp)
  805c0e:	00 
  805c0f:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  805c16:	00 
  805c17:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  805c1e:	e8 77 94 00 00       	call   80f09a <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  805c23:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  805c2a:	e8 e3 ed ff ff       	call   804a12 <memp_malloc>
  805c2f:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  805c31:	85 c0                	test   %eax,%eax
  805c33:	0f 84 af 00 00 00    	je     805ce8 <tcp_listen_with_backlog+0xf2>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  805c39:	8b 43 18             	mov    0x18(%ebx),%eax
  805c3c:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  805c3f:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  805c43:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  805c47:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  805c4e:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  805c52:	83 c8 02             	or     $0x2,%eax
  805c55:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  805c59:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  805c5d:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  805c60:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  805c64:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  805c67:	85 db                	test   %ebx,%ebx
  805c69:	74 04                	je     805c6f <tcp_listen_with_backlog+0x79>
  805c6b:	8b 03                	mov    (%ebx),%eax
  805c6d:	eb 05                	jmp    805c74 <tcp_listen_with_backlog+0x7e>
  805c6f:	b8 00 00 00 00       	mov    $0x0,%eax
  805c74:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  805c76:	a1 6c c2 b3 00       	mov    0xb3c26c,%eax
  805c7b:	39 d8                	cmp    %ebx,%eax
  805c7d:	75 0a                	jne    805c89 <tcp_listen_with_backlog+0x93>
  805c7f:	8b 40 0c             	mov    0xc(%eax),%eax
  805c82:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  805c87:	eb 2a                	jmp    805cb3 <tcp_listen_with_backlog+0xbd>
  805c89:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805c8e:	eb 1a                	jmp    805caa <tcp_listen_with_backlog+0xb4>
  805c90:	8b 50 0c             	mov    0xc(%eax),%edx
  805c93:	85 d2                	test   %edx,%edx
  805c95:	74 11                	je     805ca8 <tcp_listen_with_backlog+0xb2>
  805c97:	39 d3                	cmp    %edx,%ebx
  805c99:	75 0d                	jne    805ca8 <tcp_listen_with_backlog+0xb2>
  805c9b:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805ca0:	8b 53 0c             	mov    0xc(%ebx),%edx
  805ca3:	89 50 0c             	mov    %edx,0xc(%eax)
  805ca6:	eb 0b                	jmp    805cb3 <tcp_listen_with_backlog+0xbd>
  805ca8:	89 d0                	mov    %edx,%eax
  805caa:	85 c0                	test   %eax,%eax
  805cac:	75 e2                	jne    805c90 <tcp_listen_with_backlog+0x9a>
  805cae:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  805cb3:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  805cba:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805cbe:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  805cc5:	e8 a8 ed ff ff       	call   804a72 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  805cca:	c7 46 20 c0 59 80 00 	movl   $0x8059c0,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  805cd1:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  805cd6:	89 46 0c             	mov    %eax,0xc(%esi)
  805cd9:	89 35 64 c2 b3 00    	mov    %esi,0xb3c264
  805cdf:	e8 be c8 ff ff       	call   8025a2 <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  805ce4:	89 f0                	mov    %esi,%eax
  805ce6:	eb 05                	jmp    805ced <tcp_listen_with_backlog+0xf7>
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
    return NULL;
  805ce8:	b8 00 00 00 00       	mov    $0x0,%eax
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  return (struct tcp_pcb *)lpcb;
}
  805ced:	83 c4 10             	add    $0x10,%esp
  805cf0:	5b                   	pop    %ebx
  805cf1:	5e                   	pop    %esi
  805cf2:	5d                   	pop    %ebp
  805cf3:	c3                   	ret    

00805cf4 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  805cf4:	55                   	push   %ebp
  805cf5:	89 e5                	mov    %esp,%ebp
  805cf7:	56                   	push   %esi
  805cf8:	53                   	push   %ebx
  805cf9:	83 ec 10             	sub    $0x10,%esp
  805cfc:	8b 45 08             	mov    0x8(%ebp),%eax
  805cff:	8b 55 0c             	mov    0xc(%ebp),%edx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  805d02:	0f b7 48 28          	movzwl 0x28(%eax),%ecx
  805d06:	0f b7 f2             	movzwl %dx,%esi
  805d09:	0f b7 d9             	movzwl %cx,%ebx
  805d0c:	01 f3                	add    %esi,%ebx
  805d0e:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  805d14:	76 0e                	jbe    805d24 <tcp_recved+0x30>
    pcb->rcv_wnd = TCP_WND;
  805d16:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  805d1c:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  805d22:	eb 10                	jmp    805d34 <tcp_recved+0x40>
  } else {
    pcb->rcv_wnd += len;
  805d24:	01 ca                	add    %ecx,%edx
  805d26:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  805d2a:	66 3b 50 34          	cmp    0x34(%eax),%dx
  805d2e:	72 04                	jb     805d34 <tcp_recved+0x40>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  805d30:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  805d34:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  805d38:	f6 c2 03             	test   $0x3,%dl
  805d3b:	75 20                	jne    805d5d <tcp_recved+0x69>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  805d3d:	f6 c2 01             	test   $0x1,%dl
  805d40:	74 13                	je     805d55 <tcp_recved+0x61>
  805d42:	83 e2 fe             	and    $0xfffffffe,%edx
  805d45:	83 ca 02             	or     $0x2,%edx
  805d48:	88 50 20             	mov    %dl,0x20(%eax)
  805d4b:	89 04 24             	mov    %eax,(%esp)
  805d4e:	e8 3e 2a 00 00       	call   808791 <tcp_output>
  805d53:	eb 23                	jmp    805d78 <tcp_recved+0x84>
  805d55:	83 ca 01             	or     $0x1,%edx
  805d58:	88 50 20             	mov    %dl,0x20(%eax)
  805d5b:	eb 1b                	jmp    805d78 <tcp_recved+0x84>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  805d5d:	f6 c2 01             	test   $0x1,%dl
  805d60:	74 16                	je     805d78 <tcp_recved+0x84>
  805d62:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  805d68:	76 0e                	jbe    805d78 <tcp_recved+0x84>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  805d6a:	83 ca 02             	or     $0x2,%edx
  805d6d:	88 50 20             	mov    %dl,0x20(%eax)
  805d70:	89 04 24             	mov    %eax,(%esp)
  805d73:	e8 19 2a 00 00       	call   808791 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  805d78:	83 c4 10             	add    $0x10,%esp
  805d7b:	5b                   	pop    %ebx
  805d7c:	5e                   	pop    %esi
  805d7d:	5d                   	pop    %ebp
  805d7e:	c3                   	ret    

00805d7f <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  805d7f:	55                   	push   %ebp
  805d80:	89 e5                	mov    %esp,%ebp
  805d82:	53                   	push   %ebx
  805d83:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805d86:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  805d8c:	eb 61                	jmp    805def <tcp_fasttmr+0x70>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  805d8e:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805d94:	85 c0                	test   %eax,%eax
  805d96:	74 3a                	je     805dd2 <tcp_fasttmr+0x53>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805d98:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  805d9e:	85 d2                	test   %edx,%edx
  805da0:	74 1e                	je     805dc0 <tcp_fasttmr+0x41>
  805da2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805da9:	00 
  805daa:	89 44 24 08          	mov    %eax,0x8(%esp)
  805dae:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805db2:	8b 43 18             	mov    0x18(%ebx),%eax
  805db5:	89 04 24             	mov    %eax,(%esp)
  805db8:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  805dba:	84 c0                	test   %al,%al
  805dbc:	75 14                	jne    805dd2 <tcp_fasttmr+0x53>
  805dbe:	eb 08                	jmp    805dc8 <tcp_fasttmr+0x49>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  805dc0:	89 04 24             	mov    %eax,(%esp)
  805dc3:	e8 5c f0 ff ff       	call   804e24 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  805dc8:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805dcf:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  805dd2:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  805dd6:	a8 01                	test   $0x1,%al
  805dd8:	74 12                	je     805dec <tcp_fasttmr+0x6d>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  805dda:	83 c8 02             	or     $0x2,%eax
  805ddd:	88 43 20             	mov    %al,0x20(%ebx)
  805de0:	89 1c 24             	mov    %ebx,(%esp)
  805de3:	e8 a9 29 00 00       	call   808791 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  805de8:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  805dec:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  805def:	85 db                	test   %ebx,%ebx
  805df1:	75 9b                	jne    805d8e <tcp_fasttmr+0xf>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  805df3:	83 c4 14             	add    $0x14,%esp
  805df6:	5b                   	pop    %ebx
  805df7:	5d                   	pop    %ebp
  805df8:	c3                   	ret    

00805df9 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  805df9:	55                   	push   %ebp
  805dfa:	89 e5                	mov    %esp,%ebp
  805dfc:	56                   	push   %esi
  805dfd:	53                   	push   %ebx
  805dfe:	83 ec 10             	sub    $0x10,%esp
  805e01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u8_t count = 0;
  
  if (seg != NULL) {
  805e04:	85 db                	test   %ebx,%ebx
  805e06:	74 28                	je     805e30 <tcp_seg_free+0x37>
    if (seg->p != NULL) {
  805e08:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805e0b:	be 00 00 00 00       	mov    $0x0,%esi
  
  if (seg != NULL) {
    if (seg->p != NULL) {
  805e10:	85 c0                	test   %eax,%eax
  805e12:	74 0a                	je     805e1e <tcp_seg_free+0x25>
      count = pbuf_free(seg->p);
  805e14:	89 04 24             	mov    %eax,(%esp)
  805e17:	e8 08 f0 ff ff       	call   804e24 <pbuf_free>
  805e1c:	89 c6                	mov    %eax,%esi
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  805e1e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805e22:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805e29:	e8 44 ec ff ff       	call   804a72 <memp_free>
  805e2e:	eb 05                	jmp    805e35 <tcp_seg_free+0x3c>
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  805e30:	be 00 00 00 00       	mov    $0x0,%esi
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  }
  return count;
}
  805e35:	89 f0                	mov    %esi,%eax
  805e37:	83 c4 10             	add    $0x10,%esp
  805e3a:	5b                   	pop    %ebx
  805e3b:	5e                   	pop    %esi
  805e3c:	5d                   	pop    %ebp
  805e3d:	c3                   	ret    

00805e3e <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  805e3e:	55                   	push   %ebp
  805e3f:	89 e5                	mov    %esp,%ebp
  805e41:	56                   	push   %esi
  805e42:	53                   	push   %ebx
  805e43:	83 ec 10             	sub    $0x10,%esp
  805e46:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t count = 0;
  805e49:	bb 00 00 00 00       	mov    $0x0,%ebx
  struct tcp_seg *next;
  while (seg != NULL) {
  805e4e:	eb 0e                	jmp    805e5e <tcp_segs_free+0x20>
    next = seg->next;
  805e50:	8b 32                	mov    (%edx),%esi
    count += tcp_seg_free(seg);
  805e52:	89 14 24             	mov    %edx,(%esp)
  805e55:	e8 9f ff ff ff       	call   805df9 <tcp_seg_free>
  805e5a:	01 c3                	add    %eax,%ebx
    seg = next;
  805e5c:	89 f2                	mov    %esi,%edx
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  805e5e:	85 d2                	test   %edx,%edx
  805e60:	75 ee                	jne    805e50 <tcp_segs_free+0x12>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  805e62:	89 d8                	mov    %ebx,%eax
  805e64:	83 c4 10             	add    $0x10,%esp
  805e67:	5b                   	pop    %ebx
  805e68:	5e                   	pop    %esi
  805e69:	5d                   	pop    %ebp
  805e6a:	c3                   	ret    

00805e6b <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  805e6b:	55                   	push   %ebp
  805e6c:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  805e6e:	8b 45 0c             	mov    0xc(%ebp),%eax
  805e71:	8b 55 08             	mov    0x8(%ebp),%edx
  805e74:	88 42 14             	mov    %al,0x14(%edx)
}
  805e77:	5d                   	pop    %ebp
  805e78:	c3                   	ret    

00805e79 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  805e79:	55                   	push   %ebp
  805e7a:	89 e5                	mov    %esp,%ebp
  805e7c:	53                   	push   %ebx
  805e7d:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  805e80:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  805e87:	e8 86 eb ff ff       	call   804a12 <memp_malloc>
  805e8c:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  805e8e:	85 c0                	test   %eax,%eax
  805e90:	74 22                	je     805eb4 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  805e92:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  805e99:	00 
  805e9a:	8b 45 08             	mov    0x8(%ebp),%eax
  805e9d:	89 44 24 04          	mov    %eax,0x4(%esp)
  805ea1:	89 1c 24             	mov    %ebx,(%esp)
  805ea4:	e8 13 9b 00 00       	call   80f9bc <memcpy>
  pbuf_ref(cseg->p);
  805ea9:	8b 43 04             	mov    0x4(%ebx),%eax
  805eac:	89 04 24             	mov    %eax,(%esp)
  805eaf:	e8 1e f4 ff ff       	call   8052d2 <pbuf_ref>
  return cseg;
}
  805eb4:	89 d8                	mov    %ebx,%eax
  805eb6:	83 c4 14             	add    $0x14,%esp
  805eb9:	5b                   	pop    %ebx
  805eba:	5d                   	pop    %ebp
  805ebb:	c3                   	ret    

00805ebc <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  805ebc:	55                   	push   %ebp
  805ebd:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  805ebf:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ec2:	8b 45 08             	mov    0x8(%ebp),%eax
  805ec5:	89 50 18             	mov    %edx,0x18(%eax)
}
  805ec8:	5d                   	pop    %ebp
  805ec9:	c3                   	ret    

00805eca <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  805eca:	55                   	push   %ebp
  805ecb:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  805ecd:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ed0:	8b 45 08             	mov    0x8(%ebp),%eax
  805ed3:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  805ed9:	5d                   	pop    %ebp
  805eda:	c3                   	ret    

00805edb <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  805edb:	55                   	push   %ebp
  805edc:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  805ede:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ee1:	8b 45 08             	mov    0x8(%ebp),%eax
  805ee4:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  805eea:	5d                   	pop    %ebp
  805eeb:	c3                   	ret    

00805eec <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  805eec:	55                   	push   %ebp
  805eed:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  805eef:	8b 55 0c             	mov    0xc(%ebp),%edx
  805ef2:	8b 45 08             	mov    0x8(%ebp),%eax
  805ef5:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  805efb:	5d                   	pop    %ebp
  805efc:	c3                   	ret    

00805efd <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  805efd:	55                   	push   %ebp
  805efe:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  805f00:	8b 55 0c             	mov    0xc(%ebp),%edx
  805f03:	8b 45 08             	mov    0x8(%ebp),%eax
  805f06:	89 50 20             	mov    %edx,0x20(%eax)
}
  805f09:	5d                   	pop    %ebp
  805f0a:	c3                   	ret    

00805f0b <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  805f0b:	55                   	push   %ebp
  805f0c:	89 e5                	mov    %esp,%ebp
  805f0e:	8b 45 08             	mov    0x8(%ebp),%eax
  805f11:	8b 55 10             	mov    0x10(%ebp),%edx
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  805f14:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  805f17:	89 88 94 00 00 00    	mov    %ecx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  805f1d:	88 50 31             	mov    %dl,0x31(%eax)
}
  805f20:	5d                   	pop    %ebp
  805f21:	c3                   	ret    

00805f22 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  805f22:	55                   	push   %ebp
  805f23:	89 e5                	mov    %esp,%ebp
  805f25:	53                   	push   %ebx
  805f26:	83 ec 14             	sub    $0x14,%esp
  805f29:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  805f2c:	8b 43 10             	mov    0x10(%ebx),%eax
  805f2f:	83 f8 01             	cmp    $0x1,%eax
  805f32:	76 5d                	jbe    805f91 <tcp_pcb_purge+0x6f>
  805f34:	83 f8 0a             	cmp    $0xa,%eax
  805f37:	74 58                	je     805f91 <tcp_pcb_purge+0x6f>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  805f39:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  805f3f:	85 c0                	test   %eax,%eax
  805f41:	74 12                	je     805f55 <tcp_pcb_purge+0x33>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  805f43:	89 04 24             	mov    %eax,(%esp)
  805f46:	e8 d9 ee ff ff       	call   804e24 <pbuf_free>
      pcb->refused_data = NULL;
  805f4b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  805f52:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  805f55:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  805f5b:	8b 43 7c             	mov    0x7c(%ebx),%eax
  805f5e:	89 04 24             	mov    %eax,(%esp)
  805f61:	e8 d8 fe ff ff       	call   805e3e <tcp_segs_free>
    pcb->ooseq = NULL;
  805f66:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  805f6d:	8b 43 74             	mov    0x74(%ebx),%eax
  805f70:	89 04 24             	mov    %eax,(%esp)
  805f73:	e8 c6 fe ff ff       	call   805e3e <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  805f78:	8b 43 78             	mov    0x78(%ebx),%eax
  805f7b:	89 04 24             	mov    %eax,(%esp)
  805f7e:	e8 bb fe ff ff       	call   805e3e <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  805f83:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  805f8a:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  805f91:	83 c4 14             	add    $0x14,%esp
  805f94:	5b                   	pop    %ebx
  805f95:	5d                   	pop    %ebp
  805f96:	c3                   	ret    

00805f97 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  805f97:	55                   	push   %ebp
  805f98:	89 e5                	mov    %esp,%ebp
  805f9a:	53                   	push   %ebx
  805f9b:	83 ec 14             	sub    $0x14,%esp
  805f9e:	8b 45 08             	mov    0x8(%ebp),%eax
  805fa1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  805fa4:	8b 10                	mov    (%eax),%edx
  805fa6:	39 da                	cmp    %ebx,%edx
  805fa8:	75 07                	jne    805fb1 <tcp_pcb_remove+0x1a>
  805faa:	8b 52 0c             	mov    0xc(%edx),%edx
  805fad:	89 10                	mov    %edx,(%eax)
  805faf:	eb 2d                	jmp    805fde <tcp_pcb_remove+0x47>
  805fb1:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805fb7:	eb 1b                	jmp    805fd4 <tcp_pcb_remove+0x3d>
  805fb9:	8b 42 0c             	mov    0xc(%edx),%eax
  805fbc:	85 c0                	test   %eax,%eax
  805fbe:	74 12                	je     805fd2 <tcp_pcb_remove+0x3b>
  805fc0:	39 c3                	cmp    %eax,%ebx
  805fc2:	75 0e                	jne    805fd2 <tcp_pcb_remove+0x3b>
  805fc4:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805fca:	8b 43 0c             	mov    0xc(%ebx),%eax
  805fcd:	89 42 0c             	mov    %eax,0xc(%edx)
  805fd0:	eb 0c                	jmp    805fde <tcp_pcb_remove+0x47>
  805fd2:	89 c2                	mov    %eax,%edx
  805fd4:	85 d2                	test   %edx,%edx
  805fd6:	75 e1                	jne    805fb9 <tcp_pcb_remove+0x22>
  805fd8:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  805fde:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  805fe5:	89 1c 24             	mov    %ebx,(%esp)
  805fe8:	e8 35 ff ff ff       	call   805f22 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  805fed:	8b 43 10             	mov    0x10(%ebx),%eax
  805ff0:	83 f8 01             	cmp    $0x1,%eax
  805ff3:	74 1b                	je     806010 <tcp_pcb_remove+0x79>
  805ff5:	83 f8 0a             	cmp    $0xa,%eax
  805ff8:	74 16                	je     806010 <tcp_pcb_remove+0x79>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  805ffa:	0f b6 43 20          	movzbl 0x20(%ebx),%eax

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  805ffe:	a8 01                	test   $0x1,%al
  806000:	74 0e                	je     806010 <tcp_pcb_remove+0x79>
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  806002:	83 c8 02             	or     $0x2,%eax
  806005:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  806008:	89 1c 24             	mov    %ebx,(%esp)
  80600b:	e8 81 27 00 00       	call   808791 <tcp_output>
  }

  if (pcb->state != LISTEN) {
  806010:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  806014:	74 66                	je     80607c <tcp_pcb_remove+0xe5>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  806016:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80601a:	74 1c                	je     806038 <tcp_pcb_remove+0xa1>
  80601c:	c7 44 24 08 7e 2e 81 	movl   $0x812e7e,0x8(%esp)
  806023:	00 
  806024:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  80602b:	00 
  80602c:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  806033:	e8 62 90 00 00       	call   80f09a <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  806038:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80603c:	74 1c                	je     80605a <tcp_pcb_remove+0xc3>
  80603e:	c7 44 24 08 96 2e 81 	movl   $0x812e96,0x8(%esp)
  806045:	00 
  806046:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  80604d:	00 
  80604e:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  806055:	e8 40 90 00 00       	call   80f09a <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  80605a:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  80605e:	74 1c                	je     80607c <tcp_pcb_remove+0xe5>
  806060:	c7 44 24 08 af 2e 81 	movl   $0x812eaf,0x8(%esp)
  806067:	00 
  806068:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  80606f:	00 
  806070:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  806077:	e8 1e 90 00 00       	call   80f09a <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80607c:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  806083:	83 c4 14             	add    $0x14,%esp
  806086:	5b                   	pop    %ebx
  806087:	5d                   	pop    %ebp
  806088:	c3                   	ret    

00806089 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  806089:	55                   	push   %ebp
  80608a:	89 e5                	mov    %esp,%ebp
  80608c:	53                   	push   %ebx
  80608d:	83 ec 14             	sub    $0x14,%esp
  806090:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  806093:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  806097:	0f 87 14 01 00 00    	ja     8061b1 <tcp_close+0x128>
  80609d:	8b 43 10             	mov    0x10(%ebx),%eax
  8060a0:	ff 24 85 c8 2e 81 00 	jmp    *0x812ec8(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8060a7:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  8060ad:	39 da                	cmp    %ebx,%edx
  8060af:	75 0a                	jne    8060bb <tcp_close+0x32>
  8060b1:	8b 42 0c             	mov    0xc(%edx),%eax
  8060b4:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  8060b9:	eb 2d                	jmp    8060e8 <tcp_close+0x5f>
  8060bb:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8060c1:	eb 1b                	jmp    8060de <tcp_close+0x55>
  8060c3:	8b 42 0c             	mov    0xc(%edx),%eax
  8060c6:	85 c0                	test   %eax,%eax
  8060c8:	74 12                	je     8060dc <tcp_close+0x53>
  8060ca:	39 c3                	cmp    %eax,%ebx
  8060cc:	75 0e                	jne    8060dc <tcp_close+0x53>
  8060ce:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8060d4:	8b 43 0c             	mov    0xc(%ebx),%eax
  8060d7:	89 42 0c             	mov    %eax,0xc(%edx)
  8060da:	eb 0c                	jmp    8060e8 <tcp_close+0x5f>
  8060dc:	89 c2                	mov    %eax,%edx
  8060de:	85 d2                	test   %edx,%edx
  8060e0:	75 e1                	jne    8060c3 <tcp_close+0x3a>
  8060e2:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  8060e8:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  8060ef:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8060f3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8060fa:	e8 73 e9 ff ff       	call   804a72 <memp_free>
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  8060ff:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  806104:	e9 c5 00 00 00       	jmp    8061ce <tcp_close+0x145>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  806109:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80610d:	c7 04 24 64 c2 b3 00 	movl   $0xb3c264,(%esp)
  806114:	e8 7e fe ff ff       	call   805f97 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  806119:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80611d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  806124:	e8 49 e9 ff ff       	call   804a72 <memp_free>
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  806129:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  80612e:	e9 9b 00 00 00       	jmp    8061ce <tcp_close+0x145>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806133:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806137:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80613e:	e8 54 fe ff ff       	call   805f97 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  806143:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806147:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80614e:	e8 1f e9 ff ff       	call   804a72 <memp_free>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  806153:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  806158:	eb 74                	jmp    8061ce <tcp_close+0x145>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80615a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  806161:	00 
  806162:	89 1c 24             	mov    %ebx,(%esp)
  806165:	e8 78 25 00 00       	call   8086e2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80616a:	84 c0                	test   %al,%al
  80616c:	75 60                	jne    8061ce <tcp_close+0x145>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80616e:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806175:	eb 3f                	jmp    8061b6 <tcp_close+0x12d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806177:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80617e:	00 
  80617f:	89 1c 24             	mov    %ebx,(%esp)
  806182:	e8 5b 25 00 00       	call   8086e2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  806187:	84 c0                	test   %al,%al
  806189:	75 43                	jne    8061ce <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80618b:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  806192:	eb 22                	jmp    8061b6 <tcp_close+0x12d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  806194:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80619b:	00 
  80619c:	89 1c 24             	mov    %ebx,(%esp)
  80619f:	e8 3e 25 00 00       	call   8086e2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8061a4:	84 c0                	test   %al,%al
  8061a6:	75 26                	jne    8061ce <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  8061a8:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  8061af:	eb 05                	jmp    8061b6 <tcp_close+0x12d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  8061b1:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  8061b6:	85 db                	test   %ebx,%ebx
  8061b8:	74 0f                	je     8061c9 <tcp_close+0x140>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  8061ba:	89 1c 24             	mov    %ebx,(%esp)
  8061bd:	e8 cf 25 00 00       	call   808791 <tcp_output>
  8061c2:	b8 00 00 00 00       	mov    $0x0,%eax
  8061c7:	eb 05                	jmp    8061ce <tcp_close+0x145>
  8061c9:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  8061ce:	83 c4 14             	add    $0x14,%esp
  8061d1:	5b                   	pop    %ebx
  8061d2:	5d                   	pop    %ebp
  8061d3:	c3                   	ret    

008061d4 <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  8061d4:	55                   	push   %ebp
  8061d5:	89 e5                	mov    %esp,%ebp
  8061d7:	83 ec 18             	sub    $0x18,%esp
  8061da:	8b 45 10             	mov    0x10(%ebp),%eax
  8061dd:	8b 55 14             	mov    0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  8061e0:	85 c0                	test   %eax,%eax
  8061e2:	74 0f                	je     8061f3 <tcp_recv_null+0x1f>
    pbuf_free(p);
  8061e4:	89 04 24             	mov    %eax,(%esp)
  8061e7:	e8 38 ec ff ff       	call   804e24 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  8061ec:	b8 00 00 00 00       	mov    $0x0,%eax
  8061f1:	eb 14                	jmp    806207 <tcp_recv_null+0x33>
  8061f3:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  8061f8:	84 d2                	test   %dl,%dl
  8061fa:	75 0b                	jne    806207 <tcp_recv_null+0x33>
    return tcp_close(pcb);
  8061fc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8061ff:	89 04 24             	mov    %eax,(%esp)
  806202:	e8 82 fe ff ff       	call   806089 <tcp_close>
  }
  return ERR_OK;
}
  806207:	c9                   	leave  
  806208:	c3                   	ret    

00806209 <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  806209:	55                   	push   %ebp
  80620a:	89 e5                	mov    %esp,%ebp
  80620c:	57                   	push   %edi
  80620d:	56                   	push   %esi
  80620e:	53                   	push   %ebx
  80620f:	83 ec 4c             	sub    $0x4c,%esp
  806212:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  806215:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  806219:	75 25                	jne    806240 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80621b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80621f:	c7 04 24 70 c2 b3 00 	movl   $0xb3c270,(%esp)
  806226:	e8 6c fd ff ff       	call   805f97 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  80622b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80622f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806236:	e8 37 e8 ff ff       	call   804a72 <memp_free>
  80623b:	e9 d5 00 00 00       	jmp    806315 <tcp_abort+0x10c>
  } else {
    seqno = pcb->snd_nxt;
  806240:	8b 43 54             	mov    0x54(%ebx),%eax
  806243:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  806246:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  806249:	85 db                	test   %ebx,%ebx
  80624b:	74 04                	je     806251 <tcp_abort+0x48>
  80624d:	8b 03                	mov    (%ebx),%eax
  80624f:	eb 05                	jmp    806256 <tcp_abort+0x4d>
  806251:	b8 00 00 00 00       	mov    $0x0,%eax
  806256:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  806259:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80625c:	74 05                	je     806263 <tcp_abort+0x5a>
  80625e:	8b 43 04             	mov    0x4(%ebx),%eax
  806261:	eb 05                	jmp    806268 <tcp_abort+0x5f>
  806263:	b8 00 00 00 00       	mov    $0x0,%eax
  806268:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  80626b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80626f:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  806273:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  806277:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80627b:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  806281:	8b 43 18             	mov    0x18(%ebx),%eax
  806284:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  806287:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80628b:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  806292:	e8 00 fd ff ff       	call   805f97 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  806297:	8b 43 78             	mov    0x78(%ebx),%eax
  80629a:	85 c0                	test   %eax,%eax
  80629c:	74 08                	je     8062a6 <tcp_abort+0x9d>
      tcp_segs_free(pcb->unacked);
  80629e:	89 04 24             	mov    %eax,(%esp)
  8062a1:	e8 98 fb ff ff       	call   805e3e <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  8062a6:	8b 43 74             	mov    0x74(%ebx),%eax
  8062a9:	85 c0                	test   %eax,%eax
  8062ab:	74 08                	je     8062b5 <tcp_abort+0xac>
      tcp_segs_free(pcb->unsent);
  8062ad:	89 04 24             	mov    %eax,(%esp)
  8062b0:	e8 89 fb ff ff       	call   805e3e <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  8062b5:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8062b8:	85 c0                	test   %eax,%eax
  8062ba:	74 08                	je     8062c4 <tcp_abort+0xbb>
      tcp_segs_free(pcb->ooseq);
  8062bc:	89 04 24             	mov    %eax,(%esp)
  8062bf:	e8 7a fb ff ff       	call   805e3e <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  8062c4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8062c8:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8062cf:	e8 9e e7 ff ff       	call   804a72 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  8062d4:	85 f6                	test   %esi,%esi
  8062d6:	74 10                	je     8062e8 <tcp_abort+0xdf>
  8062d8:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  8062df:	ff 
  8062e0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  8062e3:	89 04 24             	mov    %eax,(%esp)
  8062e6:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  8062e8:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  8062ec:	89 44 24 14          	mov    %eax,0x14(%esp)
  8062f0:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  8062f4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8062f8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8062fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8062ff:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806302:	89 44 24 08          	mov    %eax,0x8(%esp)
  806306:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80630a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80630d:	89 04 24             	mov    %eax,(%esp)
  806310:	e8 10 29 00 00       	call   808c25 <tcp_rst>
  }
}
  806315:	83 c4 4c             	add    $0x4c,%esp
  806318:	5b                   	pop    %ebx
  806319:	5e                   	pop    %esi
  80631a:	5f                   	pop    %edi
  80631b:	5d                   	pop    %ebp
  80631c:	c3                   	ret    

0080631d <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80631d:	55                   	push   %ebp
  80631e:	89 e5                	mov    %esp,%ebp
  806320:	57                   	push   %edi
  806321:	56                   	push   %esi
  806322:	53                   	push   %ebx
  806323:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  806326:	83 05 60 c2 b3 00 01 	addl   $0x1,0xb3c260

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  80632d:	8b 1d 5c c2 b3 00    	mov    0xb3c25c,%ebx
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  806333:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  806337:	bf 00 00 00 00       	mov    $0x0,%edi
  80633c:	e9 3a 03 00 00       	jmp    80667b <tcp_slowtmr+0x35e>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  806341:	8b 43 10             	mov    0x10(%ebx),%eax
  806344:	85 c0                	test   %eax,%eax
  806346:	75 1c                	jne    806364 <tcp_slowtmr+0x47>
  806348:	c7 44 24 08 d8 2c 81 	movl   $0x812cd8,0x8(%esp)
  80634f:	00 
  806350:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  806357:	00 
  806358:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  80635f:	e8 36 8d 00 00       	call   80f09a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  806364:	83 f8 01             	cmp    $0x1,%eax
  806367:	75 1c                	jne    806385 <tcp_slowtmr+0x68>
  806369:	c7 44 24 08 04 2d 81 	movl   $0x812d04,0x8(%esp)
  806370:	00 
  806371:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  806378:	00 
  806379:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  806380:	e8 15 8d 00 00       	call   80f09a <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  806385:	83 f8 0a             	cmp    $0xa,%eax
  806388:	75 1c                	jne    8063a6 <tcp_slowtmr+0x89>
  80638a:	c7 44 24 08 30 2d 81 	movl   $0x812d30,0x8(%esp)
  806391:	00 
  806392:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  806399:	00 
  80639a:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  8063a1:	e8 f4 8c 00 00       	call   80f09a <_panic>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8063a6:	83 f8 02             	cmp    $0x2,%eax
  8063a9:	75 0f                	jne    8063ba <tcp_slowtmr+0x9d>
      ++pcb_remove;
  8063ab:	be 01 00 00 00       	mov    $0x1,%esi
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8063b0:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  8063b4:	0f 84 16 01 00 00    	je     8064d0 <tcp_slowtmr+0x1b3>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  8063ba:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  8063be:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  8063c3:	80 fa 0c             	cmp    $0xc,%dl
  8063c6:	0f 84 e9 00 00 00    	je     8064b5 <tcp_slowtmr+0x198>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  8063cc:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  8063d3:	84 c9                	test   %cl,%cl
  8063d5:	74 50                	je     806427 <tcp_slowtmr+0x10a>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  8063d7:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  8063dd:	83 c0 01             	add    $0x1,%eax
  8063e0:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8063e6:	0f b6 d1             	movzbl %cl,%edx
  8063e9:	0f b6 92 e7 2e 81 00 	movzbl 0x812ee7(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8063f0:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  8063f5:	39 d0                	cmp    %edx,%eax
  8063f7:	0f 82 b8 00 00 00    	jb     8064b5 <tcp_slowtmr+0x198>
          pcb->persist_cnt = 0;
  8063fd:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  806404:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  806407:	80 f9 06             	cmp    $0x6,%cl
  80640a:	77 09                	ja     806415 <tcp_slowtmr+0xf8>
            pcb->persist_backoff++;
  80640c:	83 c1 01             	add    $0x1,%ecx
  80640f:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  806415:	89 1c 24             	mov    %ebx,(%esp)
  806418:	e8 58 2b 00 00       	call   808f75 <tcp_zero_window_probe>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80641d:	be 00 00 00 00       	mov    $0x0,%esi
  806422:	e9 8e 00 00 00       	jmp    8064b5 <tcp_slowtmr+0x198>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  806427:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  80642b:	66 85 c9             	test   %cx,%cx
  80642e:	78 07                	js     806437 <tcp_slowtmr+0x11a>
          ++pcb->rtime;
  806430:	83 c1 01             	add    $0x1,%ecx
  806433:	66 89 4b 32          	mov    %cx,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  806437:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80643b:	74 73                	je     8064b0 <tcp_slowtmr+0x193>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80643d:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  806442:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  806446:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  80644a:	7c 69                	jl     8064b5 <tcp_slowtmr+0x198>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80644c:	83 f8 02             	cmp    $0x2,%eax
  80644f:	74 1f                	je     806470 <tcp_slowtmr+0x153>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  806451:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  806455:	66 c1 f8 03          	sar    $0x3,%ax
  806459:	98                   	cwtl   
  80645a:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  80645e:	01 c8                	add    %ecx,%eax
  806460:	0f b6 d2             	movzbl %dl,%edx
  806463:	0f b6 8a ef 2e 81 00 	movzbl 0x812eef(%edx),%ecx
  80646a:	d3 e0                	shl    %cl,%eax
  80646c:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  806470:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
  806476:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  80647a:	66 39 43 4e          	cmp    %ax,0x4e(%ebx)
  80647e:	66 0f 46 43 4e       	cmovbe 0x4e(%ebx),%ax
          pcb->ssthresh = eff_wnd >> 1;
  806483:	66 d1 e8             	shr    %ax
  806486:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  80648a:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80648e:	66 39 d0             	cmp    %dx,%ax
  806491:	73 06                	jae    806499 <tcp_slowtmr+0x17c>
            pcb->ssthresh = pcb->mss * 2;
  806493:	01 d2                	add    %edx,%edx
  806495:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  806499:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80649d:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  8064a1:	89 1c 24             	mov    %ebx,(%esp)
  8064a4:	e8 d6 28 00 00       	call   808d7f <tcp_rexmit_rto>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  8064a9:	be 00 00 00 00       	mov    $0x0,%esi
  8064ae:	eb 05                	jmp    8064b5 <tcp_slowtmr+0x198>
  8064b0:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  8064b5:	8b 43 10             	mov    0x10(%ebx),%eax
  8064b8:	83 f8 06             	cmp    $0x6,%eax
  8064bb:	75 13                	jne    8064d0 <tcp_slowtmr+0x1b3>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8064bd:	8b 15 60 c2 b3 00    	mov    0xb3c260,%edx
  8064c3:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8064c6:	83 fa 29             	cmp    $0x29,%edx
  8064c9:	89 f1                	mov    %esi,%ecx
  8064cb:	80 d9 ff             	sbb    $0xff,%cl
  8064ce:	89 ce                	mov    %ecx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  8064d0:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  8064d4:	74 67                	je     80653d <tcp_slowtmr+0x220>
  8064d6:	83 f8 07             	cmp    $0x7,%eax
  8064d9:	74 05                	je     8064e0 <tcp_slowtmr+0x1c3>
  8064db:	83 f8 04             	cmp    $0x4,%eax
  8064de:	75 5d                	jne    80653d <tcp_slowtmr+0x220>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  8064e0:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8064e5:	2b 43 2c             	sub    0x2c(%ebx),%eax
  8064e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  8064eb:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  8064f1:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  8064f7:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  8064fc:	f7 e2                	mul    %edx
  8064fe:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  806501:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  806504:	76 0a                	jbe    806510 <tcp_slowtmr+0x1f3>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  806506:	89 1c 24             	mov    %ebx,(%esp)
  806509:	e8 fb fc ff ff       	call   806209 <tcp_abort>
  80650e:	eb 2d                	jmp    80653d <tcp_slowtmr+0x220>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  806510:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  806517:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  80651d:	01 d1                	add    %edx,%ecx
              / TCP_SLOW_INTERVAL)
  80651f:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  806524:	f7 e1                	mul    %ecx
  806526:	c1 ea 05             	shr    $0x5,%edx
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  806529:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80652c:	76 0f                	jbe    80653d <tcp_slowtmr+0x220>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80652e:	89 1c 24             	mov    %ebx,(%esp)
  806531:	e8 eb 28 00 00       	call   808e21 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  806536:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80653d:	8b 53 7c             	mov    0x7c(%ebx),%edx
  806540:	85 d2                	test   %edx,%edx
  806542:	74 25                	je     806569 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  806544:	8b 0d 60 c2 b3 00    	mov    0xb3c260,%ecx
  80654a:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  80654d:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  806551:	8d 04 40             	lea    (%eax,%eax,2),%eax
  806554:	01 c0                	add    %eax,%eax

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  806556:	39 c1                	cmp    %eax,%ecx
  806558:	72 0f                	jb     806569 <tcp_slowtmr+0x24c>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80655a:	89 14 24             	mov    %edx,(%esp)
  80655d:	e8 dc f8 ff ff       	call   805e3e <tcp_segs_free>
      pcb->ooseq = NULL;
  806562:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  806569:	8b 43 10             	mov    0x10(%ebx),%eax
  80656c:	83 f8 03             	cmp    $0x3,%eax
  80656f:	75 13                	jne    806584 <tcp_slowtmr+0x267>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  806571:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  806576:	2b 43 2c             	sub    0x2c(%ebx),%eax
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  806579:	83 f8 29             	cmp    $0x29,%eax
  80657c:	89 f0                	mov    %esi,%eax
  80657e:	1c ff                	sbb    $0xff,%al
  806580:	89 c6                	mov    %eax,%esi
  806582:	eb 18                	jmp    80659c <tcp_slowtmr+0x27f>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  806584:	83 f8 09             	cmp    $0x9,%eax
  806587:	75 13                	jne    80659c <tcp_slowtmr+0x27f>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  806589:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  80658e:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  806591:	3d f1 00 00 00       	cmp    $0xf1,%eax
  806596:	89 f0                	mov    %esi,%eax
  806598:	1c ff                	sbb    $0xff,%al
  80659a:	89 c6                	mov    %eax,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80659c:	89 f0                	mov    %esi,%eax
  80659e:	84 c0                	test   %al,%al
  8065a0:	0f 84 96 00 00 00    	je     80663c <tcp_slowtmr+0x31f>
      tcp_pcb_purge(pcb);      
  8065a6:	89 1c 24             	mov    %ebx,(%esp)
  8065a9:	e8 74 f9 ff ff       	call   805f22 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  8065ae:	85 ff                	test   %edi,%edi
  8065b0:	74 2c                	je     8065de <tcp_slowtmr+0x2c1>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8065b2:	3b 1d 5c c2 b3 00    	cmp    0xb3c25c,%ebx
  8065b8:	75 1c                	jne    8065d6 <tcp_slowtmr+0x2b9>
  8065ba:	c7 44 24 08 60 2d 81 	movl   $0x812d60,0x8(%esp)
  8065c1:	00 
  8065c2:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  8065c9:	00 
  8065ca:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  8065d1:	e8 c4 8a 00 00       	call   80f09a <_panic>
        prev->next = pcb->next;
  8065d6:	8b 43 0c             	mov    0xc(%ebx),%eax
  8065d9:	89 47 0c             	mov    %eax,0xc(%edi)
  8065dc:	eb 2d                	jmp    80660b <tcp_slowtmr+0x2ee>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  8065de:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  8065e3:	39 d8                	cmp    %ebx,%eax
  8065e5:	74 1c                	je     806603 <tcp_slowtmr+0x2e6>
  8065e7:	c7 44 24 08 8c 2d 81 	movl   $0x812d8c,0x8(%esp)
  8065ee:	00 
  8065ef:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  8065f6:	00 
  8065f7:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  8065fe:	e8 97 8a 00 00       	call   80f09a <_panic>
        tcp_active_pcbs = pcb->next;
  806603:	8b 40 0c             	mov    0xc(%eax),%eax
  806606:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80660b:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  806611:	85 c0                	test   %eax,%eax
  806613:	74 10                	je     806625 <tcp_slowtmr+0x308>
  806615:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  80661c:	ff 
  80661d:	8b 53 18             	mov    0x18(%ebx),%edx
  806620:	89 14 24             	mov    %edx,(%esp)
  806623:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  806625:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  806628:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80662c:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806633:	e8 3a e4 ff ff       	call   804a72 <memp_free>
      pcb = pcb2;
  806638:	89 f3                	mov    %esi,%ebx
  80663a:	eb 3f                	jmp    80667b <tcp_slowtmr+0x35e>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80663c:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  806640:	83 c0 01             	add    $0x1,%eax
  806643:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  806646:	3a 43 31             	cmp    0x31(%ebx),%al
  806649:	72 2b                	jb     806676 <tcp_slowtmr+0x359>
        pcb->polltmr = 0;
  80664b:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80664f:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  806655:	85 c0                	test   %eax,%eax
  806657:	74 0f                	je     806668 <tcp_slowtmr+0x34b>
  806659:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80665d:	8b 53 18             	mov    0x18(%ebx),%edx
  806660:	89 14 24             	mov    %edx,(%esp)
  806663:	ff d0                	call   *%eax
  806665:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  806668:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80666c:	75 08                	jne    806676 <tcp_slowtmr+0x359>
          tcp_output(pcb);
  80666e:	89 1c 24             	mov    %ebx,(%esp)
  806671:	e8 1b 21 00 00       	call   808791 <tcp_output>
        }
      }
      
      prev = pcb;
  806676:	89 df                	mov    %ebx,%edi
      pcb = pcb->next;
  806678:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80667b:	85 db                	test   %ebx,%ebx
  80667d:	0f 85 be fc ff ff    	jne    806341 <tcp_slowtmr+0x24>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  806683:	8b 35 70 c2 b3 00    	mov    0xb3c270,%esi
  while (pcb != NULL) {
  806689:	e9 b2 00 00 00       	jmp    806740 <tcp_slowtmr+0x423>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80668e:	83 7e 10 0a          	cmpl   $0xa,0x10(%esi)
  806692:	74 1c                	je     8066b0 <tcp_slowtmr+0x393>
  806694:	c7 44 24 08 b8 2d 81 	movl   $0x812db8,0x8(%esp)
  80669b:	00 
  80669c:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  8066a3:	00 
  8066a4:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  8066ab:	e8 ea 89 00 00       	call   80f09a <_panic>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8066b0:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8066b5:	2b 46 2c             	sub    0x2c(%esi),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8066b8:	3d f0 00 00 00       	cmp    $0xf0,%eax
  8066bd:	76 7c                	jbe    80673b <tcp_slowtmr+0x41e>
      tcp_pcb_purge(pcb);      
  8066bf:	89 34 24             	mov    %esi,(%esp)
  8066c2:	e8 5b f8 ff ff       	call   805f22 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  8066c7:	85 db                	test   %ebx,%ebx
  8066c9:	74 2c                	je     8066f7 <tcp_slowtmr+0x3da>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  8066cb:	3b 35 70 c2 b3 00    	cmp    0xb3c270,%esi
  8066d1:	75 1c                	jne    8066ef <tcp_slowtmr+0x3d2>
  8066d3:	c7 44 24 08 e8 2d 81 	movl   $0x812de8,0x8(%esp)
  8066da:	00 
  8066db:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  8066e2:	00 
  8066e3:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  8066ea:	e8 ab 89 00 00       	call   80f09a <_panic>
        prev->next = pcb->next;
  8066ef:	8b 46 0c             	mov    0xc(%esi),%eax
  8066f2:	89 43 0c             	mov    %eax,0xc(%ebx)
  8066f5:	eb 2d                	jmp    806724 <tcp_slowtmr+0x407>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  8066f7:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  8066fc:	39 f0                	cmp    %esi,%eax
  8066fe:	74 1c                	je     80671c <tcp_slowtmr+0x3ff>
  806700:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  806707:	00 
  806708:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  80670f:	00 
  806710:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  806717:	e8 7e 89 00 00       	call   80f09a <_panic>
        tcp_tw_pcbs = pcb->next;
  80671c:	8b 40 0c             	mov    0xc(%eax),%eax
  80671f:	a3 70 c2 b3 00       	mov    %eax,0xb3c270
      }
      pcb2 = pcb->next;
  806724:	8b 7e 0c             	mov    0xc(%esi),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  806727:	89 74 24 04          	mov    %esi,0x4(%esp)
  80672b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806732:	e8 3b e3 ff ff       	call   804a72 <memp_free>
      pcb = pcb2;
  806737:	89 fe                	mov    %edi,%esi
  806739:	eb 05                	jmp    806740 <tcp_slowtmr+0x423>
    } else {
      prev = pcb;
  80673b:	89 f3                	mov    %esi,%ebx
      pcb = pcb->next;
  80673d:	8b 76 0c             	mov    0xc(%esi),%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  806740:	85 f6                	test   %esi,%esi
  806742:	0f 85 46 ff ff ff    	jne    80668e <tcp_slowtmr+0x371>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  806748:	83 c4 2c             	add    $0x2c,%esp
  80674b:	5b                   	pop    %ebx
  80674c:	5e                   	pop    %esi
  80674d:	5f                   	pop    %edi
  80674e:	5d                   	pop    %ebp
  80674f:	c3                   	ret    

00806750 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  806750:	55                   	push   %ebp
  806751:	89 e5                	mov    %esp,%ebp
  806753:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  806756:	e8 24 f6 ff ff       	call   805d7f <tcp_fasttmr>

  if (++tcp_timer & 1) {
  80675b:	0f b6 05 19 54 b3 00 	movzbl 0xb35419,%eax
  806762:	83 c0 01             	add    $0x1,%eax
  806765:	a2 19 54 b3 00       	mov    %al,0xb35419
  80676a:	a8 01                	test   $0x1,%al
  80676c:	74 05                	je     806773 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80676e:	e8 aa fb ff ff       	call   80631d <tcp_slowtmr>
  }
}
  806773:	c9                   	leave  
  806774:	c3                   	ret    

00806775 <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  806775:	55                   	push   %ebp
  806776:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  806778:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  80677d:	03 05 08 50 81 00    	add    0x815008,%eax
  806783:	a3 08 50 81 00       	mov    %eax,0x815008
  return iss;
}
  806788:	5d                   	pop    %ebp
  806789:	c3                   	ret    

0080678a <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80678a:	55                   	push   %ebp
  80678b:	89 e5                	mov    %esp,%ebp
  80678d:	57                   	push   %edi
  80678e:	56                   	push   %esi
  80678f:	53                   	push   %ebx
  806790:	83 ec 2c             	sub    $0x2c,%esp
  806793:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  806797:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80679e:	e8 6f e2 ff ff       	call   804a12 <memp_malloc>
  8067a3:	89 c6                	mov    %eax,%esi
  if (pcb == NULL) {
  8067a5:	85 c0                	test   %eax,%eax
  8067a7:	0f 85 b3 00 00 00    	jne    806860 <tcp_alloc+0xd6>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8067ad:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067b2:	8b 35 60 c2 b3 00    	mov    0xb3c260,%esi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  8067b8:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  8067bd:	bf 00 00 00 00       	mov    $0x0,%edi
  8067c2:	eb 10                	jmp    8067d4 <tcp_alloc+0x4a>
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067c4:	89 f2                	mov    %esi,%edx
  8067c6:	2b 50 2c             	sub    0x2c(%eax),%edx
  8067c9:	39 ca                	cmp    %ecx,%edx
  8067cb:	72 04                	jb     8067d1 <tcp_alloc+0x47>
      inactivity = tcp_ticks - pcb->tmr;
  8067cd:	89 d1                	mov    %edx,%ecx
      inactive = pcb;
  8067cf:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8067d1:	8b 40 0c             	mov    0xc(%eax),%eax
  8067d4:	85 c0                	test   %eax,%eax
  8067d6:	75 ec                	jne    8067c4 <tcp_alloc+0x3a>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8067d8:	85 ff                	test   %edi,%edi
  8067da:	74 08                	je     8067e4 <tcp_alloc+0x5a>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8067dc:	89 3c 24             	mov    %edi,(%esp)
  8067df:	e8 25 fa ff ff       	call   806209 <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8067e4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8067eb:	e8 22 e2 ff ff       	call   804a12 <memp_malloc>
  8067f0:	89 c6                	mov    %eax,%esi
    if (pcb == NULL) {
  8067f2:	85 c0                	test   %eax,%eax
  8067f4:	75 6a                	jne    806860 <tcp_alloc+0xd6>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  8067f6:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8067fb:	8b 3d 60 c2 b3 00    	mov    0xb3c260,%edi
  806801:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  806804:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  806809:	bf 00 00 00 00       	mov    $0x0,%edi
  inactive = NULL;
  80680e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806815:	eb 20                	jmp    806837 <tcp_alloc+0xad>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  806817:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80681b:	38 d3                	cmp    %dl,%bl
  80681d:	72 15                	jb     806834 <tcp_alloc+0xaa>
  80681f:	38 ca                	cmp    %cl,%dl
  806821:	77 11                	ja     806834 <tcp_alloc+0xaa>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  806823:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806826:	2b 70 2c             	sub    0x2c(%eax),%esi
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
  806829:	39 fe                	cmp    %edi,%esi
  80682b:	72 07                	jb     806834 <tcp_alloc+0xaa>
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  80682d:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  80682f:	89 f7                	mov    %esi,%edi
      inactive = pcb;
  806831:	89 45 e0             	mov    %eax,-0x20(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  806834:	8b 40 0c             	mov    0xc(%eax),%eax
  806837:	85 c0                	test   %eax,%eax
  806839:	75 dc                	jne    806817 <tcp_alloc+0x8d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80683b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80683e:	85 c0                	test   %eax,%eax
  806840:	74 08                	je     80684a <tcp_alloc+0xc0>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  806842:	89 04 24             	mov    %eax,(%esp)
  806845:	e8 bf f9 ff ff       	call   806209 <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80684a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  806851:	e8 bc e1 ff ff       	call   804a12 <memp_malloc>
  806856:	89 c6                	mov    %eax,%esi
    }
  }
  if (pcb != NULL) {
  806858:	85 c0                	test   %eax,%eax
  80685a:	0f 84 9b 00 00 00    	je     8068fb <tcp_alloc+0x171>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  806860:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  806867:	00 
  806868:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80686f:	00 
  806870:	89 34 24             	mov    %esi,(%esp)
  806873:	e8 8f 90 00 00       	call   80f907 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  806878:	c6 46 14 40          	movb   $0x40,0x14(%esi)
    pcb->snd_buf = TCP_SND_BUF;
  80687c:	66 c7 46 6e 40 5b    	movw   $0x5b40,0x6e(%esi)
    pcb->snd_queuelen = 0;
  806882:	66 c7 46 70 00 00    	movw   $0x0,0x70(%esi)
    pcb->rcv_wnd = TCP_WND;
  806888:	66 c7 46 28 c0 5d    	movw   $0x5dc0,0x28(%esi)
    pcb->rcv_ann_wnd = TCP_WND;
  80688e:	66 c7 46 2a c0 5d    	movw   $0x5dc0,0x2a(%esi)
    pcb->tos = 0;
  806894:	c6 46 0a 00          	movb   $0x0,0xa(%esi)
    pcb->ttl = TCP_TTL;
  806898:	c6 46 0b ff          	movb   $0xff,0xb(%esi)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80689c:	66 c7 46 34 18 02    	movw   $0x218,0x34(%esi)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8068a2:	66 c7 46 44 06 00    	movw   $0x6,0x44(%esi)
    pcb->sa = 0;
  8068a8:	66 c7 46 40 00 00    	movw   $0x0,0x40(%esi)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8068ae:	66 c7 46 42 06 00    	movw   $0x6,0x42(%esi)
    pcb->rtime = -1;
  8068b4:	66 c7 46 32 ff ff    	movw   $0xffff,0x32(%esi)
    pcb->cwnd = 1;
  8068ba:	66 c7 46 4e 01 00    	movw   $0x1,0x4e(%esi)
    iss = tcp_next_iss();
  8068c0:	e8 b0 fe ff ff       	call   806775 <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8068c5:	89 46 64             	mov    %eax,0x64(%esi)
    pcb->snd_nxt = iss;
  8068c8:	89 46 54             	mov    %eax,0x54(%esi)
    pcb->snd_max = iss;
  8068cb:	89 46 58             	mov    %eax,0x58(%esi)
    pcb->lastack = iss;
  8068ce:	89 46 48             	mov    %eax,0x48(%esi)
    pcb->snd_lbb = iss;   
  8068d1:	89 46 68             	mov    %eax,0x68(%esi)
    pcb->tmr = tcp_ticks;
  8068d4:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  8068d9:	89 46 2c             	mov    %eax,0x2c(%esi)

    pcb->polltmr = 0;
  8068dc:	c6 46 30 00          	movb   $0x0,0x30(%esi)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  8068e0:	c7 86 88 00 00 00 d4 	movl   $0x8061d4,0x88(%esi)
  8068e7:	61 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  8068ea:	c7 86 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%esi)
  8068f1:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  8068f4:	c6 86 a5 00 00 00 00 	movb   $0x0,0xa5(%esi)
  }
  return pcb;
}
  8068fb:	89 f0                	mov    %esi,%eax
  8068fd:	83 c4 2c             	add    $0x2c,%esp
  806900:	5b                   	pop    %ebx
  806901:	5e                   	pop    %esi
  806902:	5f                   	pop    %edi
  806903:	5d                   	pop    %ebp
  806904:	c3                   	ret    

00806905 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  806905:	55                   	push   %ebp
  806906:	89 e5                	mov    %esp,%ebp
  806908:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80690b:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  806912:	e8 73 fe ff ff       	call   80678a <tcp_alloc>
}
  806917:	c9                   	leave  
  806918:	c3                   	ret    

00806919 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  806919:	55                   	push   %ebp
  80691a:	89 e5                	mov    %esp,%ebp
  80691c:	56                   	push   %esi
  80691d:	53                   	push   %ebx
  80691e:	83 ec 10             	sub    $0x10,%esp
  806921:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806924:	89 de                	mov    %ebx,%esi
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  806926:	8b 45 0c             	mov    0xc(%ebp),%eax
  806929:	89 04 24             	mov    %eax,(%esp)
  80692c:	e8 df 01 00 00       	call   806b10 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  806931:	85 c0                	test   %eax,%eax
  806933:	74 12                	je     806947 <tcp_eff_send_mss+0x2e>
  806935:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806939:	66 85 c0             	test   %ax,%ax
  80693c:	74 09                	je     806947 <tcp_eff_send_mss+0x2e>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  80693e:	8d 70 d8             	lea    -0x28(%eax),%esi
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  806941:	66 39 f3             	cmp    %si,%bx
  806944:	0f 46 f3             	cmovbe %ebx,%esi
  }
  return sendmss;
}
  806947:	89 f0                	mov    %esi,%eax
  806949:	83 c4 10             	add    $0x10,%esp
  80694c:	5b                   	pop    %ebx
  80694d:	5e                   	pop    %esi
  80694e:	5d                   	pop    %ebp
  80694f:	c3                   	ret    

00806950 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  806950:	55                   	push   %ebp
  806951:	89 e5                	mov    %esp,%ebp
  806953:	56                   	push   %esi
  806954:	53                   	push   %ebx
  806955:	83 ec 30             	sub    $0x30,%esp
  806958:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80695b:	8b 75 0c             	mov    0xc(%ebp),%esi
  80695e:	8b 45 10             	mov    0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  806961:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  806965:	74 1c                	je     806983 <tcp_connect+0x33>
  806967:	c7 44 24 08 38 2e 81 	movl   $0x812e38,0x8(%esp)
  80696e:	00 
  80696f:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  806976:	00 
  806977:	c7 04 24 6a 2e 81 00 	movl   $0x812e6a,(%esp)
  80697e:	e8 17 87 00 00       	call   80f09a <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  806983:	85 f6                	test   %esi,%esi
  806985:	0f 84 2a 01 00 00    	je     806ab5 <tcp_connect+0x165>
    pcb->remote_ip = *ipaddr;
  80698b:	8b 16                	mov    (%esi),%edx
  80698d:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  806990:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  806994:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  806999:	75 09                	jne    8069a4 <tcp_connect+0x54>
    pcb->local_port = tcp_new_port();
  80699b:	e8 2a f0 ff ff       	call   8059ca <tcp_new_port>
  8069a0:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  8069a4:	e8 cc fd ff ff       	call   806775 <tcp_next_iss>
  pcb->rcv_nxt = 0;
  8069a9:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  8069b0:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  8069b3:	83 e8 01             	sub    $0x1,%eax
  8069b6:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  8069b9:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  8069bc:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  8069c2:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  8069c8:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8069ce:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  8069d4:	89 74 24 04          	mov    %esi,0x4(%esp)
  8069d8:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  8069df:	e8 35 ff ff ff       	call   806919 <tcp_eff_send_mss>
  8069e4:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  8069e8:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  8069ee:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8069f1:	01 c0                	add    %eax,%eax
  8069f3:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  8069f7:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  8069fe:	8b 45 14             	mov    0x14(%ebp),%eax
  806a01:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  806a07:	8b 15 6c c2 b3 00    	mov    0xb3c26c,%edx
  806a0d:	39 da                	cmp    %ebx,%edx
  806a0f:	75 0a                	jne    806a1b <tcp_connect+0xcb>
  806a11:	8b 42 0c             	mov    0xc(%edx),%eax
  806a14:	a3 6c c2 b3 00       	mov    %eax,0xb3c26c
  806a19:	eb 2d                	jmp    806a48 <tcp_connect+0xf8>
  806a1b:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806a21:	eb 1b                	jmp    806a3e <tcp_connect+0xee>
  806a23:	8b 42 0c             	mov    0xc(%edx),%eax
  806a26:	85 c0                	test   %eax,%eax
  806a28:	74 12                	je     806a3c <tcp_connect+0xec>
  806a2a:	39 c3                	cmp    %eax,%ebx
  806a2c:	75 0e                	jne    806a3c <tcp_connect+0xec>
  806a2e:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  806a34:	8b 43 0c             	mov    0xc(%ebx),%eax
  806a37:	89 42 0c             	mov    %eax,0xc(%edx)
  806a3a:	eb 0c                	jmp    806a48 <tcp_connect+0xf8>
  806a3c:	89 c2                	mov    %eax,%edx
  806a3e:	85 d2                	test   %edx,%edx
  806a40:	75 e1                	jne    806a23 <tcp_connect+0xd3>
  806a42:	89 15 68 c2 b3 00    	mov    %edx,0xb3c268
  TCP_REG(&tcp_active_pcbs, pcb);
  806a48:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  806a4d:	89 43 0c             	mov    %eax,0xc(%ebx)
  806a50:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
  806a56:	e8 47 bb ff ff       	call   8025a2 <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  806a5b:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  806a62:	e8 59 13 00 00       	call   807dc0 <htonl>
  806a67:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  806a6a:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  806a71:	00 
  806a72:	8d 45 f4             	lea    -0xc(%ebp),%eax
  806a75:	89 44 24 14          	mov    %eax,0x14(%esp)
  806a79:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  806a80:	00 
  806a81:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  806a88:	00 
  806a89:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806a90:	00 
  806a91:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806a98:	00 
  806a99:	89 1c 24             	mov    %ebx,(%esp)
  806a9c:	e8 6f 15 00 00       	call   808010 <tcp_enqueue>
  806aa1:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  806aa3:	89 f1                	mov    %esi,%ecx
  806aa5:	84 c9                	test   %cl,%cl
  806aa7:	75 11                	jne    806aba <tcp_connect+0x16a>
    tcp_output(pcb);
  806aa9:	89 1c 24             	mov    %ebx,(%esp)
  806aac:	e8 e0 1c 00 00       	call   808791 <tcp_output>
  }
  return ret;
  806ab1:	89 f0                	mov    %esi,%eax
  806ab3:	eb 05                	jmp    806aba <tcp_connect+0x16a>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  806ab5:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  if (ret == ERR_OK) { 
    tcp_output(pcb);
  }
  return ret;
} 
  806aba:	83 c4 30             	add    $0x30,%esp
  806abd:	5b                   	pop    %ebx
  806abe:	5e                   	pop    %esi
  806abf:	5d                   	pop    %ebp
  806ac0:	c3                   	ret    

00806ac1 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  806ac1:	55                   	push   %ebp
  806ac2:	89 e5                	mov    %esp,%ebp
  806ac4:	53                   	push   %ebx
  806ac5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  806ac8:	8b 45 08             	mov    0x8(%ebp),%eax
  806acb:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806acd:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  806ad0:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  806ad5:	83 fb fd             	cmp    $0xfffffffd,%ebx
  806ad8:	77 32                	ja     806b0c <ip_addr_isbroadcast+0x4b>
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  806ada:	b8 00 00 00 00       	mov    $0x0,%eax
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  806adf:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  806ae3:	74 27                	je     806b0c <ip_addr_isbroadcast+0x4b>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  806ae5:	8b 41 04             	mov    0x4(%ecx),%eax
  806ae8:	39 d0                	cmp    %edx,%eax
  806aea:	74 1b                	je     806b07 <ip_addr_isbroadcast+0x46>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806aec:	8b 49 08             	mov    0x8(%ecx),%ecx
  806aef:	31 d0                	xor    %edx,%eax
  806af1:	89 c3                	mov    %eax,%ebx
          && ((addr2test & ~netif->netmask.addr) ==
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
  806af3:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  806af8:	85 cb                	test   %ecx,%ebx
  806afa:	75 10                	jne    806b0c <ip_addr_isbroadcast+0x4b>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  806afc:	f7 d1                	not    %ecx
  806afe:	21 ca                	and    %ecx,%edx
  806b00:	39 d1                	cmp    %edx,%ecx
  806b02:	0f 94 c0             	sete   %al
  806b05:	eb 05                	jmp    806b0c <ip_addr_isbroadcast+0x4b>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
    return 0;
  806b07:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  806b0c:	5b                   	pop    %ebx
  806b0d:	5d                   	pop    %ebp
  806b0e:	c3                   	ret    
  806b0f:	90                   	nop

00806b10 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  806b10:	55                   	push   %ebp
  806b11:	89 e5                	mov    %esp,%ebp
  806b13:	56                   	push   %esi
  806b14:	53                   	push   %ebx
  806b15:	83 ec 10             	sub    $0x10,%esp
  806b18:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806b1b:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  806b21:	eb 18                	jmp    806b3b <ip_route+0x2b>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  806b23:	89 1c 24             	mov    %ebx,(%esp)
  806b26:	e8 02 e2 ff ff       	call   804d2d <netif_is_up>
  806b2b:	84 c0                	test   %al,%al
  806b2d:	74 0a                	je     806b39 <ip_route+0x29>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  806b2f:	8b 43 04             	mov    0x4(%ebx),%eax
  806b32:	33 06                	xor    (%esi),%eax
  806b34:	85 43 08             	test   %eax,0x8(%ebx)
  806b37:	74 27                	je     806b60 <ip_route+0x50>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  806b39:	8b 1b                	mov    (%ebx),%ebx
  806b3b:	85 db                	test   %ebx,%ebx
  806b3d:	75 e4                	jne    806b23 <ip_route+0x13>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  806b3f:	a1 58 c2 b3 00       	mov    0xb3c258,%eax
  806b44:	85 c0                	test   %eax,%eax
  806b46:	74 1c                	je     806b64 <ip_route+0x54>
  806b48:	89 04 24             	mov    %eax,(%esp)
  806b4b:	e8 dd e1 ff ff       	call   804d2d <netif_is_up>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  806b50:	84 c0                	test   %al,%al
  806b52:	b8 00 00 00 00       	mov    $0x0,%eax
  806b57:	0f 45 05 58 c2 b3 00 	cmovne 0xb3c258,%eax
  806b5e:	eb 09                	jmp    806b69 <ip_route+0x59>
  806b60:	89 d8                	mov    %ebx,%eax
  806b62:	eb 05                	jmp    806b69 <ip_route+0x59>
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  806b64:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
  806b69:	83 c4 10             	add    $0x10,%esp
  806b6c:	5b                   	pop    %ebx
  806b6d:	5e                   	pop    %esi
  806b6e:	5d                   	pop    %ebp
  806b6f:	c3                   	ret    

00806b70 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  806b70:	55                   	push   %ebp
  806b71:	89 e5                	mov    %esp,%ebp
  806b73:	57                   	push   %edi
  806b74:	56                   	push   %esi
  806b75:	53                   	push   %ebx
  806b76:	83 ec 2c             	sub    $0x2c,%esp

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  806b79:	8b 45 08             	mov    0x8(%ebp),%eax
  806b7c:	8b 70 04             	mov    0x4(%eax),%esi
  if (IPH_V(iphdr) != 4) {
  806b7f:	0f b7 06             	movzwl (%esi),%eax
  806b82:	89 04 24             	mov    %eax,(%esp)
  806b85:	e8 29 12 00 00       	call   807db3 <ntohs>
  806b8a:	66 c1 e8 0c          	shr    $0xc,%ax
  806b8e:	66 83 f8 04          	cmp    $0x4,%ax
  806b92:	74 10                	je     806ba4 <ip_input+0x34>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  806b94:	8b 45 08             	mov    0x8(%ebp),%eax
  806b97:	89 04 24             	mov    %eax,(%esp)
  806b9a:	e8 85 e2 ff ff       	call   804e24 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806b9f:	e9 9d 02 00 00       	jmp    806e41 <ip_input+0x2d1>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  806ba4:	0f b7 06             	movzwl (%esi),%eax
  806ba7:	89 04 24             	mov    %eax,(%esp)
  806baa:	e8 04 12 00 00       	call   807db3 <ntohs>
  806baf:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  806bb3:	83 e0 3c             	and    $0x3c,%eax
  806bb6:	89 c7                	mov    %eax,%edi
  806bb8:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  806bbc:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  806bc0:	89 04 24             	mov    %eax,(%esp)
  806bc3:	e8 eb 11 00 00       	call   807db3 <ntohs>
  806bc8:	89 c3                	mov    %eax,%ebx

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  806bca:	8b 55 08             	mov    0x8(%ebp),%edx
  806bcd:	66 3b 7a 0a          	cmp    0xa(%edx),%di
  806bd1:	77 06                	ja     806bd9 <ip_input+0x69>
  806bd3:	66 3b 5a 08          	cmp    0x8(%edx),%bx
  806bd7:	76 10                	jbe    806be9 <ip_input+0x79>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  806bd9:	8b 45 08             	mov    0x8(%ebp),%eax
  806bdc:	89 04 24             	mov    %eax,(%esp)
  806bdf:	e8 40 e2 ff ff       	call   804e24 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  806be4:	e9 58 02 00 00       	jmp    806e41 <ip_input+0x2d1>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  806be9:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806bed:	89 44 24 04          	mov    %eax,0x4(%esp)
  806bf1:	89 34 24             	mov    %esi,(%esp)
  806bf4:	e8 58 10 00 00       	call   807c51 <inet_chksum>
  806bf9:	66 85 c0             	test   %ax,%ax
  806bfc:	74 10                	je     806c0e <ip_input+0x9e>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  806bfe:	8b 45 08             	mov    0x8(%ebp),%eax
  806c01:	89 04 24             	mov    %eax,(%esp)
  806c04:	e8 1b e2 ff ff       	call   804e24 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  806c09:	e9 33 02 00 00       	jmp    806e41 <ip_input+0x2d1>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  806c0e:	0f b7 db             	movzwl %bx,%ebx
  806c11:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806c15:	8b 45 08             	mov    0x8(%ebp),%eax
  806c18:	89 04 24             	mov    %eax,(%esp)
  806c1b:	e8 76 e5 ff ff       	call   805196 <pbuf_realloc>
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  806c20:	8b 5d 0c             	mov    0xc(%ebp),%ebx
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  806c23:	bf 01 00 00 00       	mov    $0x1,%edi
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806c28:	8d 46 10             	lea    0x10(%esi),%eax
  806c2b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806c2e:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  806c31:	89 de                	mov    %ebx,%esi
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  806c33:	89 1c 24             	mov    %ebx,(%esp)
  806c36:	e8 f2 e0 ff ff       	call   804d2d <netif_is_up>
  806c3b:	84 c0                	test   %al,%al
  806c3d:	74 27                	je     806c66 <ip_input+0xf6>
  806c3f:	83 fb fc             	cmp    $0xfffffffc,%ebx
  806c42:	74 22                	je     806c66 <ip_input+0xf6>
  806c44:	8b 43 04             	mov    0x4(%ebx),%eax
  806c47:	85 c0                	test   %eax,%eax
  806c49:	74 1b                	je     806c66 <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806c4b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806c4e:	3b 41 10             	cmp    0x10(%ecx),%eax
  806c51:	74 32                	je     806c85 <ip_input+0x115>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  806c53:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806c57:	8b 45 dc             	mov    -0x24(%ebp),%eax
  806c5a:	89 04 24             	mov    %eax,(%esp)
  806c5d:	e8 5f fe ff ff       	call   806ac1 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  806c62:	84 c0                	test   %al,%al
  806c64:	75 26                	jne    806c8c <ip_input+0x11c>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  806c66:	85 ff                	test   %edi,%edi
  806c68:	74 08                	je     806c72 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  806c6a:	8b 1d 54 c2 b3 00    	mov    0xb3c254,%ebx
  806c70:	eb 02                	jmp    806c74 <ip_input+0x104>
      } else {
        netif = netif->next;
  806c72:	8b 1b                	mov    (%ebx),%ebx
      }
      if (netif == inp) {
  806c74:	39 f3                	cmp    %esi,%ebx
  806c76:	75 02                	jne    806c7a <ip_input+0x10a>
        netif = netif->next;
  806c78:	8b 1e                	mov    (%esi),%ebx
      }
    } while(netif != NULL);
  806c7a:	85 db                	test   %ebx,%ebx
  806c7c:	74 1d                	je     806c9b <ip_input+0x12b>
  806c7e:	bf 00 00 00 00       	mov    $0x0,%edi
  806c83:	eb ae                	jmp    806c33 <ip_input+0xc3>
  806c85:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806c88:	89 d8                	mov    %ebx,%eax
  806c8a:	eb 05                	jmp    806c91 <ip_input+0x121>
  806c8c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  806c8f:	89 d8                	mov    %ebx,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  806c91:	85 c0                	test   %eax,%eax
  806c93:	0f 85 89 01 00 00    	jne    806e22 <ip_input+0x2b2>
  806c99:	eb 03                	jmp    806c9e <ip_input+0x12e>
  806c9b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  806c9e:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806ca2:	89 04 24             	mov    %eax,(%esp)
  806ca5:	e8 09 11 00 00       	call   807db3 <ntohs>
  806caa:	bb 00 00 00 00       	mov    $0x0,%ebx
  806caf:	3c 11                	cmp    $0x11,%al
  806cb1:	0f 85 6b 01 00 00    	jne    806e22 <ip_input+0x2b2>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  806cb7:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  806cbb:	0f b7 44 06 02       	movzwl 0x2(%esi,%eax,1),%eax
  806cc0:	89 04 24             	mov    %eax,(%esp)
  806cc3:	e8 eb 10 00 00       	call   807db3 <ntohs>
  806cc8:	66 83 f8 44          	cmp    $0x44,%ax
  806ccc:	74 36                	je     806d04 <ip_input+0x194>
  806cce:	e9 4f 01 00 00       	jmp    806e22 <ip_input+0x2b2>
  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
         (ip_addr_ismulticast(&(iphdr->src)))) {
  806cd3:	8b 7e 0c             	mov    0xc(%esi),%edi
  806cd6:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806cdd:	e8 18 13 00 00       	call   807ffa <ntohl>
  806ce2:	21 c7                	and    %eax,%edi
  806ce4:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806ceb:	e8 0a 13 00 00       	call   807ffa <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806cf0:	39 c7                	cmp    %eax,%edi
  806cf2:	75 13                	jne    806d07 <ip_input+0x197>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  806cf4:	8b 45 08             	mov    0x8(%ebp),%eax
  806cf7:	89 04 24             	mov    %eax,(%esp)
  806cfa:	e8 25 e1 ff ff       	call   804e24 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  806cff:	e9 3d 01 00 00       	jmp    806e41 <ip_input+0x2d1>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  806d04:	8b 5d 0c             	mov    0xc(%ebp),%ebx
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  806d07:	85 db                	test   %ebx,%ebx
  806d09:	75 10                	jne    806d1b <ip_input+0x1ab>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  806d0b:	8b 45 08             	mov    0x8(%ebp),%eax
  806d0e:	89 04 24             	mov    %eax,(%esp)
  806d11:	e8 0e e1 ff ff       	call   804e24 <pbuf_free>
    return ERR_OK;
  806d16:	e9 26 01 00 00       	jmp    806e41 <ip_input+0x2d1>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  806d1b:	0f b7 5e 06          	movzwl 0x6(%esi),%ebx
  806d1f:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  806d26:	e8 7b 10 00 00       	call   807da6 <htons>
  806d2b:	66 85 d8             	test   %bx,%ax
  806d2e:	74 19                	je     806d49 <ip_input+0x1d9>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  806d30:	8b 45 08             	mov    0x8(%ebp),%eax
  806d33:	89 04 24             	mov    %eax,(%esp)
  806d36:	e8 52 05 00 00       	call   80728d <ip_reass>
  806d3b:	89 45 08             	mov    %eax,0x8(%ebp)
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  806d3e:	85 c0                	test   %eax,%eax
  806d40:	0f 84 fb 00 00 00    	je     806e41 <ip_input+0x2d1>
      return ERR_OK;
    }
    iphdr = p->payload;
  806d46:	8b 70 04             	mov    0x4(%eax),%esi
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  806d49:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d4c:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d50:	8b 45 08             	mov    0x8(%ebp),%eax
  806d53:	89 04 24             	mov    %eax,(%esp)
  806d56:	e8 7e 7a 00 00       	call   80e7d9 <raw_input>
  806d5b:	84 c0                	test   %al,%al
  806d5d:	0f 85 de 00 00 00    	jne    806e41 <ip_input+0x2d1>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  806d63:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806d67:	89 04 24             	mov    %eax,(%esp)
  806d6a:	e8 44 10 00 00       	call   807db3 <ntohs>
  806d6f:	0f b6 c0             	movzbl %al,%eax
  806d72:	66 83 f8 06          	cmp    $0x6,%ax
  806d76:	74 25                	je     806d9d <ip_input+0x22d>
  806d78:	66 83 f8 11          	cmp    $0x11,%ax
  806d7c:	74 08                	je     806d86 <ip_input+0x216>
  806d7e:	66 83 f8 01          	cmp    $0x1,%ax
  806d82:	75 44                	jne    806dc8 <ip_input+0x258>
  806d84:	eb 2e                	jmp    806db4 <ip_input+0x244>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  806d86:	8b 45 0c             	mov    0xc(%ebp),%eax
  806d89:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d8d:	8b 45 08             	mov    0x8(%ebp),%eax
  806d90:	89 04 24             	mov    %eax,(%esp)
  806d93:	e8 58 23 00 00       	call   8090f0 <udp_input>
      break;
  806d98:	e9 a4 00 00 00       	jmp    806e41 <ip_input+0x2d1>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  806d9d:	8b 45 0c             	mov    0xc(%ebp),%eax
  806da0:	89 44 24 04          	mov    %eax,0x4(%esp)
  806da4:	8b 45 08             	mov    0x8(%ebp),%eax
  806da7:	89 04 24             	mov    %eax,(%esp)
  806daa:	e8 e9 6c 00 00       	call   80da98 <tcp_input>
      break;
  806daf:	e9 8d 00 00 00       	jmp    806e41 <ip_input+0x2d1>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  806db4:	8b 45 0c             	mov    0xc(%ebp),%eax
  806db7:	89 44 24 04          	mov    %eax,0x4(%esp)
  806dbb:	8b 45 08             	mov    0x8(%ebp),%eax
  806dbe:	89 04 24             	mov    %eax,(%esp)
  806dc1:	e8 0a 7d 00 00       	call   80ead0 <icmp_input>
      break;
  806dc6:	eb 79                	jmp    806e41 <ip_input+0x2d1>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806dc8:	8b 45 0c             	mov    0xc(%ebp),%eax
  806dcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  806dcf:	8d 46 10             	lea    0x10(%esi),%eax
  806dd2:	89 04 24             	mov    %eax,(%esp)
  806dd5:	e8 e7 fc ff ff       	call   806ac1 <ip_addr_isbroadcast>
  806dda:	84 c0                	test   %al,%al
  806ddc:	75 37                	jne    806e15 <ip_input+0x2a5>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  806dde:	8b 5e 10             	mov    0x10(%esi),%ebx
  806de1:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  806de8:	e8 0d 12 00 00       	call   807ffa <ntohl>
  806ded:	21 c3                	and    %eax,%ebx
  806def:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  806df6:	e8 ff 11 00 00       	call   807ffa <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  806dfb:	39 c3                	cmp    %eax,%ebx
  806dfd:	74 16                	je     806e15 <ip_input+0x2a5>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  806dff:	8b 45 08             	mov    0x8(%ebp),%eax
  806e02:	89 70 04             	mov    %esi,0x4(%eax)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  806e05:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  806e0c:	00 
  806e0d:	89 04 24             	mov    %eax,(%esp)
  806e10:	e8 00 80 00 00       	call   80ee15 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  806e15:	8b 45 08             	mov    0x8(%ebp),%eax
  806e18:	89 04 24             	mov    %eax,(%esp)
  806e1b:	e8 04 e0 ff ff       	call   804e24 <pbuf_free>
  806e20:	eb 1f                	jmp    806e41 <ip_input+0x2d1>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  806e22:	8b 45 0c             	mov    0xc(%ebp),%eax
  806e25:	89 44 24 04          	mov    %eax,0x4(%esp)
  806e29:	8d 46 0c             	lea    0xc(%esi),%eax
  806e2c:	89 04 24             	mov    %eax,(%esp)
  806e2f:	e8 8d fc ff ff       	call   806ac1 <ip_addr_isbroadcast>
  806e34:	84 c0                	test   %al,%al
  806e36:	0f 84 97 fe ff ff    	je     806cd3 <ip_input+0x163>
  806e3c:	e9 b3 fe ff ff       	jmp    806cf4 <ip_input+0x184>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  806e41:	b8 00 00 00 00       	mov    $0x0,%eax
  806e46:	83 c4 2c             	add    $0x2c,%esp
  806e49:	5b                   	pop    %ebx
  806e4a:	5e                   	pop    %esi
  806e4b:	5f                   	pop    %edi
  806e4c:	5d                   	pop    %ebp
  806e4d:	c3                   	ret    

00806e4e <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  806e4e:	55                   	push   %ebp
  806e4f:	89 e5                	mov    %esp,%ebp
  806e51:	57                   	push   %edi
  806e52:	56                   	push   %esi
  806e53:	53                   	push   %ebx
  806e54:	83 ec 2c             	sub    $0x2c,%esp
  806e57:	8b 75 08             	mov    0x8(%ebp),%esi
  806e5a:	8b 7d 14             	mov    0x14(%ebp),%edi
  806e5d:	8b 45 18             	mov    0x18(%ebp),%eax
  806e60:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806e63:	8b 45 1c             	mov    0x1c(%ebp),%eax
  806e66:	89 45 e0             	mov    %eax,-0x20(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  806e69:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  806e6d:	0f 84 17 01 00 00    	je     806f8a <ip_output_if+0x13c>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  806e73:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806e7a:	00 
  806e7b:	89 34 24             	mov    %esi,(%esp)
  806e7e:	e8 bd de ff ff       	call   804d40 <pbuf_header>
  806e83:	84 c0                	test   %al,%al
  806e85:	0f 85 48 01 00 00    	jne    806fd3 <ip_output_if+0x185>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  806e8b:	8b 5e 04             	mov    0x4(%esi),%ebx
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  806e8e:	66 83 7e 0a 13       	cmpw   $0x13,0xa(%esi)
  806e93:	77 1c                	ja     806eb1 <ip_output_if+0x63>
  806e95:	c7 44 24 08 04 2f 81 	movl   $0x812f04,0x8(%esp)
  806e9c:	00 
  806e9d:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  806ea4:	00 
  806ea5:	c7 04 24 31 2f 81 00 	movl   $0x812f31,(%esp)
  806eac:	e8 e9 81 00 00       	call   80f09a <_panic>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  806eb1:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  806eb5:	89 04 24             	mov    %eax,(%esp)
  806eb8:	e8 f6 0e 00 00       	call   807db3 <ntohs>
  806ebd:	0f b6 c0             	movzbl %al,%eax
  806ec0:	c1 e7 08             	shl    $0x8,%edi
  806ec3:	09 c7                	or     %eax,%edi
  806ec5:	0f b7 ff             	movzwl %di,%edi
  806ec8:	89 3c 24             	mov    %edi,(%esp)
  806ecb:	e8 d6 0e 00 00       	call   807da6 <htons>
  806ed0:	66 89 43 08          	mov    %ax,0x8(%ebx)
    IPH_PROTO_SET(iphdr, proto);
  806ed4:	0f b7 c0             	movzwl %ax,%eax
  806ed7:	89 04 24             	mov    %eax,(%esp)
  806eda:	e8 d4 0e 00 00       	call   807db3 <ntohs>
  806edf:	25 00 ff 00 00       	and    $0xff00,%eax
  806ee4:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  806ee8:	09 d0                	or     %edx,%eax
  806eea:	0f b7 c0             	movzwl %ax,%eax
  806eed:	89 04 24             	mov    %eax,(%esp)
  806ef0:	e8 b1 0e 00 00       	call   807da6 <htons>
  806ef5:	66 89 43 08          	mov    %ax,0x8(%ebx)

    ip_addr_set(&(iphdr->dest), dest);
  806ef9:	8b 45 10             	mov    0x10(%ebp),%eax
  806efc:	8b 00                	mov    (%eax),%eax
  806efe:	89 43 10             	mov    %eax,0x10(%ebx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  806f01:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  806f05:	80 cc 45             	or     $0x45,%ah
  806f08:	89 04 24             	mov    %eax,(%esp)
  806f0b:	e8 96 0e 00 00       	call   807da6 <htons>
  806f10:	66 89 03             	mov    %ax,(%ebx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  806f13:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  806f17:	89 04 24             	mov    %eax,(%esp)
  806f1a:	e8 87 0e 00 00       	call   807da6 <htons>
  806f1f:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(iphdr, 0);
  806f23:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_ID_SET(iphdr, htons(ip_id));
  806f29:	0f b7 05 1a 54 b3 00 	movzwl 0xb3541a,%eax
  806f30:	89 04 24             	mov    %eax,(%esp)
  806f33:	e8 6e 0e 00 00       	call   807da6 <htons>
  806f38:	66 89 43 04          	mov    %ax,0x4(%ebx)
    ++ip_id;
  806f3c:	66 83 05 1a 54 b3 00 	addw   $0x1,0xb3541a
  806f43:	01 

    if (ip_addr_isany(src)) {
  806f44:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  806f48:	74 09                	je     806f53 <ip_output_if+0x105>
  806f4a:	8b 45 0c             	mov    0xc(%ebp),%eax
  806f4d:	8b 00                	mov    (%eax),%eax
  806f4f:	85 c0                	test   %eax,%eax
  806f51:	75 18                	jne    806f6b <ip_output_if+0x11d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  806f53:	83 7d 20 fc          	cmpl   $0xfffffffc,0x20(%ebp)
  806f57:	74 08                	je     806f61 <ip_output_if+0x113>
  806f59:	8b 45 20             	mov    0x20(%ebp),%eax
  806f5c:	8b 40 04             	mov    0x4(%eax),%eax
  806f5f:	eb 05                	jmp    806f66 <ip_output_if+0x118>
  806f61:	b8 00 00 00 00       	mov    $0x0,%eax
  806f66:	89 43 0c             	mov    %eax,0xc(%ebx)
  806f69:	eb 03                	jmp    806f6e <ip_output_if+0x120>
    } else {
      ip_addr_set(&(iphdr->src), src);
  806f6b:	89 43 0c             	mov    %eax,0xc(%ebx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  806f6e:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  806f74:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  806f7b:	00 
  806f7c:	89 1c 24             	mov    %ebx,(%esp)
  806f7f:	e8 cd 0c 00 00       	call   807c51 <inet_chksum>
  806f84:	66 89 43 0a          	mov    %ax,0xa(%ebx)
  806f88:	eb 09                	jmp    806f93 <ip_output_if+0x145>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  806f8a:	8b 46 04             	mov    0x4(%esi),%eax
  806f8d:	83 c0 10             	add    $0x10,%eax
  806f90:	89 45 10             	mov    %eax,0x10(%ebp)
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  806f93:	8b 45 20             	mov    0x20(%ebp),%eax
  806f96:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  806f9a:	66 85 c0             	test   %ax,%ax
  806f9d:	74 1e                	je     806fbd <ip_output_if+0x16f>
  806f9f:	66 3b 46 08          	cmp    0x8(%esi),%ax
  806fa3:	73 18                	jae    806fbd <ip_output_if+0x16f>
    return ip_frag(p,netif,dest);
  806fa5:	8b 45 10             	mov    0x10(%ebp),%eax
  806fa8:	89 44 24 08          	mov    %eax,0x8(%esp)
  806fac:	8b 45 20             	mov    0x20(%ebp),%eax
  806faf:	89 44 24 04          	mov    %eax,0x4(%esp)
  806fb3:	89 34 24             	mov    %esi,(%esp)
  806fb6:	e8 07 08 00 00       	call   8077c2 <ip_frag>
  806fbb:	eb 1b                	jmp    806fd8 <ip_output_if+0x18a>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  806fbd:	8b 45 10             	mov    0x10(%ebp),%eax
  806fc0:	89 44 24 08          	mov    %eax,0x8(%esp)
  806fc4:	89 74 24 04          	mov    %esi,0x4(%esp)
  806fc8:	8b 45 20             	mov    0x20(%ebp),%eax
  806fcb:	89 04 24             	mov    %eax,(%esp)
  806fce:	ff 50 14             	call   *0x14(%eax)
  806fd1:	eb 05                	jmp    806fd8 <ip_output_if+0x18a>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  806fd3:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  806fd8:	83 c4 2c             	add    $0x2c,%esp
  806fdb:	5b                   	pop    %ebx
  806fdc:	5e                   	pop    %esi
  806fdd:	5f                   	pop    %edi
  806fde:	5d                   	pop    %ebp
  806fdf:	c3                   	ret    

00806fe0 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  806fe0:	55                   	push   %ebp
  806fe1:	89 e5                	mov    %esp,%ebp
  806fe3:	57                   	push   %edi
  806fe4:	56                   	push   %esi
  806fe5:	53                   	push   %ebx
  806fe6:	83 ec 2c             	sub    $0x2c,%esp
  806fe9:	8b 5d 14             	mov    0x14(%ebp),%ebx
  806fec:	8b 75 18             	mov    0x18(%ebp),%esi
  806fef:	8b 7d 1c             	mov    0x1c(%ebp),%edi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  806ff2:	8b 45 10             	mov    0x10(%ebp),%eax
  806ff5:	89 04 24             	mov    %eax,(%esp)
  806ff8:	e8 13 fb ff ff       	call   806b10 <ip_route>
  806ffd:	85 c0                	test   %eax,%eax
  806fff:	74 38                	je     807039 <ip_output+0x59>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  807001:	89 44 24 18          	mov    %eax,0x18(%esp)
  807005:	89 f8                	mov    %edi,%eax
  807007:	0f b6 f8             	movzbl %al,%edi
  80700a:	89 7c 24 14          	mov    %edi,0x14(%esp)
  80700e:	89 f0                	mov    %esi,%eax
  807010:	0f b6 f0             	movzbl %al,%esi
  807013:	89 74 24 10          	mov    %esi,0x10(%esp)
  807017:	0f b6 db             	movzbl %bl,%ebx
  80701a:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80701e:	8b 45 10             	mov    0x10(%ebp),%eax
  807021:	89 44 24 08          	mov    %eax,0x8(%esp)
  807025:	8b 45 0c             	mov    0xc(%ebp),%eax
  807028:	89 44 24 04          	mov    %eax,0x4(%esp)
  80702c:	8b 45 08             	mov    0x8(%ebp),%eax
  80702f:	89 04 24             	mov    %eax,(%esp)
  807032:	e8 17 fe ff ff       	call   806e4e <ip_output_if>
  807037:	eb 05                	jmp    80703e <ip_output+0x5e>
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
    return ERR_RTE;
  807039:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
}
  80703e:	83 c4 2c             	add    $0x2c,%esp
  807041:	5b                   	pop    %ebx
  807042:	5e                   	pop    %esi
  807043:	5f                   	pop    %edi
  807044:	5d                   	pop    %ebp
  807045:	c3                   	ret    
  807046:	66 90                	xchg   %ax,%ax
  807048:	66 90                	xchg   %ax,%ax
  80704a:	66 90                	xchg   %ax,%ax
  80704c:	66 90                	xchg   %ax,%ax
  80704e:	66 90                	xchg   %ax,%ax

00807050 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  807050:	55                   	push   %ebp
  807051:	89 e5                	mov    %esp,%ebp
  807053:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  807056:	8b 0d 00 5a b3 00    	mov    0xb35a00,%ecx
  80705c:	39 c1                	cmp    %eax,%ecx
  80705e:	75 0a                	jne    80706a <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  807060:	8b 11                	mov    (%ecx),%edx
  807062:	89 15 00 5a b3 00    	mov    %edx,0xb35a00
  807068:	eb 24                	jmp    80708e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80706a:	85 d2                	test   %edx,%edx
  80706c:	75 1c                	jne    80708a <ip_reass_dequeue_datagram+0x3a>
  80706e:	c7 44 24 08 49 2f 81 	movl   $0x812f49,0x8(%esp)
  807075:	00 
  807076:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80707d:	00 
  80707e:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  807085:	e8 10 80 00 00       	call   80f09a <_panic>
    prev->next = ipr->next;
  80708a:	8b 08                	mov    (%eax),%ecx
  80708c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80708e:	89 44 24 04          	mov    %eax,0x4(%esp)
  807092:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807099:	e8 d4 d9 ff ff       	call   804a72 <memp_free>
}
  80709e:	c9                   	leave  
  80709f:	c3                   	ret    

008070a0 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  8070a0:	55                   	push   %ebp
  8070a1:	89 e5                	mov    %esp,%ebp
  8070a3:	57                   	push   %edi
  8070a4:	56                   	push   %esi
  8070a5:	53                   	push   %ebx
  8070a6:	83 ec 2c             	sub    $0x2c,%esp
  8070a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8070ac:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  8070af:	39 c2                	cmp    %eax,%edx
  8070b1:	75 1c                	jne    8070cf <ip_reass_free_complete_datagram+0x2f>
  8070b3:	c7 44 24 08 7f 2f 81 	movl   $0x812f7f,0x8(%esp)
  8070ba:	00 
  8070bb:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  8070c2:	00 
  8070c3:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  8070ca:	e8 cb 7f 00 00       	call   80f09a <_panic>
  if (prev != NULL) {
  8070cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8070d2:	85 c0                	test   %eax,%eax
  8070d4:	74 23                	je     8070f9 <ip_reass_free_complete_datagram+0x59>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  8070d6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8070d9:	39 08                	cmp    %ecx,(%eax)
  8070db:	74 1c                	je     8070f9 <ip_reass_free_complete_datagram+0x59>
  8070dd:	c7 44 24 08 8b 2f 81 	movl   $0x812f8b,0x8(%esp)
  8070e4:	00 
  8070e5:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  8070ec:	00 
  8070ed:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  8070f4:	e8 a1 7f 00 00       	call   80f09a <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  8070f9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070fc:	8b 58 04             	mov    0x4(%eax),%ebx
  8070ff:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  807102:	be 00 00 00 00       	mov    $0x0,%esi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  807107:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80710c:	75 45                	jne    807153 <ip_reass_free_complete_datagram+0xb3>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  80710e:	8b 00                	mov    (%eax),%eax
  807110:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807113:	89 41 04             	mov    %eax,0x4(%ecx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  807116:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80711d:	00 
  80711e:	8d 41 08             	lea    0x8(%ecx),%eax
  807121:	89 44 24 04          	mov    %eax,0x4(%esp)
  807125:	8b 43 04             	mov    0x4(%ebx),%eax
  807128:	89 04 24             	mov    %eax,(%esp)
  80712b:	e8 8c 88 00 00       	call   80f9bc <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  807130:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  807137:	00 
  807138:	89 1c 24             	mov    %ebx,(%esp)
  80713b:	e8 e7 7d 00 00       	call   80ef27 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  807140:	89 1c 24             	mov    %ebx,(%esp)
  807143:	e8 72 e1 ff ff       	call   8052ba <pbuf_clen>
  807148:	0f b6 f0             	movzbl %al,%esi
    pbuf_free(p);
  80714b:	89 1c 24             	mov    %ebx,(%esp)
  80714e:	e8 d1 dc ff ff       	call   804e24 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  807153:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807156:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  807159:	eb 1c                	jmp    807177 <ip_reass_free_complete_datagram+0xd7>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80715b:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80715e:	8b 38                	mov    (%eax),%edi
    pbufs_freed += pbuf_clen(pcur);
  807160:	89 1c 24             	mov    %ebx,(%esp)
  807163:	e8 52 e1 ff ff       	call   8052ba <pbuf_clen>
  807168:	0f b6 c0             	movzbl %al,%eax
  80716b:	01 c6                	add    %eax,%esi
    pbuf_free(pcur);    
  80716d:	89 1c 24             	mov    %ebx,(%esp)
  807170:	e8 af dc ff ff       	call   804e24 <pbuf_free>
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  807175:	89 fb                	mov    %edi,%ebx
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  807177:	85 db                	test   %ebx,%ebx
  807179:	75 e0                	jne    80715b <ip_reass_free_complete_datagram+0xbb>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80717b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80717e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807181:	e8 ca fe ff ff       	call   807050 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  807186:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  80718d:	0f b7 d0             	movzwl %ax,%edx
  807190:	39 f2                	cmp    %esi,%edx
  807192:	7d 1c                	jge    8071b0 <ip_reass_free_complete_datagram+0x110>
  807194:	c7 44 24 08 9d 2f 81 	movl   $0x812f9d,0x8(%esp)
  80719b:	00 
  80719c:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  8071a3:	00 
  8071a4:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  8071ab:	e8 ea 7e 00 00       	call   80f09a <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  8071b0:	29 f0                	sub    %esi,%eax
  8071b2:	66 a3 fc 59 b3 00    	mov    %ax,0xb359fc

  return pbufs_freed;
}
  8071b8:	89 f0                	mov    %esi,%eax
  8071ba:	83 c4 2c             	add    $0x2c,%esp
  8071bd:	5b                   	pop    %ebx
  8071be:	5e                   	pop    %esi
  8071bf:	5f                   	pop    %edi
  8071c0:	5d                   	pop    %ebp
  8071c1:	c3                   	ret    

008071c2 <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  8071c2:	55                   	push   %ebp
  8071c3:	89 e5                	mov    %esp,%ebp
  8071c5:	57                   	push   %edi
  8071c6:	56                   	push   %esi
  8071c7:	53                   	push   %ebx
  8071c8:	83 ec 1c             	sub    $0x1c,%esp
  8071cb:	89 c6                	mov    %eax,%esi
  8071cd:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  8071d0:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  8071d7:	8b 0d 00 5a b3 00    	mov    0xb35a00,%ecx
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  8071dd:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  8071e2:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  8071e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8071ec:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  8071ef:	eb 39                	jmp    80722a <ip_reass_remove_oldest_datagram+0x68>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  8071f1:	8b 5e 0c             	mov    0xc(%esi),%ebx
  8071f4:	39 59 14             	cmp    %ebx,0x14(%ecx)
  8071f7:	75 12                	jne    80720b <ip_reass_remove_oldest_datagram+0x49>
  8071f9:	8b 7e 10             	mov    0x10(%esi),%edi
  8071fc:	39 79 18             	cmp    %edi,0x18(%ecx)
  8071ff:	75 0a                	jne    80720b <ip_reass_remove_oldest_datagram+0x49>
  807201:	0f b7 7e 04          	movzwl 0x4(%esi),%edi
  807205:	66 39 79 0c          	cmp    %di,0xc(%ecx)
  807209:	74 16                	je     807221 <ip_reass_remove_oldest_datagram+0x5f>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  80720b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (oldest == NULL) {
  80720f:	85 c0                	test   %eax,%eax
  807211:	74 0c                	je     80721f <ip_reass_remove_oldest_datagram+0x5d>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
  807213:	0f b6 58 1f          	movzbl 0x1f(%eax),%ebx
  807217:	38 59 1f             	cmp    %bl,0x1f(%ecx)
  80721a:	0f 46 c1             	cmovbe %ecx,%eax
  80721d:	eb 02                	jmp    807221 <ip_reass_remove_oldest_datagram+0x5f>
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
          oldest = r;
  80721f:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  807221:	8b 39                	mov    (%ecx),%edi
  807223:	85 ff                	test   %edi,%edi
  807225:	0f 45 d1             	cmovne %ecx,%edx
  807228:	89 f9                	mov    %edi,%ecx
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
  80722a:	85 c9                	test   %ecx,%ecx
  80722c:	75 c3                	jne    8071f1 <ip_reass_remove_oldest_datagram+0x2f>
  80722e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
      if (r->next != NULL) {
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  807231:	85 c0                	test   %eax,%eax
  807233:	74 08                	je     80723d <ip_reass_remove_oldest_datagram+0x7b>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  807235:	e8 66 fe ff ff       	call   8070a0 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  80723a:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  80723d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807240:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  807243:	7d 05                	jge    80724a <ip_reass_remove_oldest_datagram+0x88>
  807245:	83 fb 01             	cmp    $0x1,%ebx
  807248:	7f 8d                	jg     8071d7 <ip_reass_remove_oldest_datagram+0x15>
  return pbufs_freed;
}
  80724a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80724d:	83 c4 1c             	add    $0x1c,%esp
  807250:	5b                   	pop    %ebx
  807251:	5e                   	pop    %esi
  807252:	5f                   	pop    %edi
  807253:	5d                   	pop    %ebp
  807254:	c3                   	ret    

00807255 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  807255:	55                   	push   %ebp
  807256:	89 e5                	mov    %esp,%ebp
  807258:	56                   	push   %esi
  807259:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80725a:	a1 00 5a b3 00       	mov    0xb35a00,%eax
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  80725f:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
  807264:	eb 1f                	jmp    807285 <ip_reass_tmr+0x30>
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  807266:	0f b6 48 1f          	movzbl 0x1f(%eax),%ecx
  80726a:	84 c9                	test   %cl,%cl
  80726c:	74 0c                	je     80727a <ip_reass_tmr+0x25>
      r->timer--;
  80726e:	83 e9 01             	sub    $0x1,%ecx
  807271:	88 48 1f             	mov    %cl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
  807274:	89 c3                	mov    %eax,%ebx
      r = r->next;
  807276:	8b 00                	mov    (%eax),%eax
  807278:	eb 0b                	jmp    807285 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80727a:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80727c:	89 da                	mov    %ebx,%edx
  80727e:	e8 1d fe ff ff       	call   8070a0 <ip_reass_free_complete_datagram>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  807283:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  807285:	85 c0                	test   %eax,%eax
  807287:	75 dd                	jne    807266 <ip_reass_tmr+0x11>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  807289:	5b                   	pop    %ebx
  80728a:	5e                   	pop    %esi
  80728b:	5d                   	pop    %ebp
  80728c:	c3                   	ret    

0080728d <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80728d:	55                   	push   %ebp
  80728e:	89 e5                	mov    %esp,%ebp
  807290:	57                   	push   %edi
  807291:	56                   	push   %esi
  807292:	53                   	push   %ebx
  807293:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  807296:	8b 45 08             	mov    0x8(%ebp),%eax
  807299:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80729c:	0f b7 03             	movzwl (%ebx),%eax
  80729f:	89 04 24             	mov    %eax,(%esp)
  8072a2:	e8 0c 0b 00 00       	call   807db3 <ntohs>
  8072a7:	66 c1 e8 08          	shr    $0x8,%ax
  8072ab:	83 e0 0f             	and    $0xf,%eax
  8072ae:	83 f8 05             	cmp    $0x5,%eax
  8072b1:	0f 85 14 04 00 00    	jne    8076cb <ip_reass+0x43e>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  8072b7:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8072bb:	89 04 24             	mov    %eax,(%esp)
  8072be:	e8 f0 0a 00 00       	call   807db3 <ntohs>
  8072c3:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8072c7:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  8072cb:	89 04 24             	mov    %eax,(%esp)
  8072ce:	e8 e0 0a 00 00       	call   807db3 <ntohs>
  8072d3:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  8072d7:	0f b7 03             	movzwl (%ebx),%eax
  8072da:	89 04 24             	mov    %eax,(%esp)
  8072dd:	e8 d1 0a 00 00       	call   807db3 <ntohs>
  8072e2:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  8072e6:	8b 45 08             	mov    0x8(%ebp),%eax
  8072e9:	89 04 24             	mov    %eax,(%esp)
  8072ec:	e8 c9 df ff ff       	call   8052ba <pbuf_clen>
  8072f1:	88 45 e4             	mov    %al,-0x1c(%ebp)
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  8072f4:	0f b6 f0             	movzbl %al,%esi
  8072f7:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  8072fe:	01 f0                	add    %esi,%eax
  807300:	83 f8 0a             	cmp    $0xa,%eax
  807303:	7e 23                	jle    807328 <ip_reass+0x9b>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  807305:	89 f2                	mov    %esi,%edx
  807307:	89 d8                	mov    %ebx,%eax
  807309:	e8 b4 fe ff ff       	call   8071c2 <ip_reass_remove_oldest_datagram>
  80730e:	85 c0                	test   %eax,%eax
  807310:	0f 84 b5 03 00 00    	je     8076cb <ip_reass+0x43e>
        ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS))
  807316:	0f b7 05 fc 59 b3 00 	movzwl 0xb359fc,%eax
  80731d:	01 f0                	add    %esi,%eax

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  80731f:	83 f8 0a             	cmp    $0xa,%eax
  807322:	0f 8f a3 03 00 00    	jg     8076cb <ip_reass+0x43e>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  807328:	8b 3d 00 5a b3 00    	mov    0xb35a00,%edi
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  80732e:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  807333:	eb 1e                	jmp    807353 <ip_reass+0xc6>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  807335:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  807338:	39 4f 14             	cmp    %ecx,0x14(%edi)
  80733b:	75 12                	jne    80734f <ip_reass+0xc2>
  80733d:	8b 53 10             	mov    0x10(%ebx),%edx
  807340:	39 57 18             	cmp    %edx,0x18(%edi)
  807343:	75 0a                	jne    80734f <ip_reass+0xc2>
  807345:	0f b7 4b 04          	movzwl 0x4(%ebx),%ecx
  807349:	66 39 4f 0c          	cmp    %cx,0xc(%edi)
  80734d:	74 4d                	je     80739c <ip_reass+0x10f>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80734f:	89 f8                	mov    %edi,%eax
  807351:	8b 3f                	mov    (%edi),%edi
  807353:	85 ff                	test   %edi,%edi
  807355:	75 de                	jne    807335 <ip_reass+0xa8>
  807357:	89 45 e0             	mov    %eax,-0x20(%ebp)
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80735a:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807361:	e8 ac d6 ff ff       	call   804a12 <memp_malloc>
  807366:	89 c7                	mov    %eax,%edi
  if (ipr == NULL) {
  807368:	85 c0                	test   %eax,%eax
  80736a:	0f 85 05 04 00 00    	jne    807775 <ip_reass+0x4e8>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  807370:	89 f2                	mov    %esi,%edx
  807372:	89 d8                	mov    %ebx,%eax
  807374:	e8 49 fe ff ff       	call   8071c2 <ip_reass_remove_oldest_datagram>
  807379:	39 c6                	cmp    %eax,%esi
  80737b:	0f 8f 4a 03 00 00    	jg     8076cb <ip_reass+0x43e>
      ipr = memp_malloc(MEMP_REASSDATA);
  807381:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  807388:	e8 85 d6 ff ff       	call   804a12 <memp_malloc>
  80738d:	89 c7                	mov    %eax,%edi
    }
    if (ipr == NULL)
  80738f:	85 c0                	test   %eax,%eax
  807391:	0f 85 de 03 00 00    	jne    807775 <ip_reass+0x4e8>
  807397:	e9 2f 03 00 00       	jmp    8076cb <ip_reass+0x43e>
  80739c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80739f:	89 fe                	mov    %edi,%esi
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8073a1:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8073a5:	89 04 24             	mov    %eax,(%esp)
  8073a8:	e8 06 0a 00 00       	call   807db3 <ntohs>
  8073ad:	66 a9 ff 1f          	test   $0x1fff,%ax
  8073b1:	75 29                	jne    8073dc <ip_reass+0x14f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  8073b3:	0f b7 47 0e          	movzwl 0xe(%edi),%eax
  8073b7:	89 04 24             	mov    %eax,(%esp)
  8073ba:	e8 f4 09 00 00       	call   807db3 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  8073bf:	66 a9 ff 1f          	test   $0x1fff,%ax
  8073c3:	74 17                	je     8073dc <ip_reass+0x14f>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  8073c5:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8073cc:	00 
  8073cd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8073d1:	83 c6 08             	add    $0x8,%esi
  8073d4:	89 34 24             	mov    %esi,(%esp)
  8073d7:	e8 e0 85 00 00       	call   80f9bc <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  8073dc:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  8073e0:	66 01 05 fc 59 b3 00 	add    %ax,0xb359fc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  8073e7:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  8073eb:	89 04 24             	mov    %eax,(%esp)
  8073ee:	e8 c0 09 00 00       	call   807db3 <ntohs>
  8073f3:	f6 c4 20             	test   $0x20,%ah
  8073f6:	75 20                	jne    807418 <ip_reass+0x18b>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  8073f8:	80 4f 1e 01          	orb    $0x1,0x1e(%edi)
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  8073fc:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  807400:	0f b7 75 da          	movzwl -0x26(%ebp),%esi
  807404:	8d 04 c6             	lea    (%esi,%eax,8),%eax
  807407:	0f b7 55 d4          	movzwl -0x2c(%ebp),%edx
  80740b:	66 c1 ea 06          	shr    $0x6,%dx
  80740f:	83 e2 3c             	and    $0x3c,%edx
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  807412:	29 d0                	sub    %edx,%eax
  807414:	66 89 47 1c          	mov    %ax,0x1c(%edi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  807418:	8b 45 08             	mov    0x8(%ebp),%eax
  80741b:	8b 58 04             	mov    0x4(%eax),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80741e:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  807422:	89 04 24             	mov    %eax,(%esp)
  807425:	e8 89 09 00 00       	call   807db3 <ntohs>
  80742a:	89 c6                	mov    %eax,%esi
  80742c:	0f b7 03             	movzwl (%ebx),%eax
  80742f:	89 04 24             	mov    %eax,(%esp)
  807432:	e8 7c 09 00 00       	call   807db3 <ntohs>
  807437:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80743b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80743f:	89 04 24             	mov    %eax,(%esp)
  807442:	e8 6c 09 00 00       	call   807db3 <ntohs>
  807447:	8d 1c c5 00 00 00 00 	lea    0x0(,%eax,8),%ebx
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80744e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807451:	8b 51 04             	mov    0x4(%ecx),%edx
  807454:	89 55 dc             	mov    %edx,-0x24(%ebp)
  iprh->next_pbuf = NULL;
  807457:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80745d:	66 89 5a 04          	mov    %bx,0x4(%edx)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  807461:	01 de                	add    %ebx,%esi
  807463:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807467:	66 c1 e8 06          	shr    $0x6,%ax
  80746b:	83 e0 3c             	and    $0x3c,%eax
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  80746e:	29 c6                	sub    %eax,%esi
  807470:	66 89 75 da          	mov    %si,-0x26(%ebp)
  807474:	66 89 72 06          	mov    %si,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  807478:	8b 47 04             	mov    0x4(%edi),%eax
  80747b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  80747e:	b9 01 00 00 00       	mov    $0x1,%ecx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  807483:	be 00 00 00 00       	mov    $0x0,%esi
  807488:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80748b:	89 cf                	mov    %ecx,%edi
  80748d:	eb 6f                	jmp    8074fe <ip_reass+0x271>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80748f:	8b 50 04             	mov    0x4(%eax),%edx
    if (iprh->start < iprh_tmp->start) {
  807492:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  807496:	66 39 cb             	cmp    %cx,%bx
  807499:	73 3c                	jae    8074d7 <ip_reass+0x24a>
  80749b:	89 7d d0             	mov    %edi,-0x30(%ebp)
  80749e:	8b 7d e4             	mov    -0x1c(%ebp),%edi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  8074a1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  8074a4:	89 01                	mov    %eax,(%ecx)
      if (iprh_prev != NULL) {
  8074a6:	85 f6                	test   %esi,%esi
  8074a8:	74 22                	je     8074cc <ip_reass+0x23f>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  8074aa:	66 3b 5e 06          	cmp    0x6(%esi),%bx
  8074ae:	0f 82 92 01 00 00    	jb     807646 <ip_reass+0x3b9>
  8074b4:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  8074b8:	66 3b 42 04          	cmp    0x4(%edx),%ax
  8074bc:	0f 87 84 01 00 00    	ja     807646 <ip_reass+0x3b9>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  8074c2:	8b 45 08             	mov    0x8(%ebp),%eax
  8074c5:	89 06                	mov    %eax,(%esi)
  8074c7:	e9 a0 00 00 00       	jmp    80756c <ip_reass+0x2df>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  8074cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8074cf:	89 47 04             	mov    %eax,0x4(%edi)
  8074d2:	e9 95 00 00 00       	jmp    80756c <ip_reass+0x2df>
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  8074d7:	66 39 cb             	cmp    %cx,%bx
  8074da:	0f 84 66 01 00 00    	je     807646 <ip_reass+0x3b9>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  8074e0:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  8074e4:	0f 82 5c 01 00 00    	jb     807646 <ip_reass+0x3b9>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  8074ea:	85 f6                	test   %esi,%esi
  8074ec:	74 0c                	je     8074fa <ip_reass+0x26d>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  8074ee:	66 3b 4e 06          	cmp    0x6(%esi),%cx
  8074f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8074f7:	0f 45 f8             	cmovne %eax,%edi
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  8074fa:	8b 02                	mov    (%edx),%eax
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  8074fc:	89 d6                	mov    %edx,%esi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  8074fe:	85 c0                	test   %eax,%eax
  807500:	75 8d                	jne    80748f <ip_reass+0x202>
  807502:	e9 d9 01 00 00       	jmp    8076e0 <ip_reass+0x453>
  if (q == NULL) {
    if (iprh_prev != NULL) {
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  807507:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  80750b:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80750e:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  807512:	76 1c                	jbe    807530 <ip_reass+0x2a3>
  807514:	c7 44 24 08 b8 2f 81 	movl   $0x812fb8,0x8(%esp)
  80751b:	00 
  80751c:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  807523:	00 
  807524:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  80752b:	e8 6a 7b 00 00       	call   80f09a <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  807530:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807533:	89 0e                	mov    %ecx,(%esi)
      if (iprh_prev->end != iprh->start) {
  807535:	8b 75 dc             	mov    -0x24(%ebp),%esi
  807538:	66 3b 46 04          	cmp    0x4(%esi),%ax
  80753c:	0f 85 c3 01 00 00    	jne    807705 <ip_reass+0x478>
  807542:	eb 28                	jmp    80756c <ip_reass+0x2df>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  807544:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  807548:	74 1c                	je     807566 <ip_reass+0x2d9>
  80754a:	c7 44 24 08 e4 2f 81 	movl   $0x812fe4,0x8(%esp)
  807551:	00 
  807552:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  807559:	00 
  80755a:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  807561:	e8 34 7b 00 00       	call   80f09a <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  807566:	8b 45 08             	mov    0x8(%ebp),%eax
  807569:	89 47 04             	mov    %eax,0x4(%edi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80756c:	f6 47 1e 01          	testb  $0x1,0x1e(%edi)
  807570:	0f 84 8f 01 00 00    	je     807705 <ip_reass+0x478>
    /* and had no wholes so far */
    if (valid) {
  807576:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80757a:	0f 84 85 01 00 00    	je     807705 <ip_reass+0x478>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  807580:	8b 4f 04             	mov    0x4(%edi),%ecx
  807583:	8b 59 04             	mov    0x4(%ecx),%ebx
  807586:	66 83 7b 04 00       	cmpw   $0x0,0x4(%ebx)
  80758b:	0f 85 74 01 00 00    	jne    807705 <ip_reass+0x478>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  807591:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807594:	8b 10                	mov    (%eax),%edx
  807596:	89 c6                	mov    %eax,%esi
  807598:	eb 15                	jmp    8075af <ip_reass+0x322>
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80759a:	8b 42 04             	mov    0x4(%edx),%eax
          if (iprh_prev->end != iprh->start) {
  80759d:	0f b7 50 04          	movzwl 0x4(%eax),%edx
  8075a1:	66 39 56 06          	cmp    %dx,0x6(%esi)
  8075a5:	0f 85 5a 01 00 00    	jne    807705 <ip_reass+0x478>
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  8075ab:	8b 10                	mov    (%eax),%edx
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  8075ad:	89 c6                	mov    %eax,%esi
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  8075af:	85 d2                	test   %edx,%edx
  8075b1:	75 e7                	jne    80759a <ip_reass+0x30d>
  8075b3:	e9 3b 01 00 00       	jmp    8076f3 <ip_reass+0x466>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8075b8:	c7 44 24 08 d6 2f 81 	movl   $0x812fd6,0x8(%esp)
  8075bf:	00 
  8075c0:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  8075c7:	00 
  8075c8:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  8075cf:	e8 c6 7a 00 00       	call   80f09a <_panic>
          LWIP_ASSERT("sanity check",
  8075d4:	3b 5d dc             	cmp    -0x24(%ebp),%ebx
  8075d7:	75 1c                	jne    8075f5 <ip_reass+0x368>
  8075d9:	c7 44 24 08 d6 2f 81 	movl   $0x812fd6,0x8(%esp)
  8075e0:	00 
  8075e1:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  8075e8:	00 
  8075e9:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  8075f0:	e8 a5 7a 00 00       	call   80f09a <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  8075f5:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8075f8:	83 38 00             	cmpl   $0x0,(%eax)
  8075fb:	74 1c                	je     807619 <ip_reass+0x38c>
  8075fd:	c7 44 24 08 1c 30 81 	movl   $0x81301c,0x8(%esp)
  807604:	00 
  807605:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80760c:	00 
  80760d:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  807614:	e8 81 7a 00 00       	call   80f09a <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  807619:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80761c:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  807620:	66 3b 47 1c          	cmp    0x1c(%edi),%ax
  807624:	0f 84 e5 00 00 00    	je     80770f <ip_reass+0x482>
  80762a:	c7 44 24 08 40 30 81 	movl   $0x813040,0x8(%esp)
  807631:	00 
  807632:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  807639:	00 
  80763a:	c7 04 24 62 2f 81 00 	movl   $0x812f62,(%esp)
  807641:	e8 54 7a 00 00       	call   80f09a <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  807646:	0f b7 1d fc 59 b3 00 	movzwl 0xb359fc,%ebx
  80764d:	8b 45 08             	mov    0x8(%ebp),%eax
  807650:	89 04 24             	mov    %eax,(%esp)
  807653:	e8 62 dc ff ff       	call   8052ba <pbuf_clen>
  807658:	0f b6 c0             	movzbl %al,%eax
  80765b:	29 c3                	sub    %eax,%ebx
  80765d:	66 89 1d fc 59 b3 00 	mov    %bx,0xb359fc
  pbuf_free(new_p);
  807664:	8b 45 08             	mov    0x8(%ebp),%eax
  807667:	89 04 24             	mov    %eax,(%esp)
  80766a:	e8 b5 d7 ff ff       	call   804e24 <pbuf_free>
  80766f:	e9 91 00 00 00       	jmp    807705 <ip_reass+0x478>

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  807674:	8b 73 04             	mov    0x4(%ebx),%esi

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  807677:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80767e:	ff 
  80767f:	89 1c 24             	mov    %ebx,(%esp)
  807682:	e8 b9 d6 ff ff       	call   804d40 <pbuf_header>
      pbuf_cat(p, r);
  807687:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80768b:	89 3c 24             	mov    %edi,(%esp)
  80768e:	e8 50 dc ff ff       	call   8052e3 <pbuf_cat>
      r = iprh->next_pbuf;
  807693:	8b 1e                	mov    (%esi),%ebx
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807695:	85 db                	test   %ebx,%ebx
  807697:	75 db                	jne    807674 <ip_reass+0x3e7>
  807699:	8b 7d dc             	mov    -0x24(%ebp),%edi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80769c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80769f:	89 f8                	mov    %edi,%eax
  8076a1:	e8 aa f9 ff ff       	call   807050 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  8076a6:	0f b7 1d fc 59 b3 00 	movzwl 0xb359fc,%ebx
  8076ad:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8076b0:	89 34 24             	mov    %esi,(%esp)
  8076b3:	e8 02 dc ff ff       	call   8052ba <pbuf_clen>
  8076b8:	0f b6 c0             	movzbl %al,%eax
  8076bb:	29 c3                	sub    %eax,%ebx
  8076bd:	66 89 1d fc 59 b3 00 	mov    %bx,0xb359fc

    /* Return the pbuf chain */
    return p;
  8076c4:	89 f0                	mov    %esi,%eax
  8076c6:	e9 ef 00 00 00       	jmp    8077ba <ip_reass+0x52d>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  8076cb:	8b 45 08             	mov    0x8(%ebp),%eax
  8076ce:	89 04 24             	mov    %eax,(%esp)
  8076d1:	e8 4e d7 ff ff       	call   804e24 <pbuf_free>
  return NULL;
  8076d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8076db:	e9 da 00 00 00       	jmp    8077ba <ip_reass+0x52d>
  8076e0:	89 7d d0             	mov    %edi,-0x30(%ebp)
  8076e3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  8076e6:	85 f6                	test   %esi,%esi
  8076e8:	0f 85 19 fe ff ff    	jne    807507 <ip_reass+0x27a>
  8076ee:	e9 51 fe ff ff       	jmp    807544 <ip_reass+0x2b7>
  8076f3:	89 75 dc             	mov    %esi,-0x24(%ebp)
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  8076f6:	85 c9                	test   %ecx,%ecx
  8076f8:	0f 85 d6 fe ff ff    	jne    8075d4 <ip_reass+0x347>
  8076fe:	66 90                	xchg   %ax,%ax
  807700:	e9 b3 fe ff ff       	jmp    8075b8 <ip_reass+0x32b>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  807705:	b8 00 00 00 00       	mov    $0x0,%eax
  80770a:	e9 ab 00 00 00       	jmp    8077ba <ip_reass+0x52d>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80770f:	83 c0 14             	add    $0x14,%eax
  807712:	66 89 47 1c          	mov    %ax,0x1c(%edi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  807716:	8b 47 04             	mov    0x4(%edi),%eax
  807719:	8b 70 04             	mov    0x4(%eax),%esi
  80771c:	8b 1e                	mov    (%esi),%ebx

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80771e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807725:	00 
  807726:	8d 47 08             	lea    0x8(%edi),%eax
  807729:	89 44 24 04          	mov    %eax,0x4(%esp)
  80772d:	89 34 24             	mov    %esi,(%esp)
  807730:	e8 87 82 00 00       	call   80f9bc <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  807735:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  807739:	89 04 24             	mov    %eax,(%esp)
  80773c:	e8 65 06 00 00       	call   807da6 <htons>
  807741:	66 89 46 02          	mov    %ax,0x2(%esi)
    IPH_OFFSET_SET(fraghdr, 0);
  807745:	66 c7 46 06 00 00    	movw   $0x0,0x6(%esi)
    IPH_CHKSUM_SET(fraghdr, 0);
  80774b:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  807751:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807758:	00 
  807759:	89 34 24             	mov    %esi,(%esp)
  80775c:	e8 f0 04 00 00       	call   807c51 <inet_chksum>
  807761:	66 89 46 0a          	mov    %ax,0xa(%esi)

    p = ipr->p;
  807765:	8b 47 04             	mov    0x4(%edi),%eax
  807768:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80776b:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80776e:	89 c7                	mov    %eax,%edi

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  807770:	e9 20 ff ff ff       	jmp    807695 <ip_reass+0x408>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  807775:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80777c:	00 
  80777d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807784:	00 
  807785:	89 3c 24             	mov    %edi,(%esp)
  807788:	e8 7a 81 00 00       	call   80f907 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80778d:	c6 47 1f 03          	movb   $0x3,0x1f(%edi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  807791:	a1 00 5a b3 00       	mov    0xb35a00,%eax
  807796:	89 07                	mov    %eax,(%edi)
  reassdatagrams = ipr;
  807798:	89 3d 00 5a b3 00    	mov    %edi,0xb35a00
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80779e:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  8077a5:	00 
  8077a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8077aa:	8d 47 08             	lea    0x8(%edi),%eax
  8077ad:	89 04 24             	mov    %eax,(%esp)
  8077b0:	e8 07 82 00 00       	call   80f9bc <memcpy>
  8077b5:	e9 22 fc ff ff       	jmp    8073dc <ip_reass+0x14f>
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  8077ba:	83 c4 3c             	add    $0x3c,%esp
  8077bd:	5b                   	pop    %ebx
  8077be:	5e                   	pop    %esi
  8077bf:	5f                   	pop    %edi
  8077c0:	5d                   	pop    %ebp
  8077c1:	c3                   	ret    

008077c2 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  8077c2:	55                   	push   %ebp
  8077c3:	89 e5                	mov    %esp,%ebp
  8077c5:	57                   	push   %edi
  8077c6:	56                   	push   %esi
  8077c7:	53                   	push   %ebx
  8077c8:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  8077cb:	8b 45 0c             	mov    0xc(%ebp),%eax
  8077ce:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  8077d2:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8077d9:	00 
  8077da:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8077e1:	00 
  8077e2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8077e9:	e8 17 d7 ff ff       	call   804f05 <pbuf_alloc>
  8077ee:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (rambuf == NULL) {
  8077f1:	89 c1                	mov    %eax,%ecx
  8077f3:	85 c0                	test   %eax,%eax
  8077f5:	0f 84 d2 01 00 00    	je     8079cd <ip_frag+0x20b>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  8077fb:	66 89 70 0a          	mov    %si,0xa(%eax)
  8077ff:	66 89 70 08          	mov    %si,0x8(%eax)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  807803:	b8 23 54 b3 00       	mov    $0xb35423,%eax
  807808:	83 e0 fc             	and    $0xfffffffc,%eax
  80780b:	89 c3                	mov    %eax,%ebx
  80780d:	89 59 04             	mov    %ebx,0x4(%ecx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  807810:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  807817:	00 
  807818:	8b 45 08             	mov    0x8(%ebp),%eax
  80781b:	8b 40 04             	mov    0x4(%eax),%eax
  80781e:	89 44 24 04          	mov    %eax,0x4(%esp)
  807822:	89 1c 24             	mov    %ebx,(%esp)
  807825:	e8 92 81 00 00       	call   80f9bc <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80782a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80782e:	89 04 24             	mov    %eax,(%esp)
  807831:	e8 7d 05 00 00       	call   807db3 <ntohs>
  ofo = tmp & IP_OFFMASK;
  807836:	89 c1                	mov    %eax,%ecx
  807838:	66 81 e1 ff 1f       	and    $0x1fff,%cx
  80783d:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  omf = tmp & IP_MF;
  807841:	66 25 00 20          	and    $0x2000,%ax
  807845:	66 89 45 da          	mov    %ax,-0x26(%ebp)

  left = p->tot_len - IP_HLEN;
  807849:	8b 45 08             	mov    0x8(%ebp),%eax
  80784c:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807850:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  807854:	83 e8 14             	sub    $0x14,%eax
  807857:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

  nfb = (mtu - IP_HLEN) / 8;
  80785b:	0f b7 d6             	movzwl %si,%edx
  80785e:	8d 42 f3             	lea    -0xd(%edx),%eax
  807861:	83 ea 14             	sub    $0x14,%edx
  807864:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  807867:	0f 49 c2             	cmovns %edx,%eax
  80786a:	c1 f8 03             	sar    $0x3,%eax
  80786d:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  807871:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  807877:	c1 e0 03             	shl    $0x3,%eax
  80787a:	66 89 45 ce          	mov    %ax,-0x32(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80787e:	8d 43 14             	lea    0x14(%ebx),%eax
  807881:	89 45 d0             	mov    %eax,-0x30(%ebp)

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  807884:	e9 27 01 00 00       	jmp    8079b0 <ip_frag+0x1ee>
    last = (left <= mtu - IP_HLEN);
  807889:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
  80788d:	0f b7 c1             	movzwl %cx,%eax
  807890:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  807893:	0f 9d c0             	setge  %al
  807896:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  807899:	0f b7 7d e0          	movzwl -0x20(%ebp),%edi
  80789d:	66 81 e7 ff 1f       	and    $0x1fff,%di
  8078a2:	66 0b 7d da          	or     -0x26(%ebp),%di
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8078a6:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  while (left) {
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
  8078aa:	66 85 f6             	test   %si,%si
  8078ad:	75 0d                	jne    8078bc <ip_frag+0xfa>
      tmp = tmp | IP_MF;
  8078af:	66 81 cf 00 20       	or     $0x2000,%di

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  8078b4:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  8078b8:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  8078bc:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  8078c0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8078c4:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8078c8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8078cc:	8b 55 d0             	mov    -0x30(%ebp),%edx
  8078cf:	89 54 24 04          	mov    %edx,0x4(%esp)
  8078d3:	8b 55 08             	mov    0x8(%ebp),%edx
  8078d6:	89 14 24             	mov    %edx,(%esp)
  8078d9:	e8 f1 dc ff ff       	call   8055cf <pbuf_copy_partial>
  8078de:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  8078e2:	0f b7 ff             	movzwl %di,%edi
  8078e5:	89 3c 24             	mov    %edi,(%esp)
  8078e8:	e8 b9 04 00 00       	call   807da6 <htons>
  8078ed:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  8078f1:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8078f5:	83 c0 14             	add    $0x14,%eax
  8078f8:	0f b7 c0             	movzwl %ax,%eax
  8078fb:	89 04 24             	mov    %eax,(%esp)
  8078fe:	e8 a3 04 00 00       	call   807da6 <htons>
  807903:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  807907:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80790d:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  807914:	00 
  807915:	89 1c 24             	mov    %ebx,(%esp)
  807918:	e8 34 03 00 00       	call   807c51 <inet_chksum>
  80791d:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  807921:	66 85 f6             	test   %si,%si
  807924:	74 19                	je     80793f <ip_frag+0x17d>
      pbuf_realloc(rambuf, left + IP_HLEN);
  807926:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80792a:	83 c0 14             	add    $0x14,%eax
  80792d:	0f b7 c0             	movzwl %ax,%eax
  807930:	89 44 24 04          	mov    %eax,0x4(%esp)
  807934:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807937:	89 04 24             	mov    %eax,(%esp)
  80793a:	e8 57 d8 ff ff       	call   805196 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  80793f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  807946:	00 
  807947:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80794e:	00 
  80794f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  807956:	e8 aa d5 ff ff       	call   804f05 <pbuf_alloc>
  80795b:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  80795d:	85 c0                	test   %eax,%eax
  80795f:	74 3d                	je     80799e <ip_frag+0x1dc>
      pbuf_chain(header, rambuf);
  807961:	8b 45 dc             	mov    -0x24(%ebp),%eax
  807964:	89 44 24 04          	mov    %eax,0x4(%esp)
  807968:	89 34 24             	mov    %esi,(%esp)
  80796b:	e8 ea d9 ff ff       	call   80535a <pbuf_chain>
      netif->output(netif, header, dest);
  807970:	8b 45 10             	mov    0x10(%ebp),%eax
  807973:	89 44 24 08          	mov    %eax,0x8(%esp)
  807977:	89 74 24 04          	mov    %esi,0x4(%esp)
  80797b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80797e:	89 04 24             	mov    %eax,(%esp)
  807981:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  807984:	89 34 24             	mov    %esi,(%esp)
  807987:	e8 98 d4 ff ff       	call   804e24 <pbuf_free>
     * there will be zero memory penalty.
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
  80798c:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807990:	66 29 45 e4          	sub    %ax,-0x1c(%ebp)
    ofo += nfb;
  807994:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807998:	66 01 45 e0          	add    %ax,-0x20(%ebp)
  80799c:	eb 12                	jmp    8079b0 <ip_frag+0x1ee>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80799e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8079a1:	89 04 24             	mov    %eax,(%esp)
  8079a4:	e8 7b d4 ff ff       	call   804e24 <pbuf_free>
      return ERR_MEM;
  8079a9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8079ae:	eb 22                	jmp    8079d2 <ip_frag+0x210>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  8079b0:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  8079b5:	0f 85 ce fe ff ff    	jne    807889 <ip_frag+0xc7>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  8079bb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8079be:	89 04 24             	mov    %eax,(%esp)
  8079c1:	e8 5e d4 ff ff       	call   804e24 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  8079c6:	b8 00 00 00 00       	mov    $0x0,%eax
  8079cb:	eb 05                	jmp    8079d2 <ip_frag+0x210>
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  8079cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  8079d2:	83 c4 3c             	add    $0x3c,%esp
  8079d5:	5b                   	pop    %ebx
  8079d6:	5e                   	pop    %esi
  8079d7:	5f                   	pop    %edi
  8079d8:	5d                   	pop    %ebp
  8079d9:	c3                   	ret    

008079da <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  8079da:	55                   	push   %ebp
  8079db:	89 e5                	mov    %esp,%ebp
  8079dd:	57                   	push   %edi
  8079de:	56                   	push   %esi
  8079df:	53                   	push   %ebx
  8079e0:	83 ec 1c             	sub    $0x1c,%esp
  8079e3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8079e6:	89 d1                	mov    %edx,%ecx
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  8079e8:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  8079ed:	eb 17                	jmp    807a06 <lwip_standard_chksum+0x2c>
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  8079ef:	0f b6 30             	movzbl (%eax),%esi
  8079f2:	c1 e6 08             	shl    $0x8,%esi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  8079f5:	0f b6 78 01          	movzbl 0x1(%eax),%edi
  8079f9:	09 fe                	or     %edi,%esi
  8079fb:	83 c0 02             	add    $0x2,%eax
    octetptr++;
    acc += src;
  8079fe:	0f b7 f6             	movzwl %si,%esi
  807a01:	01 f3                	add    %esi,%ebx
    len -= 2;
  807a03:	83 e9 02             	sub    $0x2,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  807a06:	66 83 f9 01          	cmp    $0x1,%cx
  807a0a:	77 e3                	ja     8079ef <lwip_standard_chksum+0x15>
  807a0c:	89 d0                	mov    %edx,%eax
  807a0e:	66 d1 e8             	shr    %ax
  807a11:	0f b7 c8             	movzwl %ax,%ecx
  807a14:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  807a17:	8d 0c 4f             	lea    (%edi,%ecx,2),%ecx
  807a1a:	f7 d8                	neg    %eax
  807a1c:	8d 14 42             	lea    (%edx,%eax,2),%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  807a1f:	66 85 d2             	test   %dx,%dx
  807a22:	74 0b                	je     807a2f <lwip_standard_chksum+0x55>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  807a24:	0f b6 01             	movzbl (%ecx),%eax
  807a27:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  807a2a:	0f b7 c0             	movzwl %ax,%eax
  807a2d:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807a2f:	89 d8                	mov    %ebx,%eax
  807a31:	c1 e8 10             	shr    $0x10,%eax
  807a34:	0f b7 db             	movzwl %bx,%ebx
  807a37:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  807a39:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  807a3f:	74 0a                	je     807a4b <lwip_standard_chksum+0x71>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  807a41:	89 d8                	mov    %ebx,%eax
  807a43:	c1 e8 10             	shr    $0x10,%eax
  807a46:	0f b7 db             	movzwl %bx,%ebx
  807a49:	01 c3                	add    %eax,%ebx
  807a4b:	0f b7 db             	movzwl %bx,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  807a4e:	89 1c 24             	mov    %ebx,(%esp)
  807a51:	e8 50 03 00 00       	call   807da6 <htons>
}
  807a56:	83 c4 1c             	add    $0x1c,%esp
  807a59:	5b                   	pop    %ebx
  807a5a:	5e                   	pop    %esi
  807a5b:	5f                   	pop    %edi
  807a5c:	5d                   	pop    %ebp
  807a5d:	c3                   	ret    

00807a5e <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  807a5e:	55                   	push   %ebp
  807a5f:	89 e5                	mov    %esp,%ebp
  807a61:	57                   	push   %edi
  807a62:	56                   	push   %esi
  807a63:	53                   	push   %ebx
  807a64:	83 ec 1c             	sub    $0x1c,%esp
  807a67:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807a6a:	8b 45 14             	mov    0x14(%ebp),%eax
  807a6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807a70:	8b 45 18             	mov    0x18(%ebp),%eax
  807a73:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807a76:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807a7b:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807a80:	eb 3d                	jmp    807abf <inet_chksum_pseudo+0x61>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  807a82:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807a86:	8b 43 04             	mov    0x4(%ebx),%eax
  807a89:	e8 4c ff ff ff       	call   8079da <lwip_standard_chksum>
  807a8e:	0f b7 c0             	movzwl %ax,%eax
  807a91:	01 c6                	add    %eax,%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  807a93:	89 f0                	mov    %esi,%eax
  807a95:	c1 e8 10             	shr    $0x10,%eax
  807a98:	0f b7 f6             	movzwl %si,%esi
  807a9b:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807a9d:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807aa1:	74 1a                	je     807abd <inet_chksum_pseudo+0x5f>
      swapped = 1 - swapped;
  807aa3:	b8 01 00 00 00       	mov    $0x1,%eax
  807aa8:	89 f9                	mov    %edi,%ecx
  807aaa:	29 c8                	sub    %ecx,%eax
  807aac:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807aae:	89 f0                	mov    %esi,%eax
  807ab0:	c1 e0 08             	shl    $0x8,%eax
  807ab3:	0f b7 c0             	movzwl %ax,%eax
  807ab6:	89 f1                	mov    %esi,%ecx
  807ab8:	0f b6 f5             	movzbl %ch,%esi
  807abb:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  807abd:	8b 1b                	mov    (%ebx),%ebx
  807abf:	85 db                	test   %ebx,%ebx
  807ac1:	75 bf                	jne    807a82 <inet_chksum_pseudo+0x24>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807ac3:	89 f8                	mov    %edi,%eax
  807ac5:	84 c0                	test   %al,%al
  807ac7:	74 0f                	je     807ad8 <inet_chksum_pseudo+0x7a>
    acc = SWAP_BYTES_IN_WORD(acc);
  807ac9:	89 f0                	mov    %esi,%eax
  807acb:	c1 e0 08             	shl    $0x8,%eax
  807ace:	0f b7 c0             	movzwl %ax,%eax
  807ad1:	89 f1                	mov    %esi,%ecx
  807ad3:	0f b6 f5             	movzbl %ch,%esi
  807ad6:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  807ad8:	8b 45 0c             	mov    0xc(%ebp),%eax
  807adb:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807add:	8b 45 10             	mov    0x10(%ebp),%eax
  807ae0:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807ae2:	89 d1                	mov    %edx,%ecx
  807ae4:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807ae7:	0f b7 d2             	movzwl %dx,%edx
  807aea:	01 ca                	add    %ecx,%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807aec:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807aef:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807af1:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807af4:	01 d0                	add    %edx,%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  807af6:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons((u16_t)proto);
  807af8:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  807afc:	89 04 24             	mov    %eax,(%esp)
  807aff:	e8 a2 02 00 00       	call   807da6 <htons>
  807b04:	0f b7 c0             	movzwl %ax,%eax
  807b07:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  807b09:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  807b0d:	89 04 24             	mov    %eax,(%esp)
  807b10:	e8 91 02 00 00       	call   807da6 <htons>
  807b15:	0f b7 c0             	movzwl %ax,%eax
  807b18:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807b1a:	89 f2                	mov    %esi,%edx
  807b1c:	c1 ea 10             	shr    $0x10,%edx
  807b1f:	0f b7 c6             	movzwl %si,%eax
  807b22:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807b24:	89 c2                	mov    %eax,%edx
  807b26:	c1 ea 10             	shr    $0x10,%edx
  807b29:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807b2b:	f7 d0                	not    %eax
}
  807b2d:	83 c4 1c             	add    $0x1c,%esp
  807b30:	5b                   	pop    %ebx
  807b31:	5e                   	pop    %esi
  807b32:	5f                   	pop    %edi
  807b33:	5d                   	pop    %ebp
  807b34:	c3                   	ret    

00807b35 <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  807b35:	55                   	push   %ebp
  807b36:	89 e5                	mov    %esp,%ebp
  807b38:	57                   	push   %edi
  807b39:	56                   	push   %esi
  807b3a:	53                   	push   %ebx
  807b3b:	83 ec 2c             	sub    $0x2c,%esp
  807b3e:	8b 75 08             	mov    0x8(%ebp),%esi
  807b41:	8b 45 14             	mov    0x14(%ebp),%eax
  807b44:	89 45 dc             	mov    %eax,-0x24(%ebp)
  807b47:	8b 45 18             	mov    0x18(%ebp),%eax
  807b4a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  807b4d:	0f b7 5d 1c          	movzwl 0x1c(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  807b51:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  807b55:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807b5c:	eb 73                	jmp    807bd1 <inet_chksum_pseudo_partial+0x9c>
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  807b5e:	0f b7 7e 0a          	movzwl 0xa(%esi),%edi
  807b62:	66 39 fb             	cmp    %di,%bx
  807b65:	0f 46 fb             	cmovbe %ebx,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  807b68:	0f b7 d7             	movzwl %di,%edx
  807b6b:	8b 46 04             	mov    0x4(%esi),%eax
  807b6e:	e8 67 fe ff ff       	call   8079da <lwip_standard_chksum>
  807b73:	0f b7 c0             	movzwl %ax,%eax
  807b76:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
  807b79:	29 fb                	sub    %edi,%ebx
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  807b7b:	66 81 fb fe 7f       	cmp    $0x7ffe,%bx
  807b80:	76 1c                	jbe    807b9e <inet_chksum_pseudo_partial+0x69>
  807b82:	c7 44 24 08 6d 30 81 	movl   $0x81306d,0x8(%esp)
  807b89:	00 
  807b8a:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  807b91:	00 
  807b92:	c7 04 24 78 30 81 00 	movl   $0x813078,(%esp)
  807b99:	e8 fc 74 00 00       	call   80f09a <_panic>
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  807b9e:	89 c2                	mov    %eax,%edx
  807ba0:	c1 ea 10             	shr    $0x10,%edx
  807ba3:	0f b7 c0             	movzwl %ax,%eax
  807ba6:	01 d0                	add    %edx,%eax
  807ba8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  807bab:	f6 46 0a 01          	testb  $0x1,0xa(%esi)
  807baf:	74 1e                	je     807bcf <inet_chksum_pseudo_partial+0x9a>
      swapped = 1 - swapped;
  807bb1:	b8 01 00 00 00       	mov    $0x1,%eax
  807bb6:	2a 45 e3             	sub    -0x1d(%ebp),%al
  807bb9:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  807bbc:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807bbf:	89 c8                	mov    %ecx,%eax
  807bc1:	c1 e0 08             	shl    $0x8,%eax
  807bc4:	0f b7 c0             	movzwl %ax,%eax
  807bc7:	0f b6 d5             	movzbl %ch,%edx
  807bca:	09 c2                	or     %eax,%edx
  807bcc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  807bcf:	8b 36                	mov    (%esi),%esi
  807bd1:	66 85 db             	test   %bx,%bx
  807bd4:	74 04                	je     807bda <inet_chksum_pseudo_partial+0xa5>
  807bd6:	85 f6                	test   %esi,%esi
  807bd8:	75 84                	jne    807b5e <inet_chksum_pseudo_partial+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  807bda:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  807bde:	74 13                	je     807bf3 <inet_chksum_pseudo_partial+0xbe>
    acc = SWAP_BYTES_IN_WORD(acc);
  807be0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807be3:	89 c8                	mov    %ecx,%eax
  807be5:	c1 e0 08             	shl    $0x8,%eax
  807be8:	0f b7 c0             	movzwl %ax,%eax
  807beb:	0f b6 d5             	movzbl %ch,%edx
  807bee:	09 c2                	or     %eax,%edx
  807bf0:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  807bf3:	8b 45 0c             	mov    0xc(%ebp),%eax
  807bf6:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807bf8:	8b 45 10             	mov    0x10(%ebp),%eax
  807bfb:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807bfd:	89 d1                	mov    %edx,%ecx
  807bff:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  807c02:	0f b7 f2             	movzwl %dx,%esi
  807c05:	01 ce                	add    %ecx,%esi
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807c07:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  807c0a:	01 ce                	add    %ecx,%esi
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  807c0c:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  807c0f:	01 c6                	add    %eax,%esi
  acc += ((dest->addr >> 16) & 0xffffUL);
  807c11:	03 75 e4             	add    -0x1c(%ebp),%esi
  acc += (u32_t)htons((u16_t)proto);
  807c14:	0f b6 45 dc          	movzbl -0x24(%ebp),%eax
  807c18:	89 04 24             	mov    %eax,(%esp)
  807c1b:	e8 86 01 00 00       	call   807da6 <htons>
  807c20:	0f b7 d8             	movzwl %ax,%ebx
  807c23:	01 f3                	add    %esi,%ebx
  acc += (u32_t)htons(proto_len);
  807c25:	0f b7 45 d8          	movzwl -0x28(%ebp),%eax
  807c29:	89 04 24             	mov    %eax,(%esp)
  807c2c:	e8 75 01 00 00       	call   807da6 <htons>
  807c31:	0f b7 d0             	movzwl %ax,%edx
  807c34:	01 da                	add    %ebx,%edx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  807c36:	89 d0                	mov    %edx,%eax
  807c38:	c1 e8 10             	shr    $0x10,%eax
  807c3b:	0f b7 d2             	movzwl %dx,%edx
  807c3e:	01 d0                	add    %edx,%eax
  acc = FOLD_U32T(acc);
  807c40:	89 c2                	mov    %eax,%edx
  807c42:	c1 ea 10             	shr    $0x10,%edx
  807c45:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  807c47:	f7 d0                	not    %eax
}
  807c49:	83 c4 2c             	add    $0x2c,%esp
  807c4c:	5b                   	pop    %ebx
  807c4d:	5e                   	pop    %esi
  807c4e:	5f                   	pop    %edi
  807c4f:	5d                   	pop    %ebp
  807c50:	c3                   	ret    

00807c51 <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  807c51:	55                   	push   %ebp
  807c52:	89 e5                	mov    %esp,%ebp
  807c54:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  807c57:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  807c5b:	8b 45 08             	mov    0x8(%ebp),%eax
  807c5e:	e8 77 fd ff ff       	call   8079da <lwip_standard_chksum>
  807c63:	f7 d0                	not    %eax
}
  807c65:	c9                   	leave  
  807c66:	c3                   	ret    

00807c67 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  807c67:	55                   	push   %ebp
  807c68:	89 e5                	mov    %esp,%ebp
  807c6a:	57                   	push   %edi
  807c6b:	56                   	push   %esi
  807c6c:	53                   	push   %ebx
  807c6d:	83 ec 0c             	sub    $0xc,%esp
  807c70:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  807c73:	bf 00 00 00 00       	mov    $0x0,%edi
{
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  807c78:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807c7d:	eb 3d                	jmp    807cbc <inet_chksum_pbuf+0x55>
    acc += LWIP_CHKSUM(q->payload, q->len);
  807c7f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807c83:	8b 43 04             	mov    0x4(%ebx),%eax
  807c86:	e8 4f fd ff ff       	call   8079da <lwip_standard_chksum>
  807c8b:	0f b7 c0             	movzwl %ax,%eax
  807c8e:	01 c6                	add    %eax,%esi
    acc = FOLD_U32T(acc);
  807c90:	89 f0                	mov    %esi,%eax
  807c92:	c1 e8 10             	shr    $0x10,%eax
  807c95:	0f b7 f6             	movzwl %si,%esi
  807c98:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  807c9a:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  807c9e:	74 1a                	je     807cba <inet_chksum_pbuf+0x53>
      swapped = 1 - swapped;
  807ca0:	b8 01 00 00 00       	mov    $0x1,%eax
  807ca5:	89 f9                	mov    %edi,%ecx
  807ca7:	29 c8                	sub    %ecx,%eax
  807ca9:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  807cab:	89 f0                	mov    %esi,%eax
  807cad:	c1 e0 08             	shl    $0x8,%eax
  807cb0:	0f b7 c0             	movzwl %ax,%eax
  807cb3:	89 f1                	mov    %esi,%ecx
  807cb5:	0f b6 f5             	movzbl %ch,%esi
  807cb8:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  807cba:	8b 1b                	mov    (%ebx),%ebx
  807cbc:	85 db                	test   %ebx,%ebx
  807cbe:	75 bf                	jne    807c7f <inet_chksum_pbuf+0x18>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  807cc0:	89 f8                	mov    %edi,%eax
  807cc2:	84 c0                	test   %al,%al
  807cc4:	74 0f                	je     807cd5 <inet_chksum_pbuf+0x6e>
    acc = SWAP_BYTES_IN_WORD(acc);
  807cc6:	89 f0                	mov    %esi,%eax
  807cc8:	c1 e0 08             	shl    $0x8,%eax
  807ccb:	0f b7 c0             	movzwl %ax,%eax
  807cce:	89 f1                	mov    %esi,%ecx
  807cd0:	0f b6 f5             	movzbl %ch,%esi
  807cd3:	09 c6                	or     %eax,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  807cd5:	89 f0                	mov    %esi,%eax
  807cd7:	f7 d0                	not    %eax
}
  807cd9:	83 c4 0c             	add    $0xc,%esp
  807cdc:	5b                   	pop    %ebx
  807cdd:	5e                   	pop    %esi
  807cde:	5f                   	pop    %edi
  807cdf:	5d                   	pop    %ebp
  807ce0:	c3                   	ret    
  807ce1:	66 90                	xchg   %ax,%ax
  807ce3:	66 90                	xchg   %ax,%ax
  807ce5:	66 90                	xchg   %ax,%ax
  807ce7:	66 90                	xchg   %ax,%ax
  807ce9:	66 90                	xchg   %ax,%ax
  807ceb:	66 90                	xchg   %ax,%ax
  807ced:	66 90                	xchg   %ax,%ax
  807cef:	90                   	nop

00807cf0 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  807cf0:	55                   	push   %ebp
  807cf1:	89 e5                	mov    %esp,%ebp
  807cf3:	57                   	push   %edi
  807cf4:	56                   	push   %esi
  807cf5:	53                   	push   %ebx
  807cf6:	83 ec 19             	sub    $0x19,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807cf9:	8b 45 08             	mov    0x8(%ebp),%eax
  807cfc:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807cff:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  807d03:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  807d06:	c7 45 dc 04 5a b3 00 	movl   $0xb35a04,-0x24(%ebp)
 */
char *
inet_ntoa(struct in_addr addr)
{
  static char str[16];
  u32_t s_addr = addr.s_addr;
  807d0d:	be 00 00 00 00       	mov    $0x0,%esi
  807d12:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807d15:	eb 02                	jmp    807d19 <inet_ntoa+0x29>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807d17:	89 ce                	mov    %ecx,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807d19:	8b 7d e0             	mov    -0x20(%ebp),%edi
  807d1c:	0f b6 17             	movzbl (%edi),%edx
      *ap /= (u8_t)10;
  807d1f:	0f b6 c2             	movzbl %dl,%eax
  807d22:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  807d25:	8d 04 c8             	lea    (%eax,%ecx,8),%eax
  807d28:	8d 04 80             	lea    (%eax,%eax,4),%eax
  807d2b:	66 c1 e8 0b          	shr    $0xb,%ax
  807d2f:	88 07                	mov    %al,(%edi)
      inv[i++] = '0' + rem;
  807d31:	8d 4e 01             	lea    0x1(%esi),%ecx
  807d34:	89 f3                	mov    %esi,%ebx
  807d36:	0f b6 f3             	movzbl %bl,%esi
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  807d39:	8d 3c 80             	lea    (%eax,%eax,4),%edi
  807d3c:	01 ff                	add    %edi,%edi
  807d3e:	89 fb                	mov    %edi,%ebx
  807d40:	29 da                	sub    %ebx,%edx
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
  807d42:	83 c2 30             	add    $0x30,%edx
  807d45:	88 54 35 ed          	mov    %dl,-0x13(%ebp,%esi,1)
    } while(*ap);
  807d49:	84 c0                	test   %al,%al
  807d4b:	75 ca                	jne    807d17 <inet_ntoa+0x27>
  807d4d:	8b 55 dc             	mov    -0x24(%ebp),%edx
  807d50:	89 c8                	mov    %ecx,%eax
  807d52:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  807d55:	89 cf                	mov    %ecx,%edi
  807d57:	eb 0d                	jmp    807d66 <inet_ntoa+0x76>
    while(i--)
      *rp++ = inv[i];
  807d59:	0f b6 f0             	movzbl %al,%esi
  807d5c:	0f b6 4c 35 ed       	movzbl -0x13(%ebp,%esi,1),%ecx
  807d61:	88 0a                	mov    %cl,(%edx)
  807d63:	83 c2 01             	add    $0x1,%edx
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  807d66:	83 e8 01             	sub    $0x1,%eax
  807d69:	3c ff                	cmp    $0xff,%al
  807d6b:	75 ec                	jne    807d59 <inet_ntoa+0x69>
  807d6d:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  807d70:	89 f9                	mov    %edi,%ecx
  807d72:	0f b6 c9             	movzbl %cl,%ecx
  807d75:	03 4d dc             	add    -0x24(%ebp),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  807d78:	8d 41 01             	lea    0x1(%ecx),%eax
  807d7b:	89 45 dc             	mov    %eax,-0x24(%ebp)
    ap++;
  807d7e:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  807d82:	80 45 db 01          	addb   $0x1,-0x25(%ebp)
  807d86:	80 7d db 03          	cmpb   $0x3,-0x25(%ebp)
  807d8a:	77 0a                	ja     807d96 <inet_ntoa+0xa6>
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
  807d8c:	c6 01 2e             	movb   $0x2e,(%ecx)
  807d8f:	b9 00 00 00 00       	mov    $0x0,%ecx
  807d94:	eb 81                	jmp    807d17 <inet_ntoa+0x27>
    ap++;
  }
  *--rp = 0;
  807d96:	c6 01 00             	movb   $0x0,(%ecx)
  return str;
}
  807d99:	b8 04 5a b3 00       	mov    $0xb35a04,%eax
  807d9e:	83 c4 19             	add    $0x19,%esp
  807da1:	5b                   	pop    %ebx
  807da2:	5e                   	pop    %esi
  807da3:	5f                   	pop    %edi
  807da4:	5d                   	pop    %ebp
  807da5:	c3                   	ret    

00807da6 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  807da6:	55                   	push   %ebp
  807da7:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807da9:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807dad:	66 c1 c0 08          	rol    $0x8,%ax
}
  807db1:	5d                   	pop    %ebp
  807db2:	c3                   	ret    

00807db3 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  807db3:	55                   	push   %ebp
  807db4:	89 e5                	mov    %esp,%ebp
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  807db6:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  807dba:	66 c1 c0 08          	rol    $0x8,%ax
 */
u16_t
ntohs(u16_t n)
{
  return htons(n);
}
  807dbe:	5d                   	pop    %ebp
  807dbf:	c3                   	ret    

00807dc0 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  807dc0:	55                   	push   %ebp
  807dc1:	89 e5                	mov    %esp,%ebp
  807dc3:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  807dc6:	89 d1                	mov    %edx,%ecx
  807dc8:	c1 e9 18             	shr    $0x18,%ecx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807dcb:	89 d0                	mov    %edx,%eax
  807dcd:	c1 e0 18             	shl    $0x18,%eax
  807dd0:	09 c8                	or     %ecx,%eax
    ((n & 0xff00) << 8) |
  807dd2:	89 d1                	mov    %edx,%ecx
  807dd4:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  807dda:	c1 e1 08             	shl    $0x8,%ecx
  807ddd:	09 c8                	or     %ecx,%eax
    ((n & 0xff0000UL) >> 8) |
  807ddf:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  807de5:	c1 ea 08             	shr    $0x8,%edx
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  return ((n & 0xff) << 24) |
  807de8:	09 d0                	or     %edx,%eax
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  807dea:	5d                   	pop    %ebp
  807deb:	c3                   	ret    

00807dec <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  807dec:	55                   	push   %ebp
  807ded:	89 e5                	mov    %esp,%ebp
  807def:	57                   	push   %edi
  807df0:	56                   	push   %esi
  807df1:	53                   	push   %ebx
  807df2:	83 ec 20             	sub    $0x20,%esp
  807df5:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  807df8:	0f be 10             	movsbl (%eax),%edx
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  807dfb:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  807dfe:	89 75 d8             	mov    %esi,-0x28(%ebp)
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  807e01:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807e04:	80 f9 09             	cmp    $0x9,%cl
  807e07:	0f 87 a6 01 00 00    	ja     807fb3 <inet_aton+0x1c7>
      return (0);
    val = 0;
    base = 10;
  807e0d:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
    if (c == '0') {
  807e14:	83 fa 30             	cmp    $0x30,%edx
  807e17:	75 2b                	jne    807e44 <inet_aton+0x58>
      c = *++cp;
  807e19:	0f b6 50 01          	movzbl 0x1(%eax),%edx
      if (c == 'x' || c == 'X') {
  807e1d:	89 d1                	mov    %edx,%ecx
  807e1f:	83 e1 df             	and    $0xffffffdf,%ecx
  807e22:	80 f9 58             	cmp    $0x58,%cl
  807e25:	74 0f                	je     807e36 <inet_aton+0x4a>
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
  807e27:	83 c0 01             	add    $0x1,%eax
  807e2a:	0f be d2             	movsbl %dl,%edx
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
      } else
        base = 8;
  807e2d:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  807e34:	eb 0e                	jmp    807e44 <inet_aton+0x58>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  807e36:	0f be 50 02          	movsbl 0x2(%eax),%edx
  807e3a:	8d 40 02             	lea    0x2(%eax),%eax
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  807e3d:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  807e44:	83 c0 01             	add    $0x1,%eax
  807e47:	bf 00 00 00 00       	mov    $0x0,%edi
  807e4c:	eb 03                	jmp    807e51 <inet_aton+0x65>
  807e4e:	83 c0 01             	add    $0x1,%eax
  807e51:	8d 70 ff             	lea    -0x1(%eax),%esi
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  807e54:	89 d3                	mov    %edx,%ebx
  807e56:	8d 4a d0             	lea    -0x30(%edx),%ecx
  807e59:	80 f9 09             	cmp    $0x9,%cl
  807e5c:	77 0d                	ja     807e6b <inet_aton+0x7f>
        val = (val * base) + (int)(c - '0');
  807e5e:	0f af 7d e0          	imul   -0x20(%ebp),%edi
  807e62:	8d 7c 3a d0          	lea    -0x30(%edx,%edi,1),%edi
        c = *++cp;
  807e66:	0f be 10             	movsbl (%eax),%edx
  807e69:	eb e3                	jmp    807e4e <inet_aton+0x62>
      } else if (base == 16 && isxdigit(c)) {
  807e6b:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  807e6f:	75 30                	jne    807ea1 <inet_aton+0xb5>
  807e71:	8d 4b 9f             	lea    -0x61(%ebx),%ecx
  807e74:	88 4d df             	mov    %cl,-0x21(%ebp)
  807e77:	89 d1                	mov    %edx,%ecx
  807e79:	83 e1 df             	and    $0xffffffdf,%ecx
  807e7c:	83 e9 41             	sub    $0x41,%ecx
  807e7f:	80 f9 05             	cmp    $0x5,%cl
  807e82:	77 23                	ja     807ea7 <inet_aton+0xbb>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  807e84:	89 fb                	mov    %edi,%ebx
  807e86:	c1 e3 04             	shl    $0x4,%ebx
  807e89:	8d 7a 0a             	lea    0xa(%edx),%edi
  807e8c:	80 7d df 1a          	cmpb   $0x1a,-0x21(%ebp)
  807e90:	19 c9                	sbb    %ecx,%ecx
  807e92:	83 e1 20             	and    $0x20,%ecx
  807e95:	83 c1 41             	add    $0x41,%ecx
  807e98:	29 cf                	sub    %ecx,%edi
  807e9a:	09 df                	or     %ebx,%edi
        c = *++cp;
  807e9c:	0f be 10             	movsbl (%eax),%edx
  807e9f:	eb ad                	jmp    807e4e <inet_aton+0x62>
  807ea1:	89 d0                	mov    %edx,%eax
  807ea3:	89 f9                	mov    %edi,%ecx
  807ea5:	eb 04                	jmp    807eab <inet_aton+0xbf>
  807ea7:	89 d0                	mov    %edx,%eax
  807ea9:	89 f9                	mov    %edi,%ecx
      } else
        break;
    }
    if (c == '.') {
  807eab:	83 f8 2e             	cmp    $0x2e,%eax
  807eae:	75 22                	jne    807ed2 <inet_aton+0xe6>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  807eb0:	8d 45 f0             	lea    -0x10(%ebp),%eax
  807eb3:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  807eb6:	0f 84 fe 00 00 00    	je     807fba <inet_aton+0x1ce>
        return (0);
      *pp++ = val;
  807ebc:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  807ec0:	8b 45 d8             	mov    -0x28(%ebp),%eax
  807ec3:	89 48 fc             	mov    %ecx,-0x4(%eax)
      c = *++cp;
  807ec6:	8d 46 01             	lea    0x1(%esi),%eax
  807ec9:	0f be 56 01          	movsbl 0x1(%esi),%edx
    } else
      break;
  }
  807ecd:	e9 2f ff ff ff       	jmp    807e01 <inet_aton+0x15>
  807ed2:	89 f9                	mov    %edi,%ecx
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807ed4:	85 d2                	test   %edx,%edx
  807ed6:	74 27                	je     807eff <inet_aton+0x113>
    return (0);
  807ed8:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  807edd:	80 fb 1f             	cmp    $0x1f,%bl
  807ee0:	0f 86 e7 00 00 00    	jbe    807fcd <inet_aton+0x1e1>
  807ee6:	84 d2                	test   %dl,%dl
  807ee8:	0f 88 d3 00 00 00    	js     807fc1 <inet_aton+0x1d5>
  807eee:	83 fa 20             	cmp    $0x20,%edx
  807ef1:	74 0c                	je     807eff <inet_aton+0x113>
  807ef3:	83 ea 09             	sub    $0x9,%edx
  807ef6:	83 fa 04             	cmp    $0x4,%edx
  807ef9:	0f 87 ce 00 00 00    	ja     807fcd <inet_aton+0x1e1>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  807eff:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807f02:	8b 55 d8             	mov    -0x28(%ebp),%edx
  807f05:	29 c2                	sub    %eax,%edx
  807f07:	c1 fa 02             	sar    $0x2,%edx
  807f0a:	83 c2 01             	add    $0x1,%edx
  switch (n) {
  807f0d:	83 fa 02             	cmp    $0x2,%edx
  807f10:	74 22                	je     807f34 <inet_aton+0x148>
  807f12:	83 fa 02             	cmp    $0x2,%edx
  807f15:	7f 0f                	jg     807f26 <inet_aton+0x13a>

  case 0:
    return (0);       /* initial nondigit */
  807f17:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  807f1c:	85 d2                	test   %edx,%edx
  807f1e:	0f 84 a9 00 00 00    	je     807fcd <inet_aton+0x1e1>
  807f24:	eb 73                	jmp    807f99 <inet_aton+0x1ad>
  807f26:	83 fa 03             	cmp    $0x3,%edx
  807f29:	74 26                	je     807f51 <inet_aton+0x165>
  807f2b:	83 fa 04             	cmp    $0x4,%edx
  807f2e:	66 90                	xchg   %ax,%ax
  807f30:	74 40                	je     807f72 <inet_aton+0x186>
  807f32:	eb 65                	jmp    807f99 <inet_aton+0x1ad>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  807f34:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  807f39:	81 f9 ff ff ff 00    	cmp    $0xffffff,%ecx
  807f3f:	0f 87 88 00 00 00    	ja     807fcd <inet_aton+0x1e1>
      return (0);
    val |= parts[0] << 24;
  807f45:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f48:	c1 e0 18             	shl    $0x18,%eax
  807f4b:	89 cf                	mov    %ecx,%edi
  807f4d:	09 c7                	or     %eax,%edi
    break;
  807f4f:	eb 48                	jmp    807f99 <inet_aton+0x1ad>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  807f51:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  807f56:	81 f9 ff ff 00 00    	cmp    $0xffff,%ecx
  807f5c:	77 6f                	ja     807fcd <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  807f5e:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807f61:	c1 e2 10             	shl    $0x10,%edx
  807f64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f67:	c1 e0 18             	shl    $0x18,%eax
  807f6a:	09 d0                	or     %edx,%eax
  807f6c:	09 c8                	or     %ecx,%eax
  807f6e:	89 c7                	mov    %eax,%edi
    break;
  807f70:	eb 27                	jmp    807f99 <inet_aton+0x1ad>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  807f72:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  807f77:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
  807f7d:	77 4e                	ja     807fcd <inet_aton+0x1e1>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  807f7f:	8b 55 e8             	mov    -0x18(%ebp),%edx
  807f82:	c1 e2 10             	shl    $0x10,%edx
  807f85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f88:	c1 e0 18             	shl    $0x18,%eax
  807f8b:	09 c2                	or     %eax,%edx
  807f8d:	8b 45 ec             	mov    -0x14(%ebp),%eax
  807f90:	c1 e0 08             	shl    $0x8,%eax
  807f93:	09 d0                	or     %edx,%eax
  807f95:	09 c8                	or     %ecx,%eax
  807f97:	89 c7                	mov    %eax,%edi
    break;
  }
  if (addr)
  807f99:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807f9d:	74 29                	je     807fc8 <inet_aton+0x1dc>
    addr->s_addr = htonl(val);
  807f9f:	89 3c 24             	mov    %edi,(%esp)
  807fa2:	e8 19 fe ff ff       	call   807dc0 <htonl>
  807fa7:	8b 75 0c             	mov    0xc(%ebp),%esi
  807faa:	89 06                	mov    %eax,(%esi)
  return (1);
  807fac:	b8 01 00 00 00       	mov    $0x1,%eax
  807fb1:	eb 1a                	jmp    807fcd <inet_aton+0x1e1>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  807fb3:	b8 00 00 00 00       	mov    $0x0,%eax
  807fb8:	eb 13                	jmp    807fcd <inet_aton+0x1e1>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  807fba:	b8 00 00 00 00       	mov    $0x0,%eax
  807fbf:	eb 0c                	jmp    807fcd <inet_aton+0x1e1>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  807fc1:	b8 00 00 00 00       	mov    $0x0,%eax
  807fc6:	eb 05                	jmp    807fcd <inet_aton+0x1e1>
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  807fc8:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807fcd:	83 c4 20             	add    $0x20,%esp
  807fd0:	5b                   	pop    %ebx
  807fd1:	5e                   	pop    %esi
  807fd2:	5f                   	pop    %edi
  807fd3:	5d                   	pop    %ebp
  807fd4:	c3                   	ret    

00807fd5 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  807fd5:	55                   	push   %ebp
  807fd6:	89 e5                	mov    %esp,%ebp
  807fd8:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  807fdb:	8d 45 fc             	lea    -0x4(%ebp),%eax
  807fde:	89 44 24 04          	mov    %eax,0x4(%esp)
  807fe2:	8b 45 08             	mov    0x8(%ebp),%eax
  807fe5:	89 04 24             	mov    %eax,(%esp)
  807fe8:	e8 ff fd ff ff       	call   807dec <inet_aton>
  807fed:	85 c0                	test   %eax,%eax
    return (val.s_addr);
  807fef:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  807ff4:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  807ff8:	c9                   	leave  
  807ff9:	c3                   	ret    

00807ffa <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  807ffa:	55                   	push   %ebp
  807ffb:	89 e5                	mov    %esp,%ebp
  807ffd:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  808000:	8b 45 08             	mov    0x8(%ebp),%eax
  808003:	89 04 24             	mov    %eax,(%esp)
  808006:	e8 b5 fd ff ff       	call   807dc0 <htonl>
}
  80800b:	c9                   	leave  
  80800c:	c3                   	ret    
  80800d:	66 90                	xchg   %ax,%ax
  80800f:	90                   	nop

00808010 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  808010:	55                   	push   %ebp
  808011:	89 e5                	mov    %esp,%ebp
  808013:	57                   	push   %edi
  808014:	56                   	push   %esi
  808015:	53                   	push   %ebx
  808016:	83 ec 4c             	sub    $0x4c,%esp
  808019:	8b 7d 08             	mov    0x8(%ebp),%edi
  80801c:	8b 45 10             	mov    0x10(%ebp),%eax
  80801f:	89 c6                	mov    %eax,%esi
  808021:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  808024:	8b 45 14             	mov    0x14(%ebp),%eax
  808027:	89 c1                	mov    %eax,%ecx
  808029:	89 45 bc             	mov    %eax,-0x44(%ebp)
  80802c:	8b 45 18             	mov    0x18(%ebp),%eax
  80802f:	89 c2                	mov    %eax,%edx
  808031:	89 45 b8             	mov    %eax,-0x48(%ebp)
  808034:	8b 45 20             	mov    0x20(%ebp),%eax
  808037:	66 89 75 c2          	mov    %si,-0x3e(%ebp)
  80803b:	88 4d ce             	mov    %cl,-0x32(%ebp)
  80803e:	88 45 cb             	mov    %al,-0x35(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  808041:	66 85 f6             	test   %si,%si
  808044:	74 20                	je     808066 <tcp_enqueue+0x56>
  808046:	84 c0                	test   %al,%al
  808048:	74 1c                	je     808066 <tcp_enqueue+0x56>
  80804a:	c7 44 24 08 9c 30 81 	movl   $0x81309c,0x8(%esp)
  808051:	00 
  808052:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  808059:	00 
  80805a:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808061:	e8 34 70 00 00       	call   80f09a <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  808066:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80806a:	0f 95 c1             	setne  %cl
  80806d:	88 4d c9             	mov    %cl,-0x37(%ebp)
  808070:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  808074:	0f 95 45 cf          	setne  -0x31(%ebp)
  808078:	84 c9                	test   %cl,%cl
  80807a:	74 22                	je     80809e <tcp_enqueue+0x8e>
  80807c:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  808080:	74 1c                	je     80809e <tcp_enqueue+0x8e>
  808082:	c7 44 24 08 dc 30 81 	movl   $0x8130dc,0x8(%esp)
  808089:	00 
  80808a:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  808091:	00 
  808092:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808099:	e8 fc 6f 00 00       	call   80f09a <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80809e:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  8080a2:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  8080a6:	76 0e                	jbe    8080b6 <tcp_enqueue+0xa6>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  8080a8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8080ac:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080b1:	e9 24 06 00 00       	jmp    8086da <tcp_enqueue+0x6ca>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  8080b6:	8b 4f 68             	mov    0x68(%edi),%ecx
  8080b9:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  8080bc:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  8080c0:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  8080c4:	66 83 f9 1f          	cmp    $0x1f,%cx
  8080c8:	76 0e                	jbe    8080d8 <tcp_enqueue+0xc8>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  8080ca:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  8080ce:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8080d3:	e9 02 06 00 00       	jmp    8086da <tcp_enqueue+0x6ca>
  }
  if (queuelen != 0) {
  8080d8:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  8080dd:	74 30                	je     80810f <tcp_enqueue+0xff>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  8080df:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8080e3:	0f 85 b9 05 00 00    	jne    8086a2 <tcp_enqueue+0x692>
  8080e9:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8080ed:	0f 85 af 05 00 00    	jne    8086a2 <tcp_enqueue+0x692>
  8080f3:	c7 44 24 08 24 31 81 	movl   $0x813124,0x8(%esp)
  8080fa:	00 
  8080fb:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  808102:	00 
  808103:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  80810a:	e8 8b 6f 00 00       	call   80f09a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80810f:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808113:	75 0a                	jne    80811f <tcp_enqueue+0x10f>
  808115:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  808119:	0f 84 83 05 00 00    	je     8086a2 <tcp_enqueue+0x692>
  80811f:	c7 44 24 08 60 31 81 	movl   $0x813160,0x8(%esp)
  808126:	00 
  808127:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80812e:	00 
  80812f:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808136:	e8 5f 6f 00 00       	call   80f09a <_panic>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80813b:	89 de                	mov    %ebx,%esi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80813d:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  808141:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  808145:	66 39 c1             	cmp    %ax,%cx
  808148:	0f 46 c1             	cmovbe %ecx,%eax
  80814b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80814f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808156:	e8 b7 c8 ff ff       	call   804a12 <memp_malloc>
  80815b:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80815d:	85 c0                	test   %eax,%eax
  80815f:	0f 84 c3 04 00 00    	je     808628 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  808165:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80816b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  808172:	80 7d dc 00          	cmpb   $0x0,-0x24(%ebp)
  808176:	75 24                	jne    80819c <tcp_enqueue+0x18c>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  808178:	85 f6                	test   %esi,%esi
  80817a:	75 1c                	jne    808198 <tcp_enqueue+0x188>
  80817c:	c7 44 24 08 56 32 81 	movl   $0x813256,0x8(%esp)
  808183:	00 
  808184:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80818b:	00 
  80818c:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808193:	e8 02 6f 00 00       	call   80f09a <_panic>
      useg->next = seg;
  808198:	89 06                	mov    %eax,(%esi)
  80819a:	eb 03                	jmp    80819f <tcp_enqueue+0x18f>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80819c:	89 45 d0             	mov    %eax,-0x30(%ebp)
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80819f:	80 7d cf 00          	cmpb   $0x0,-0x31(%ebp)
  8081a3:	74 69                	je     80820e <tcp_enqueue+0x1fe>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8081a5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8081ac:	00 
  8081ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8081b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8081bb:	e8 45 cd ff ff       	call   804f05 <pbuf_alloc>
  8081c0:	89 43 04             	mov    %eax,0x4(%ebx)
  8081c3:	85 c0                	test   %eax,%eax
  8081c5:	0f 84 5d 04 00 00    	je     808628 <tcp_enqueue+0x618>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  8081cb:	0f b6 55 cb          	movzbl -0x35(%ebp),%edx
  8081cf:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  8081d3:	73 1c                	jae    8081f1 <tcp_enqueue+0x1e1>
  8081d5:	c7 44 24 08 94 31 81 	movl   $0x813194,0x8(%esp)
  8081dc:	00 
  8081dd:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  8081e4:	00 
  8081e5:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  8081ec:	e8 a9 6e 00 00       	call   80f09a <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  8081f1:	89 04 24             	mov    %eax,(%esp)
  8081f4:	e8 c1 d0 ff ff       	call   8052ba <pbuf_clen>
  8081f9:	0f b6 c0             	movzbl %al,%eax
  8081fc:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
      seg->dataptr = seg->p->payload;
  808200:	8b 43 04             	mov    0x4(%ebx),%eax
  808203:	8b 40 04             	mov    0x4(%eax),%eax
  808206:	89 43 08             	mov    %eax,0x8(%ebx)
  808209:	e9 22 01 00 00       	jmp    808330 <tcp_enqueue+0x320>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80820e:	80 7d ca 00          	cmpb   $0x0,-0x36(%ebp)
  808212:	0f 84 8c 00 00 00    	je     8082a4 <tcp_enqueue+0x294>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  808218:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80821f:	00 
  808220:	0f b7 75 e6          	movzwl -0x1a(%ebp),%esi
  808224:	0f b7 c6             	movzwl %si,%eax
  808227:	89 44 24 04          	mov    %eax,0x4(%esp)
  80822b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808232:	e8 ce cc ff ff       	call   804f05 <pbuf_alloc>
  808237:	89 43 04             	mov    %eax,0x4(%ebx)
  80823a:	85 c0                	test   %eax,%eax
  80823c:	0f 84 e6 03 00 00    	je     808628 <tcp_enqueue+0x618>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  808242:	66 3b 70 0a          	cmp    0xa(%eax),%si
  808246:	76 1c                	jbe    808264 <tcp_enqueue+0x254>
  808248:	c7 44 24 08 bc 31 81 	movl   $0x8131bc,0x8(%esp)
  80824f:	00 
  808250:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  808257:	00 
  808258:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  80825f:	e8 36 6e 00 00       	call   80f09a <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  808264:	89 04 24             	mov    %eax,(%esp)
  808267:	e8 4e d0 ff ff       	call   8052ba <pbuf_clen>
  80826c:	0f b6 c0             	movzbl %al,%eax
  80826f:	66 01 45 e4          	add    %ax,-0x1c(%ebp)
      if (arg != NULL) {
  808273:	80 7d c9 00          	cmpb   $0x0,-0x37(%ebp)
  808277:	74 1d                	je     808296 <tcp_enqueue+0x286>
        MEMCPY(seg->p->payload, ptr, seglen);
  808279:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80827d:	89 44 24 08          	mov    %eax,0x8(%esp)
  808281:	8b 45 0c             	mov    0xc(%ebp),%eax
  808284:	89 44 24 04          	mov    %eax,0x4(%esp)
  808288:	8b 43 04             	mov    0x4(%ebx),%eax
  80828b:	8b 40 04             	mov    0x4(%eax),%eax
  80828e:	89 04 24             	mov    %eax,(%esp)
  808291:	e8 26 77 00 00       	call   80f9bc <memcpy>
      }
      seg->dataptr = seg->p->payload;
  808296:	8b 43 04             	mov    0x4(%ebx),%eax
  808299:	8b 40 04             	mov    0x4(%eax),%eax
  80829c:	89 43 08             	mov    %eax,0x8(%ebx)
  80829f:	e9 8c 00 00 00       	jmp    808330 <tcp_enqueue+0x320>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  8082a4:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8082ab:	00 
  8082ac:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8082b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8082b4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8082bb:	e8 45 cc ff ff       	call   804f05 <pbuf_alloc>
  8082c0:	89 c6                	mov    %eax,%esi
  8082c2:	85 c0                	test   %eax,%eax
  8082c4:	0f 84 5e 03 00 00    	je     808628 <tcp_enqueue+0x618>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
  8082ca:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8082ce:	83 c0 01             	add    $0x1,%eax
  8082d1:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
      /* reference the non-volatile payload data */
      p->payload = ptr;
  8082d5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8082d8:	89 46 04             	mov    %eax,0x4(%esi)
      seg->dataptr = ptr;
  8082db:	89 43 08             	mov    %eax,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  8082de:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8082e5:	00 
  8082e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8082ed:	00 
  8082ee:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8082f5:	e8 0b cc ff ff       	call   804f05 <pbuf_alloc>
  8082fa:	89 43 04             	mov    %eax,0x4(%ebx)
  8082fd:	85 c0                	test   %eax,%eax
  8082ff:	75 0d                	jne    80830e <tcp_enqueue+0x2fe>
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  808301:	89 34 24             	mov    %esi,(%esp)
  808304:	e8 1b cb ff ff       	call   804e24 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  808309:	e9 1a 03 00 00       	jmp    808628 <tcp_enqueue+0x618>
      }
      queuelen += pbuf_clen(seg->p);
  80830e:	89 04 24             	mov    %eax,(%esp)
  808311:	e8 a4 cf ff ff       	call   8052ba <pbuf_clen>
  808316:	0f b6 c0             	movzbl %al,%eax
  808319:	66 03 45 e4          	add    -0x1c(%ebp),%ax
  80831d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  808321:	89 74 24 04          	mov    %esi,0x4(%esp)
  808325:	8b 43 04             	mov    0x4(%ebx),%eax
  808328:	89 04 24             	mov    %eax,(%esp)
  80832b:	e8 b3 cf ff ff       	call   8052e3 <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  808330:	66 83 7d e4 20       	cmpw   $0x20,-0x1c(%ebp)
  808335:	0f 87 ed 02 00 00    	ja     808628 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80833b:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80833f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  808343:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80834a:	00 
  80834b:	8b 43 04             	mov    0x4(%ebx),%eax
  80834e:	89 04 24             	mov    %eax,(%esp)
  808351:	e8 ea c9 ff ff       	call   804d40 <pbuf_header>
  808356:	84 c0                	test   %al,%al
  808358:	0f 85 ca 02 00 00    	jne    808628 <tcp_enqueue+0x618>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80835e:	8b 43 04             	mov    0x4(%ebx),%eax
  808361:	8b 70 04             	mov    0x4(%eax),%esi
  808364:	89 73 10             	mov    %esi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  808367:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80836b:	89 04 24             	mov    %eax,(%esp)
  80836e:	e8 33 fa ff ff       	call   807da6 <htons>
  808373:	66 89 06             	mov    %ax,(%esi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  808376:	8b 73 10             	mov    0x10(%ebx),%esi
  808379:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  80837d:	89 04 24             	mov    %eax,(%esp)
  808380:	e8 21 fa ff ff       	call   807da6 <htons>
  808385:	66 89 46 02          	mov    %ax,0x2(%esi)
    seg->tcphdr->seqno = htonl(seqno);
  808389:	8b 73 10             	mov    0x10(%ebx),%esi
  80838c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80838f:	89 04 24             	mov    %eax,(%esp)
  808392:	e8 29 fa ff ff       	call   807dc0 <htonl>
  808397:	89 46 04             	mov    %eax,0x4(%esi)
    seg->tcphdr->urgp = 0;
  80839a:	8b 43 10             	mov    0x10(%ebx),%eax
  80839d:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  8083a3:	8b 73 10             	mov    0x10(%ebx),%esi
  8083a6:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8083aa:	89 04 24             	mov    %eax,(%esp)
  8083ad:	e8 01 fa ff ff       	call   807db3 <ntohs>
  8083b2:	83 e0 c0             	and    $0xffffffc0,%eax
  8083b5:	0f b6 55 ce          	movzbl -0x32(%ebp),%edx
  8083b9:	09 d0                	or     %edx,%eax
  8083bb:	0f b7 c0             	movzwl %ax,%eax
  8083be:	89 04 24             	mov    %eax,(%esp)
  8083c1:	e8 e0 f9 ff ff       	call   807da6 <htons>
  8083c6:	66 89 46 0c          	mov    %ax,0xc(%esi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  8083ca:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8083ce:	75 23                	jne    8083f3 <tcp_enqueue+0x3e3>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  8083d0:	8b 73 10             	mov    0x10(%ebx),%esi
  8083d3:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8083d7:	89 04 24             	mov    %eax,(%esp)
  8083da:	e8 d4 f9 ff ff       	call   807db3 <ntohs>
  8083df:	83 e0 3f             	and    $0x3f,%eax
  8083e2:	80 cc 50             	or     $0x50,%ah
  8083e5:	89 04 24             	mov    %eax,(%esp)
  8083e8:	e8 b9 f9 ff ff       	call   807da6 <htons>
  8083ed:	66 89 46 0c          	mov    %ax,0xc(%esi)
  8083f1:	eb 3e                	jmp    808431 <tcp_enqueue+0x421>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8083f3:	8b 73 10             	mov    0x10(%ebx),%esi
  8083f6:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8083fa:	89 04 24             	mov    %eax,(%esp)
  8083fd:	e8 b1 f9 ff ff       	call   807db3 <ntohs>
  808402:	83 e0 3f             	and    $0x3f,%eax
  808405:	66 0b 45 cc          	or     -0x34(%ebp),%ax
  808409:	0f b7 c0             	movzwl %ax,%eax
  80840c:	89 04 24             	mov    %eax,(%esp)
  80840f:	e8 92 f9 ff ff       	call   807da6 <htons>
  808414:	66 89 46 0c          	mov    %ax,0xc(%esi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  808418:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80841b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80841f:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808422:	89 44 24 04          	mov    %eax,0x4(%esp)
  808426:	8b 43 08             	mov    0x8(%ebx),%eax
  808429:	89 04 24             	mov    %eax,(%esp)
  80842c:	e8 8b 75 00 00       	call   80f9bc <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  808431:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  808435:	66 29 45 e0          	sub    %ax,-0x20(%ebp)
    seqno += seglen;
  808439:	0f b7 c0             	movzwl %ax,%eax
  80843c:	01 45 d8             	add    %eax,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80843f:	01 45 0c             	add    %eax,0xc(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  808442:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  808446:	0f 94 45 dc          	sete   -0x24(%ebp)
  80844a:	0f 84 eb fc ff ff    	je     80813b <tcp_enqueue+0x12b>
  808450:	66 83 7d e0 00       	cmpw   $0x0,-0x20(%ebp)
  808455:	0f 85 e0 fc ff ff    	jne    80813b <tcp_enqueue+0x12b>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80845b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80845e:	8b 77 74             	mov    0x74(%edi),%esi
  808461:	85 f6                	test   %esi,%esi
  808463:	0f 84 24 02 00 00    	je     80868d <tcp_enqueue+0x67d>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  808469:	8b 06                	mov    (%esi),%eax
  80846b:	85 c0                	test   %eax,%eax
  80846d:	74 04                	je     808473 <tcp_enqueue+0x463>
  80846f:	89 c6                	mov    %eax,%esi
  808471:	eb f6                	jmp    808469 <tcp_enqueue+0x459>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  808473:	85 f6                	test   %esi,%esi
  808475:	0f 84 12 02 00 00    	je     80868d <tcp_enqueue+0x67d>
    TCP_TCPLEN(useg) != 0 &&
  80847b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80847f:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808482:	8b 46 10             	mov    0x10(%esi),%eax
  808485:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808489:	89 04 24             	mov    %eax,(%esp)
  80848c:	e8 22 f9 ff ff       	call   807db3 <ntohs>
  808491:	ba 01 00 00 00       	mov    $0x1,%edx
  808496:	a8 01                	test   $0x1,%al
  808498:	75 17                	jne    8084b1 <tcp_enqueue+0x4a1>
  80849a:	8b 46 10             	mov    0x10(%esi),%eax
  80849d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084a1:	89 04 24             	mov    %eax,(%esp)
  8084a4:	e8 0a f9 ff ff       	call   807db3 <ntohs>
  8084a9:	66 d1 e8             	shr    %ax
  8084ac:	89 c2                	mov    %eax,%edx
  8084ae:	83 e2 01             	and    $0x1,%edx
  8084b1:	03 55 e0             	add    -0x20(%ebp),%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  8084b4:	85 d2                	test   %edx,%edx
  8084b6:	0f 84 dc 01 00 00    	je     808698 <tcp_enqueue+0x688>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8084bc:	8b 46 10             	mov    0x10(%esi),%eax
  8084bf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084c3:	89 04 24             	mov    %eax,(%esp)
  8084c6:	e8 e8 f8 ff ff       	call   807db3 <ntohs>
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
  8084cb:	a8 03                	test   $0x3,%al
  8084cd:	0f 85 c5 01 00 00    	jne    808698 <tcp_enqueue+0x688>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  8084d3:	f6 45 bc 03          	testb  $0x3,-0x44(%ebp)
  8084d7:	0f 85 bb 01 00 00    	jne    808698 <tcp_enqueue+0x688>
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  8084dd:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  8084e1:	8b 45 d0             	mov    -0x30(%ebp),%eax
  8084e4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8084e8:	01 c2                	add    %eax,%edx
  8084ea:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
  8084ee:	39 c2                	cmp    %eax,%edx
  8084f0:	0f 8f a2 01 00 00    	jg     808698 <tcp_enqueue+0x688>
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  8084f6:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  8084fd:	ff 
  8084fe:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808501:	8b 40 04             	mov    0x4(%eax),%eax
  808504:	89 04 24             	mov    %eax,(%esp)
  808507:	e8 34 c8 ff ff       	call   804d40 <pbuf_header>
  80850c:	84 c0                	test   %al,%al
  80850e:	74 1c                	je     80852c <tcp_enqueue+0x51c>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  808510:	c7 44 24 08 63 32 81 	movl   $0x813263,0x8(%esp)
  808517:	00 
  808518:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80851f:	00 
  808520:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808527:	e8 6e 6b 00 00       	call   80f09a <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80852c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80852f:	8b 40 04             	mov    0x4(%eax),%eax
  808532:	89 44 24 04          	mov    %eax,0x4(%esp)
  808536:	8b 46 04             	mov    0x4(%esi),%eax
  808539:	89 04 24             	mov    %eax,(%esp)
  80853c:	e8 a2 cd ff ff       	call   8052e3 <pbuf_cat>
    useg->len += queue->len;
  808541:	8b 55 d0             	mov    -0x30(%ebp),%edx
  808544:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  808548:	66 01 46 0c          	add    %ax,0xc(%esi)
    useg->next = queue->next;
  80854c:	8b 02                	mov    (%edx),%eax
  80854e:	89 06                	mov    %eax,(%esi)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
      seg = NULL;
  808550:	3b 55 dc             	cmp    -0x24(%ebp),%edx
  808553:	b8 00 00 00 00       	mov    $0x0,%eax
  808558:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  80855b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80855f:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808566:	e8 07 c5 ff ff       	call   804a72 <memp_free>
  80856b:	eb 19                	jmp    808586 <tcp_enqueue+0x576>
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80856d:	0f b6 55 bc          	movzbl -0x44(%ebp),%edx
  808571:	83 e2 03             	and    $0x3,%edx
    ++len;
  808574:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  808578:	83 c0 01             	add    $0x1,%eax
  80857b:	84 d2                	test   %dl,%dl
  80857d:	66 0f 44 45 c2       	cmove  -0x3e(%ebp),%ax
  808582:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  808586:	f6 45 bc 01          	testb  $0x1,-0x44(%ebp)
  80858a:	74 04                	je     808590 <tcp_enqueue+0x580>
    pcb->flags |= TF_FIN;
  80858c:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  808590:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  808594:	0f b7 c2             	movzwl %dx,%eax
  808597:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80859a:	66 29 57 6e          	sub    %dx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80859e:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8085a2:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  8085a6:	66 85 c0             	test   %ax,%ax
  8085a9:	74 28                	je     8085d3 <tcp_enqueue+0x5c3>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  8085ab:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  8085af:	75 22                	jne    8085d3 <tcp_enqueue+0x5c3>
  8085b1:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  8085b5:	75 1c                	jne    8085d3 <tcp_enqueue+0x5c3>
  8085b7:	c7 44 24 08 f0 31 81 	movl   $0x8131f0,0x8(%esp)
  8085be:	00 
  8085bf:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  8085c6:	00 
  8085c7:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  8085ce:	e8 c7 6a 00 00       	call   80f09a <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8085d3:	85 db                	test   %ebx,%ebx
  8085d5:	0f 84 8f 00 00 00    	je     80866a <tcp_enqueue+0x65a>
  8085db:	66 83 7d e6 00       	cmpw   $0x0,-0x1a(%ebp)
  8085e0:	0f 84 84 00 00 00    	je     80866a <tcp_enqueue+0x65a>
  8085e6:	8b 5b 10             	mov    0x10(%ebx),%ebx
  8085e9:	85 db                	test   %ebx,%ebx
  8085eb:	0f 84 80 00 00 00    	je     808671 <tcp_enqueue+0x661>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  8085f1:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  8085f6:	f6 45 b8 02          	testb  $0x2,-0x48(%ebp)
  8085fa:	0f 85 da 00 00 00    	jne    8086da <tcp_enqueue+0x6ca>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  808600:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808604:	89 04 24             	mov    %eax,(%esp)
  808607:	e8 a7 f7 ff ff       	call   807db3 <ntohs>
  80860c:	83 c8 08             	or     $0x8,%eax
  80860f:	0f b7 c0             	movzwl %ax,%eax
  808612:	89 04 24             	mov    %eax,(%esp)
  808615:	e8 8c f7 ff ff       	call   807da6 <htons>
  80861a:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  80861e:	b8 00 00 00 00       	mov    $0x0,%eax
  808623:	e9 b2 00 00 00       	jmp    8086da <tcp_enqueue+0x6ca>
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  808628:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80862c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80862f:	85 c0                	test   %eax,%eax
  808631:	74 08                	je     80863b <tcp_enqueue+0x62b>
    tcp_segs_free(queue);
  808633:	89 04 24             	mov    %eax,(%esp)
  808636:	e8 03 d8 ff ff       	call   805e3e <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80863b:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  808640:	74 36                	je     808678 <tcp_enqueue+0x668>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  808642:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808646:	75 37                	jne    80867f <tcp_enqueue+0x66f>
  808648:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80864c:	75 38                	jne    808686 <tcp_enqueue+0x676>
  80864e:	c7 44 24 08 f0 31 81 	movl   $0x8131f0,0x8(%esp)
  808655:	00 
  808656:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80865d:	00 
  80865e:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808665:	e8 30 6a 00 00       	call   80f09a <_panic>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  80866a:	b8 00 00 00 00       	mov    $0x0,%eax
  80866f:	eb 69                	jmp    8086da <tcp_enqueue+0x6ca>
  808671:	b8 00 00 00 00       	mov    $0x0,%eax
  808676:	eb 62                	jmp    8086da <tcp_enqueue+0x6ca>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  808678:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80867d:	eb 5b                	jmp    8086da <tcp_enqueue+0x6ca>
  80867f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  808684:	eb 54                	jmp    8086da <tcp_enqueue+0x6ca>
  808686:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80868b:	eb 4d                	jmp    8086da <tcp_enqueue+0x6ca>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80868d:	8b 45 d0             	mov    -0x30(%ebp),%eax
  808690:	89 47 74             	mov    %eax,0x74(%edi)
  808693:	e9 d5 fe ff ff       	jmp    80856d <tcp_enqueue+0x55d>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  808698:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80869b:	89 06                	mov    %eax,(%esi)
  80869d:	e9 cb fe ff ff       	jmp    80856d <tcp_enqueue+0x55d>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8086a2:	c0 e8 02             	shr    $0x2,%al
  8086a5:	c1 e0 0c             	shl    $0xc,%eax
  8086a8:	66 05 00 50          	add    $0x5000,%ax
  8086ac:	66 89 45 cc          	mov    %ax,-0x34(%ebp)
  8086b0:	0f b7 45 c4          	movzwl -0x3c(%ebp),%eax
  8086b4:	66 89 45 e0          	mov    %ax,-0x20(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  8086b8:	c6 45 dc 01          	movb   $0x1,-0x24(%ebp)
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  8086bc:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  8086c3:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  8086c8:	83 e2 01             	and    $0x1,%edx
  8086cb:	88 55 ca             	mov    %dl,-0x36(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  8086ce:	0f b6 45 cb          	movzbl -0x35(%ebp),%eax
  8086d2:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  8086d5:	e9 63 fa ff ff       	jmp    80813d <tcp_enqueue+0x12d>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  8086da:	83 c4 4c             	add    $0x4c,%esp
  8086dd:	5b                   	pop    %ebx
  8086de:	5e                   	pop    %esi
  8086df:	5f                   	pop    %edi
  8086e0:	5d                   	pop    %ebp
  8086e1:	c3                   	ret    

008086e2 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  8086e2:	55                   	push   %ebp
  8086e3:	89 e5                	mov    %esp,%ebp
  8086e5:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  8086e8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  8086ef:	00 
  8086f0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  8086f7:	00 
  8086f8:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  8086ff:	00 
  808700:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  808704:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808708:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80870f:	00 
  808710:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808717:	00 
  808718:	8b 45 08             	mov    0x8(%ebp),%eax
  80871b:	89 04 24             	mov    %eax,(%esp)
  80871e:	e8 ed f8 ff ff       	call   808010 <tcp_enqueue>
}
  808723:	c9                   	leave  
  808724:	c3                   	ret    

00808725 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  808725:	55                   	push   %ebp
  808726:	89 e5                	mov    %esp,%ebp
  808728:	56                   	push   %esi
  808729:	53                   	push   %ebx
  80872a:	83 ec 20             	sub    $0x20,%esp
  80872d:	8b 55 08             	mov    0x8(%ebp),%edx
  808730:	8b 4d 10             	mov    0x10(%ebp),%ecx
  808733:	8b 5d 14             	mov    0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  808736:	8b 42 10             	mov    0x10(%edx),%eax
  808739:	83 f8 07             	cmp    $0x7,%eax
  80873c:	74 0d                	je     80874b <tcp_write+0x26>
     pcb->state == CLOSE_WAIT ||
  80873e:	8d 70 fe             	lea    -0x2(%eax),%esi
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  808741:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  808746:	83 fe 02             	cmp    $0x2,%esi
  808749:	77 3f                	ja     80878a <tcp_write+0x65>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  80874b:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  808750:	66 85 c9             	test   %cx,%cx
  808753:	74 35                	je     80878a <tcp_write+0x65>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  808755:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80875c:	00 
  80875d:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  808764:	00 
  808765:	0f b6 db             	movzbl %bl,%ebx
  808768:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80876c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808773:	00 
  808774:	0f b7 c9             	movzwl %cx,%ecx
  808777:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80877b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80877e:	89 44 24 04          	mov    %eax,0x4(%esp)
  808782:	89 14 24             	mov    %edx,(%esp)
  808785:	e8 86 f8 ff ff       	call   808010 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80878a:	83 c4 20             	add    $0x20,%esp
  80878d:	5b                   	pop    %ebx
  80878e:	5e                   	pop    %esi
  80878f:	5d                   	pop    %ebp
  808790:	c3                   	ret    

00808791 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  808791:	55                   	push   %ebp
  808792:	89 e5                	mov    %esp,%ebp
  808794:	57                   	push   %edi
  808795:	56                   	push   %esi
  808796:	53                   	push   %ebx
  808797:	83 ec 3c             	sub    $0x3c,%esp
  80879a:	8b 7d 08             	mov    0x8(%ebp),%edi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80879d:	39 3d 78 c2 b3 00    	cmp    %edi,0xb3c278
  8087a3:	0f 84 53 04 00 00    	je     808bfc <tcp_output+0x46b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  8087a9:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  8087ad:	66 39 47 5c          	cmp    %ax,0x5c(%edi)
  8087b1:	66 0f 46 47 5c       	cmovbe 0x5c(%edi),%ax
  8087b6:	0f b7 c0             	movzwl %ax,%eax
  8087b9:	89 45 d8             	mov    %eax,-0x28(%ebp)

  seg = pcb->unsent;
  8087bc:	8b 5f 74             	mov    0x74(%edi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  8087bf:	8b 47 78             	mov    0x78(%edi),%eax
  8087c2:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (useg != NULL) {
  8087c5:	85 c0                	test   %eax,%eax
  8087c7:	74 0f                	je     8087d8 <tcp_output+0x47>
  8087c9:	89 c2                	mov    %eax,%edx
    for (; useg->next != NULL; useg = useg->next);
  8087cb:	8b 02                	mov    (%edx),%eax
  8087cd:	85 c0                	test   %eax,%eax
  8087cf:	74 04                	je     8087d5 <tcp_output+0x44>
  8087d1:	89 c2                	mov    %eax,%edx
  8087d3:	eb f6                	jmp    8087cb <tcp_output+0x3a>
  8087d5:	89 55 dc             	mov    %edx,-0x24(%ebp)
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  8087d8:	f6 47 20 02          	testb  $0x2,0x20(%edi)
  8087dc:	74 20                	je     8087fe <tcp_output+0x6d>
  8087de:	85 db                	test   %ebx,%ebx
  8087e0:	74 27                	je     808809 <tcp_output+0x78>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  8087e2:	8b 43 10             	mov    0x10(%ebx),%eax
  8087e5:	8b 40 04             	mov    0x4(%eax),%eax
  8087e8:	89 04 24             	mov    %eax,(%esp)
  8087eb:	e8 0a f8 ff ff       	call   807ffa <ntohl>
  8087f0:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  8087f4:	2b 57 48             	sub    0x48(%edi),%edx
  8087f7:	01 d0                	add    %edx,%eax
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
  8087f9:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  8087fc:	72 0b                	jb     808809 <tcp_output+0x78>

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  8087fe:	8d 47 04             	lea    0x4(%edi),%eax
  808801:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808804:	e9 92 03 00 00       	jmp    808b9b <tcp_output+0x40a>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808809:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808810:	00 
  808811:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808818:	00 
  808819:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808820:	e8 e0 c6 ff ff       	call   804f05 <pbuf_alloc>
  808825:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808827:	85 c0                	test   %eax,%eax
  808829:	0f 84 d4 03 00 00    	je     808c03 <tcp_output+0x472>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80882f:	80 67 20 fc          	andb   $0xfc,0x20(%edi)

    tcphdr = p->payload;
  808833:	8b 58 04             	mov    0x4(%eax),%ebx
    tcphdr->src = htons(pcb->local_port);
  808836:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  80883a:	89 04 24             	mov    %eax,(%esp)
  80883d:	e8 64 f5 ff ff       	call   807da6 <htons>
  808842:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  808845:	0f b7 47 1e          	movzwl 0x1e(%edi),%eax
  808849:	89 04 24             	mov    %eax,(%esp)
  80884c:	e8 55 f5 ff ff       	call   807da6 <htons>
  808851:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  808855:	8b 47 54             	mov    0x54(%edi),%eax
  808858:	89 04 24             	mov    %eax,(%esp)
  80885b:	e8 60 f5 ff ff       	call   807dc0 <htonl>
  808860:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  808863:	8b 47 24             	mov    0x24(%edi),%eax
  808866:	89 04 24             	mov    %eax,(%esp)
  808869:	e8 52 f5 ff ff       	call   807dc0 <htonl>
  80886e:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  808871:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808875:	89 04 24             	mov    %eax,(%esp)
  808878:	e8 36 f5 ff ff       	call   807db3 <ntohs>
  80887d:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808882:	83 c8 10             	or     $0x10,%eax
  808885:	89 04 24             	mov    %eax,(%esp)
  808888:	e8 19 f5 ff ff       	call   807da6 <htons>
  80888d:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808891:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  808895:	89 04 24             	mov    %eax,(%esp)
  808898:	e8 09 f5 ff ff       	call   807da6 <htons>
  80889d:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  8088a1:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  8088a7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8088ab:	89 04 24             	mov    %eax,(%esp)
  8088ae:	e8 00 f5 ff ff       	call   807db3 <ntohs>
  8088b3:	83 e0 3f             	and    $0x3f,%eax
  8088b6:	80 cc 50             	or     $0x50,%ah
  8088b9:	89 04 24             	mov    %eax,(%esp)
  8088bc:	e8 e5 f4 ff ff       	call   807da6 <htons>
  8088c1:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  8088c5:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  8088cb:	8d 47 04             	lea    0x4(%edi),%eax
  8088ce:	89 c1                	mov    %eax,%ecx
  8088d0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8088d4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8088d8:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8088df:	00 
  8088e0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8088e3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8088e7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8088eb:	89 34 24             	mov    %esi,(%esp)
  8088ee:	e8 6b f1 ff ff       	call   807a5e <inet_chksum_pseudo>
  8088f3:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  8088f7:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8088fe:	00 
  8088ff:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808903:	89 44 24 10          	mov    %eax,0x10(%esp)
  808907:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  80890b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80890f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808912:	89 44 24 08          	mov    %eax,0x8(%esp)
  808916:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80891a:	89 34 24             	mov    %esi,(%esp)
  80891d:	e8 be e6 ff ff       	call   806fe0 <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  808922:	89 34 24             	mov    %esi,(%esp)
  808925:	e8 fa c4 ff ff       	call   804e24 <pbuf_free>

    return ERR_OK;
  80892a:	b8 00 00 00 00       	mov    $0x0,%eax
  80892f:	e9 e9 02 00 00       	jmp    808c1d <tcp_output+0x48c>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  808934:	8b 43 10             	mov    0x10(%ebx),%eax
  808937:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80893b:	89 04 24             	mov    %eax,(%esp)
  80893e:	e8 70 f4 ff ff       	call   807db3 <ntohs>
  808943:	a8 04                	test   $0x4,%al
  808945:	74 1c                	je     808963 <tcp_output+0x1d2>
  808947:	c7 44 24 08 77 32 81 	movl   $0x813277,0x8(%esp)
  80894e:	00 
  80894f:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  808956:	00 
  808957:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  80895e:	e8 37 67 00 00       	call   80f09a <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808963:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808967:	74 1c                	je     808985 <tcp_output+0x1f4>
  808969:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80896d:	a8 40                	test   $0x40,%al
  80896f:	75 14                	jne    808985 <tcp_output+0x1f4>
  808971:	8b 57 74             	mov    0x74(%edi),%edx
  808974:	85 d2                	test   %edx,%edx
  808976:	0f 84 8e 02 00 00    	je     808c0a <tcp_output+0x479>
  80897c:	83 3a 00             	cmpl   $0x0,(%edx)
  80897f:	0f 84 85 02 00 00    	je     808c0a <tcp_output+0x479>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  808985:	8b 03                	mov    (%ebx),%eax
  808987:	89 47 74             	mov    %eax,0x74(%edi)

    if (pcb->state != SYN_SENT) {
  80898a:	83 7f 10 02          	cmpl   $0x2,0x10(%edi)
  80898e:	74 25                	je     8089b5 <tcp_output+0x224>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  808990:	8b 73 10             	mov    0x10(%ebx),%esi
  808993:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  808997:	89 04 24             	mov    %eax,(%esp)
  80899a:	e8 14 f4 ff ff       	call   807db3 <ntohs>
  80899f:	83 c8 10             	or     $0x10,%eax
  8089a2:	0f b7 c0             	movzwl %ax,%eax
  8089a5:	89 04 24             	mov    %eax,(%esp)
  8089a8:	e8 f9 f3 ff ff       	call   807da6 <htons>
  8089ad:	66 89 46 0c          	mov    %ax,0xc(%esi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  8089b1:	80 67 20 fc          	andb   $0xfc,0x20(%edi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  8089b5:	8b 73 10             	mov    0x10(%ebx),%esi
  8089b8:	8b 47 24             	mov    0x24(%edi),%eax
  8089bb:	89 04 24             	mov    %eax,(%esp)
  8089be:	e8 fd f3 ff ff       	call   807dc0 <htonl>
  8089c3:	89 46 08             	mov    %eax,0x8(%esi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  8089c6:	8b 73 10             	mov    0x10(%ebx),%esi
  8089c9:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  8089cd:	89 04 24             	mov    %eax,(%esp)
  8089d0:	e8 d1 f3 ff ff       	call   807da6 <htons>
  8089d5:	66 89 46 0e          	mov    %ax,0xe(%esi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  8089d9:	85 ff                	test   %edi,%edi
  8089db:	74 05                	je     8089e2 <tcp_output+0x251>
  8089dd:	83 3f 00             	cmpl   $0x0,(%edi)
  8089e0:	75 27                	jne    808a09 <tcp_output+0x278>
    netif = ip_route(&(pcb->remote_ip));
  8089e2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8089e5:	89 04 24             	mov    %eax,(%esp)
  8089e8:	e8 23 e1 ff ff       	call   806b10 <ip_route>
    if (netif == NULL) {
  8089ed:	85 c0                	test   %eax,%eax
  8089ef:	0f 84 c1 00 00 00    	je     808ab6 <tcp_output+0x325>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  8089f5:	83 f8 fc             	cmp    $0xfffffffc,%eax
  8089f8:	74 08                	je     808a02 <tcp_output+0x271>
  8089fa:	8b 40 04             	mov    0x4(%eax),%eax
  8089fd:	8d 76 00             	lea    0x0(%esi),%esi
  808a00:	eb 05                	jmp    808a07 <tcp_output+0x276>
  808a02:	b8 00 00 00 00       	mov    $0x0,%eax
  808a07:	89 07                	mov    %eax,(%edi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  808a09:	66 83 7f 32 ff       	cmpw   $0xffff,0x32(%edi)
  808a0e:	75 06                	jne    808a16 <tcp_output+0x285>
    pcb->rtime = 0;
  808a10:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

  if (pcb->rttest == 0) {
  808a16:	83 7f 38 00          	cmpl   $0x0,0x38(%edi)
  808a1a:	75 19                	jne    808a35 <tcp_output+0x2a4>
    pcb->rttest = tcp_ticks;
  808a1c:	a1 60 c2 b3 00       	mov    0xb3c260,%eax
  808a21:	89 47 38             	mov    %eax,0x38(%edi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  808a24:	8b 43 10             	mov    0x10(%ebx),%eax
  808a27:	8b 40 04             	mov    0x4(%eax),%eax
  808a2a:	89 04 24             	mov    %eax,(%esp)
  808a2d:	e8 c8 f5 ff ff       	call   807ffa <ntohl>
  808a32:	89 47 3c             	mov    %eax,0x3c(%edi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  808a35:	8b 43 04             	mov    0x4(%ebx),%eax
  808a38:	8b 53 10             	mov    0x10(%ebx),%edx
  808a3b:	2b 50 04             	sub    0x4(%eax),%edx

  seg->p->len -= len;
  808a3e:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  808a42:	8b 43 04             	mov    0x4(%ebx),%eax
  808a45:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  808a49:	8b 43 04             	mov    0x4(%ebx),%eax
  808a4c:	8b 53 10             	mov    0x10(%ebx),%edx
  808a4f:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  808a52:	8b 43 10             	mov    0x10(%ebx),%eax
  808a55:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a5b:	8b 73 10             	mov    0x10(%ebx),%esi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  808a5e:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  808a61:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  808a65:	89 54 24 10          	mov    %edx,0x10(%esp)
  808a69:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808a70:	00 
  808a71:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808a74:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808a78:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808a7c:	89 04 24             	mov    %eax,(%esp)
  808a7f:	e8 da ef ff ff       	call   807a5e <inet_chksum_pseudo>
  808a84:	66 89 46 10          	mov    %ax,0x10(%esi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  808a88:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808a8f:	00 
  808a90:	0f b6 47 0a          	movzbl 0xa(%edi),%eax
  808a94:	89 44 24 10          	mov    %eax,0x10(%esp)
  808a98:	0f b6 47 0b          	movzbl 0xb(%edi),%eax
  808a9c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808aa0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808aa3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  808aa7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808aab:	8b 43 04             	mov    0x4(%ebx),%eax
  808aae:	89 04 24             	mov    %eax,(%esp)
  808ab1:	e8 2a e5 ff ff       	call   806fe0 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  808ab6:	8b 43 10             	mov    0x10(%ebx),%eax
  808ab9:	8b 40 04             	mov    0x4(%eax),%eax
  808abc:	89 04 24             	mov    %eax,(%esp)
  808abf:	e8 36 f5 ff ff       	call   807ffa <ntohl>
  808ac4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  808ac7:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808acb:	8b 43 10             	mov    0x10(%ebx),%eax
  808ace:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808ad2:	89 04 24             	mov    %eax,(%esp)
  808ad5:	e8 d9 f2 ff ff       	call   807db3 <ntohs>
  808ada:	ba 01 00 00 00       	mov    $0x1,%edx
  808adf:	a8 01                	test   $0x1,%al
  808ae1:	75 17                	jne    808afa <tcp_output+0x369>
  808ae3:	8b 43 10             	mov    0x10(%ebx),%eax
  808ae6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808aea:	89 04 24             	mov    %eax,(%esp)
  808aed:	e8 c1 f2 ff ff       	call   807db3 <ntohs>
  808af2:	66 d1 e8             	shr    %ax
  808af5:	89 c2                	mov    %eax,%edx
  808af7:	83 e2 01             	and    $0x1,%edx
  808afa:	01 d6                	add    %edx,%esi
  808afc:	03 75 e0             	add    -0x20(%ebp),%esi
  808aff:	89 77 54             	mov    %esi,0x54(%edi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  808b02:	39 77 58             	cmp    %esi,0x58(%edi)
  808b05:	79 03                	jns    808b0a <tcp_output+0x379>
      pcb->snd_max = pcb->snd_nxt;
  808b07:	89 77 58             	mov    %esi,0x58(%edi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  808b0a:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  808b0e:	8b 43 10             	mov    0x10(%ebx),%eax
  808b11:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808b15:	89 04 24             	mov    %eax,(%esp)
  808b18:	e8 96 f2 ff ff       	call   807db3 <ntohs>
  808b1d:	ba 01 00 00 00       	mov    $0x1,%edx
  808b22:	a8 01                	test   $0x1,%al
  808b24:	75 17                	jne    808b3d <tcp_output+0x3ac>
  808b26:	8b 43 10             	mov    0x10(%ebx),%eax
  808b29:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  808b2d:	89 04 24             	mov    %eax,(%esp)
  808b30:	e8 7e f2 ff ff       	call   807db3 <ntohs>
  808b35:	66 d1 e8             	shr    %ax
  808b38:	89 c2                	mov    %eax,%edx
  808b3a:	83 e2 01             	and    $0x1,%edx
  808b3d:	01 d6                	add    %edx,%esi
  808b3f:	85 f6                	test   %esi,%esi
  808b41:	7e 4d                	jle    808b90 <tcp_output+0x3ff>
      seg->next = NULL;
  808b43:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  808b49:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  808b4d:	75 08                	jne    808b57 <tcp_output+0x3c6>
        pcb->unacked = seg;
  808b4f:	89 5f 78             	mov    %ebx,0x78(%edi)
  808b52:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808b55:	eb 41                	jmp    808b98 <tcp_output+0x407>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  808b57:	8b 43 10             	mov    0x10(%ebx),%eax
  808b5a:	8b 40 04             	mov    0x4(%eax),%eax
  808b5d:	89 04 24             	mov    %eax,(%esp)
  808b60:	e8 95 f4 ff ff       	call   807ffa <ntohl>
  808b65:	89 c6                	mov    %eax,%esi
  808b67:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808b6a:	8b 40 10             	mov    0x10(%eax),%eax
  808b6d:	8b 40 04             	mov    0x4(%eax),%eax
  808b70:	89 04 24             	mov    %eax,(%esp)
  808b73:	e8 82 f4 ff ff       	call   807ffa <ntohl>
  808b78:	39 c6                	cmp    %eax,%esi
  808b7a:	79 0a                	jns    808b86 <tcp_output+0x3f5>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  808b7c:	8b 47 78             	mov    0x78(%edi),%eax
  808b7f:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  808b81:	89 5f 78             	mov    %ebx,0x78(%edi)
  808b84:	eb 12                	jmp    808b98 <tcp_output+0x407>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  808b86:	8b 45 dc             	mov    -0x24(%ebp),%eax
  808b89:	89 18                	mov    %ebx,(%eax)
  808b8b:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  808b8e:	eb 08                	jmp    808b98 <tcp_output+0x407>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  808b90:	89 1c 24             	mov    %ebx,(%esp)
  808b93:	e8 61 d2 ff ff       	call   805df9 <tcp_seg_free>
    }
    seg = pcb->unsent;
  808b98:	8b 5f 74             	mov    0x74(%edi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808b9b:	85 db                	test   %ebx,%ebx
  808b9d:	74 52                	je     808bf1 <tcp_output+0x460>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  808b9f:	8b 43 10             	mov    0x10(%ebx),%eax
  808ba2:	8b 40 04             	mov    0x4(%eax),%eax
  808ba5:	89 04 24             	mov    %eax,(%esp)
  808ba8:	e8 4d f4 ff ff       	call   807ffa <ntohl>
  808bad:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808bb1:	2b 57 48             	sub    0x48(%edi),%edx
  808bb4:	01 d0                	add    %edx,%eax
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  808bb6:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  808bb9:	0f 83 75 fd ff ff    	jae    808934 <tcp_output+0x1a3>
  808bbf:	eb 51                	jmp    808c12 <tcp_output+0x481>
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  808bc1:	8b 43 10             	mov    0x10(%ebx),%eax
  808bc4:	8b 40 04             	mov    0x4(%eax),%eax
  808bc7:	89 04 24             	mov    %eax,(%esp)
  808bca:	e8 2b f4 ff ff       	call   807ffa <ntohl>
  808bcf:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  808bd3:	2b 57 48             	sub    0x48(%edi),%edx
  808bd6:	01 c2                	add    %eax,%edx
  808bd8:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808bdc:	39 c2                	cmp    %eax,%edx
  808bde:	76 11                	jbe    808bf1 <tcp_output+0x460>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  808be0:	c7 87 a0 00 00 00 00 	movl   $0x0,0xa0(%edi)
  808be7:	00 00 00 
    pcb->persist_backoff = 1;
  808bea:	c6 87 a4 00 00 00 01 	movb   $0x1,0xa4(%edi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  808bf1:	80 67 20 7f          	andb   $0x7f,0x20(%edi)
  return ERR_OK;
  808bf5:	b8 00 00 00 00       	mov    $0x0,%eax
  808bfa:	eb 21                	jmp    808c1d <tcp_output+0x48c>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  808bfc:	b8 00 00 00 00       	mov    $0x0,%eax
  808c01:	eb 1a                	jmp    808c1d <tcp_output+0x48c>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  808c03:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  808c08:	eb 13                	jmp    808c1d <tcp_output+0x48c>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  808c0a:	a8 a0                	test   $0xa0,%al
  808c0c:	0f 85 73 fd ff ff    	jne    808985 <tcp_output+0x1f4>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  808c12:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  808c19:	75 d6                	jne    808bf1 <tcp_output+0x460>
  808c1b:	eb a4                	jmp    808bc1 <tcp_output+0x430>
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  808c1d:	83 c4 3c             	add    $0x3c,%esp
  808c20:	5b                   	pop    %ebx
  808c21:	5e                   	pop    %esi
  808c22:	5f                   	pop    %edi
  808c23:	5d                   	pop    %ebp
  808c24:	c3                   	ret    

00808c25 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  808c25:	55                   	push   %ebp
  808c26:	89 e5                	mov    %esp,%ebp
  808c28:	57                   	push   %edi
  808c29:	56                   	push   %esi
  808c2a:	53                   	push   %ebx
  808c2b:	83 ec 2c             	sub    $0x2c,%esp
  808c2e:	8b 7d 18             	mov    0x18(%ebp),%edi
  808c31:	8b 45 1c             	mov    0x1c(%ebp),%eax
  808c34:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808c37:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808c3e:	00 
  808c3f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808c46:	00 
  808c47:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808c4e:	e8 b2 c2 ff ff       	call   804f05 <pbuf_alloc>
  808c53:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  808c55:	85 c0                	test   %eax,%eax
  808c57:	0f 84 1a 01 00 00    	je     808d77 <tcp_rst+0x152>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808c5d:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808c62:	77 1c                	ja     808c80 <tcp_rst+0x5b>
  808c64:	c7 44 24 08 10 32 81 	movl   $0x813210,0x8(%esp)
  808c6b:	00 
  808c6c:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  808c73:	00 
  808c74:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808c7b:	e8 1a 64 00 00       	call   80f09a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808c80:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  808c83:	0f b7 ff             	movzwl %di,%edi
  808c86:	89 3c 24             	mov    %edi,(%esp)
  808c89:	e8 18 f1 ff ff       	call   807da6 <htons>
  808c8e:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  808c91:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  808c95:	89 04 24             	mov    %eax,(%esp)
  808c98:	e8 09 f1 ff ff       	call   807da6 <htons>
  808c9d:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  808ca1:	8b 45 08             	mov    0x8(%ebp),%eax
  808ca4:	89 04 24             	mov    %eax,(%esp)
  808ca7:	e8 14 f1 ff ff       	call   807dc0 <htonl>
  808cac:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  808caf:	8b 45 0c             	mov    0xc(%ebp),%eax
  808cb2:	89 04 24             	mov    %eax,(%esp)
  808cb5:	e8 06 f1 ff ff       	call   807dc0 <htonl>
  808cba:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  808cbd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808cc1:	89 04 24             	mov    %eax,(%esp)
  808cc4:	e8 ea f0 ff ff       	call   807db3 <ntohs>
  808cc9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808cce:	83 c8 14             	or     $0x14,%eax
  808cd1:	89 04 24             	mov    %eax,(%esp)
  808cd4:	e8 cd f0 ff ff       	call   807da6 <htons>
  808cd9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  808cdd:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  808ce4:	e8 bd f0 ff ff       	call   807da6 <htons>
  808ce9:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808ced:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808cf3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808cf7:	89 04 24             	mov    %eax,(%esp)
  808cfa:	e8 b4 f0 ff ff       	call   807db3 <ntohs>
  808cff:	83 e0 3f             	and    $0x3f,%eax
  808d02:	80 cc 50             	or     $0x50,%ah
  808d05:	89 04 24             	mov    %eax,(%esp)
  808d08:	e8 99 f0 ff ff       	call   807da6 <htons>
  808d0d:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808d11:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  808d17:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  808d1b:	89 44 24 10          	mov    %eax,0x10(%esp)
  808d1f:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808d26:	00 
  808d27:	8b 45 14             	mov    0x14(%ebp),%eax
  808d2a:	89 44 24 08          	mov    %eax,0x8(%esp)
  808d2e:	8b 45 10             	mov    0x10(%ebp),%eax
  808d31:	89 44 24 04          	mov    %eax,0x4(%esp)
  808d35:	89 34 24             	mov    %esi,(%esp)
  808d38:	e8 21 ed ff ff       	call   807a5e <inet_chksum_pseudo>
  808d3d:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  808d41:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808d48:	00 
  808d49:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808d50:	00 
  808d51:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  808d58:	00 
  808d59:	8b 45 14             	mov    0x14(%ebp),%eax
  808d5c:	89 44 24 08          	mov    %eax,0x8(%esp)
  808d60:	8b 45 10             	mov    0x10(%ebp),%eax
  808d63:	89 44 24 04          	mov    %eax,0x4(%esp)
  808d67:	89 34 24             	mov    %esi,(%esp)
  808d6a:	e8 71 e2 ff ff       	call   806fe0 <ip_output>
  pbuf_free(p);
  808d6f:	89 34 24             	mov    %esi,(%esp)
  808d72:	e8 ad c0 ff ff       	call   804e24 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  808d77:	83 c4 2c             	add    $0x2c,%esp
  808d7a:	5b                   	pop    %ebx
  808d7b:	5e                   	pop    %esi
  808d7c:	5f                   	pop    %edi
  808d7d:	5d                   	pop    %ebp
  808d7e:	c3                   	ret    

00808d7f <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  808d7f:	55                   	push   %ebp
  808d80:	89 e5                	mov    %esp,%ebp
  808d82:	53                   	push   %ebx
  808d83:	83 ec 14             	sub    $0x14,%esp
  808d86:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808d89:	8b 53 78             	mov    0x78(%ebx),%edx
  808d8c:	85 d2                	test   %edx,%edx
  808d8e:	74 40                	je     808dd0 <tcp_rexmit_rto+0x51>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  808d90:	8b 02                	mov    (%edx),%eax
  808d92:	85 c0                	test   %eax,%eax
  808d94:	74 04                	je     808d9a <tcp_rexmit_rto+0x1b>
  808d96:	89 c2                	mov    %eax,%edx
  808d98:	eb f6                	jmp    808d90 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  808d9a:	8b 43 74             	mov    0x74(%ebx),%eax
  808d9d:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  808d9f:	8b 43 78             	mov    0x78(%ebx),%eax
  808da2:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  808da5:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808dac:	8b 40 10             	mov    0x10(%eax),%eax
  808daf:	8b 40 04             	mov    0x4(%eax),%eax
  808db2:	89 04 24             	mov    %eax,(%esp)
  808db5:	e8 40 f2 ff ff       	call   807ffa <ntohl>
  808dba:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  808dbd:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  808dc1:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  808dc8:	89 1c 24             	mov    %ebx,(%esp)
  808dcb:	e8 c1 f9 ff ff       	call   808791 <tcp_output>
}
  808dd0:	83 c4 14             	add    $0x14,%esp
  808dd3:	5b                   	pop    %ebx
  808dd4:	5d                   	pop    %ebp
  808dd5:	c3                   	ret    

00808dd6 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  808dd6:	55                   	push   %ebp
  808dd7:	89 e5                	mov    %esp,%ebp
  808dd9:	53                   	push   %ebx
  808dda:	83 ec 14             	sub    $0x14,%esp
  808ddd:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  808de0:	8b 43 78             	mov    0x78(%ebx),%eax
  808de3:	85 c0                	test   %eax,%eax
  808de5:	74 34                	je     808e1b <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  808de7:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  808de9:	8b 4b 74             	mov    0x74(%ebx),%ecx
  808dec:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  808dee:	8b 43 78             	mov    0x78(%ebx),%eax
  808df1:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  808df4:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  808df7:	8b 40 10             	mov    0x10(%eax),%eax
  808dfa:	8b 40 04             	mov    0x4(%eax),%eax
  808dfd:	89 04 24             	mov    %eax,(%esp)
  808e00:	e8 f5 f1 ff ff       	call   807ffa <ntohl>
  808e05:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  808e08:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  808e0c:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  808e13:	89 1c 24             	mov    %ebx,(%esp)
  808e16:	e8 76 f9 ff ff       	call   808791 <tcp_output>
}
  808e1b:	83 c4 14             	add    $0x14,%esp
  808e1e:	5b                   	pop    %ebx
  808e1f:	5d                   	pop    %ebp
  808e20:	c3                   	ret    

00808e21 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  808e21:	55                   	push   %ebp
  808e22:	89 e5                	mov    %esp,%ebp
  808e24:	57                   	push   %edi
  808e25:	56                   	push   %esi
  808e26:	53                   	push   %ebx
  808e27:	83 ec 2c             	sub    $0x2c,%esp
  808e2a:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  808e2d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808e34:	00 
  808e35:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  808e3c:	00 
  808e3d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808e44:	e8 bc c0 ff ff       	call   804f05 <pbuf_alloc>
  808e49:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808e4b:	85 c0                	test   %eax,%eax
  808e4d:	0f 84 1a 01 00 00    	je     808f6d <tcp_keepalive+0x14c>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808e53:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808e58:	77 1c                	ja     808e76 <tcp_keepalive+0x55>
  808e5a:	c7 44 24 08 10 32 81 	movl   $0x813210,0x8(%esp)
  808e61:	00 
  808e62:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  808e69:	00 
  808e6a:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808e71:	e8 24 62 00 00       	call   80f09a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808e76:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808e79:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808e7d:	89 04 24             	mov    %eax,(%esp)
  808e80:	e8 21 ef ff ff       	call   807da6 <htons>
  808e85:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808e88:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808e8c:	89 04 24             	mov    %eax,(%esp)
  808e8f:	e8 12 ef ff ff       	call   807da6 <htons>
  808e94:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  808e98:	8b 46 54             	mov    0x54(%esi),%eax
  808e9b:	83 e8 01             	sub    $0x1,%eax
  808e9e:	89 04 24             	mov    %eax,(%esp)
  808ea1:	e8 1a ef ff ff       	call   807dc0 <htonl>
  808ea6:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  808ea9:	8b 46 24             	mov    0x24(%esi),%eax
  808eac:	89 04 24             	mov    %eax,(%esp)
  808eaf:	e8 0c ef ff ff       	call   807dc0 <htonl>
  808eb4:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  808eb7:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808ebb:	89 04 24             	mov    %eax,(%esp)
  808ebe:	e8 f0 ee ff ff       	call   807db3 <ntohs>
  808ec3:	25 c0 ff 00 00       	and    $0xffc0,%eax
  808ec8:	89 04 24             	mov    %eax,(%esp)
  808ecb:	e8 d6 ee ff ff       	call   807da6 <htons>
  808ed0:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  808ed4:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  808ed8:	89 04 24             	mov    %eax,(%esp)
  808edb:	e8 c6 ee ff ff       	call   807da6 <htons>
  808ee0:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  808ee4:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  808eea:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  808eee:	89 04 24             	mov    %eax,(%esp)
  808ef1:	e8 bd ee ff ff       	call   807db3 <ntohs>
  808ef6:	83 e0 3f             	and    $0x3f,%eax
  808ef9:	80 cc 50             	or     $0x50,%ah
  808efc:	89 04 24             	mov    %eax,(%esp)
  808eff:	e8 a2 ee ff ff       	call   807da6 <htons>
  808f04:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  808f08:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  808f0e:	8d 46 04             	lea    0x4(%esi),%eax
  808f11:	89 c2                	mov    %eax,%edx
  808f13:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  808f17:	89 44 24 10          	mov    %eax,0x10(%esp)
  808f1b:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  808f22:	00 
  808f23:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  808f26:	89 54 24 08          	mov    %edx,0x8(%esp)
  808f2a:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f2e:	89 3c 24             	mov    %edi,(%esp)
  808f31:	e8 28 eb ff ff       	call   807a5e <inet_chksum_pseudo>
  808f36:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  808f3a:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  808f41:	00 
  808f42:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  808f49:	00 
  808f4a:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  808f4e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  808f52:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808f55:	89 44 24 08          	mov    %eax,0x8(%esp)
  808f59:	89 74 24 04          	mov    %esi,0x4(%esp)
  808f5d:	89 3c 24             	mov    %edi,(%esp)
  808f60:	e8 7b e0 ff ff       	call   806fe0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  808f65:	89 3c 24             	mov    %edi,(%esp)
  808f68:	e8 b7 be ff ff       	call   804e24 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  808f6d:	83 c4 2c             	add    $0x2c,%esp
  808f70:	5b                   	pop    %ebx
  808f71:	5e                   	pop    %esi
  808f72:	5f                   	pop    %edi
  808f73:	5d                   	pop    %ebp
  808f74:	c3                   	ret    

00808f75 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  808f75:	55                   	push   %ebp
  808f76:	89 e5                	mov    %esp,%ebp
  808f78:	57                   	push   %edi
  808f79:	56                   	push   %esi
  808f7a:	53                   	push   %ebx
  808f7b:	83 ec 2c             	sub    $0x2c,%esp
  808f7e:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  808f81:	8b 46 78             	mov    0x78(%esi),%eax
  808f84:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808f87:	85 c0                	test   %eax,%eax
  808f89:	75 0e                	jne    808f99 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  808f8b:	8b 46 74             	mov    0x74(%esi),%eax
  808f8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  808f91:	85 c0                	test   %eax,%eax
  808f93:	0f 84 4a 01 00 00    	je     8090e3 <tcp_zero_window_probe+0x16e>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  808f99:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808fa0:	00 
  808fa1:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  808fa8:	00 
  808fa9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808fb0:	e8 50 bf ff ff       	call   804f05 <pbuf_alloc>
  808fb5:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  808fb7:	85 c0                	test   %eax,%eax
  808fb9:	0f 84 24 01 00 00    	je     8090e3 <tcp_zero_window_probe+0x16e>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  808fbf:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  808fc4:	77 1c                	ja     808fe2 <tcp_zero_window_probe+0x6d>
  808fc6:	c7 44 24 08 10 32 81 	movl   $0x813210,0x8(%esp)
  808fcd:	00 
  808fce:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  808fd5:	00 
  808fd6:	c7 04 24 3e 32 81 00 	movl   $0x81323e,(%esp)
  808fdd:	e8 b8 60 00 00       	call   80f09a <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  808fe2:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  808fe5:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  808fe9:	89 04 24             	mov    %eax,(%esp)
  808fec:	e8 b5 ed ff ff       	call   807da6 <htons>
  808ff1:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  808ff4:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  808ff8:	89 04 24             	mov    %eax,(%esp)
  808ffb:	e8 a6 ed ff ff       	call   807da6 <htons>
  809000:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  809004:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809007:	8b 40 10             	mov    0x10(%eax),%eax
  80900a:	8b 40 04             	mov    0x4(%eax),%eax
  80900d:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  809010:	8b 46 24             	mov    0x24(%esi),%eax
  809013:	89 04 24             	mov    %eax,(%esp)
  809016:	e8 a5 ed ff ff       	call   807dc0 <htonl>
  80901b:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80901e:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  809022:	89 04 24             	mov    %eax,(%esp)
  809025:	e8 89 ed ff ff       	call   807db3 <ntohs>
  80902a:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80902f:	89 04 24             	mov    %eax,(%esp)
  809032:	e8 6f ed ff ff       	call   807da6 <htons>
  809037:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80903b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80903f:	89 04 24             	mov    %eax,(%esp)
  809042:	e8 5f ed ff ff       	call   807da6 <htons>
  809047:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80904b:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  809051:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  809055:	89 04 24             	mov    %eax,(%esp)
  809058:	e8 56 ed ff ff       	call   807db3 <ntohs>
  80905d:	83 e0 3f             	and    $0x3f,%eax
  809060:	80 cc 50             	or     $0x50,%ah
  809063:	89 04 24             	mov    %eax,(%esp)
  809066:	e8 3b ed ff ff       	call   807da6 <htons>
  80906b:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80906f:	8b 47 04             	mov    0x4(%edi),%eax
  809072:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809075:	8b 51 08             	mov    0x8(%ecx),%edx
  809078:	0f b6 12             	movzbl (%edx),%edx
  80907b:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80907e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  809084:	8d 46 04             	lea    0x4(%esi),%eax
  809087:	89 c1                	mov    %eax,%ecx
  809089:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80908d:	89 44 24 10          	mov    %eax,0x10(%esp)
  809091:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  809098:	00 
  809099:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80909c:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8090a0:	89 74 24 04          	mov    %esi,0x4(%esp)
  8090a4:	89 3c 24             	mov    %edi,(%esp)
  8090a7:	e8 b2 e9 ff ff       	call   807a5e <inet_chksum_pseudo>
  8090ac:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  8090b0:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  8090b7:	00 
  8090b8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8090bf:	00 
  8090c0:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  8090c4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8090c8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8090cb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8090cf:	89 74 24 04          	mov    %esi,0x4(%esp)
  8090d3:	89 3c 24             	mov    %edi,(%esp)
  8090d6:	e8 05 df ff ff       	call   806fe0 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  8090db:	89 3c 24             	mov    %edi,(%esp)
  8090de:	e8 41 bd ff ff       	call   804e24 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  8090e3:	83 c4 2c             	add    $0x2c,%esp
  8090e6:	5b                   	pop    %ebx
  8090e7:	5e                   	pop    %esi
  8090e8:	5f                   	pop    %edi
  8090e9:	5d                   	pop    %ebp
  8090ea:	c3                   	ret    
  8090eb:	66 90                	xchg   %ax,%ax
  8090ed:	66 90                	xchg   %ax,%ax
  8090ef:	90                   	nop

008090f0 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  8090f0:	55                   	push   %ebp
  8090f1:	89 e5                	mov    %esp,%ebp
  8090f3:	57                   	push   %edi
  8090f4:	56                   	push   %esi
  8090f5:	53                   	push   %ebx
  8090f6:	83 ec 3c             	sub    $0x3c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  8090f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8090fc:	8b 40 04             	mov    0x4(%eax),%eax
  8090ff:	89 c7                	mov    %eax,%edi
  809101:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  809104:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809107:	0f b7 59 08          	movzwl 0x8(%ecx),%ebx
  80910b:	0f b7 00             	movzwl (%eax),%eax
  80910e:	89 04 24             	mov    %eax,(%esp)
  809111:	e8 9d ec ff ff       	call   807db3 <ntohs>
  809116:	66 c1 e8 08          	shr    $0x8,%ax
  80911a:	83 e0 0f             	and    $0xf,%eax
  80911d:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  809124:	39 c3                	cmp    %eax,%ebx
  809126:	7c 28                	jl     809150 <udp_input+0x60>
  809128:	0f b7 07             	movzwl (%edi),%eax
  80912b:	89 04 24             	mov    %eax,(%esp)
  80912e:	e8 80 ec ff ff       	call   807db3 <ntohs>
  809133:	66 c1 e8 06          	shr    $0x6,%ax
  809137:	83 e0 3c             	and    $0x3c,%eax
  80913a:	f7 d8                	neg    %eax
  80913c:	98                   	cwtl   
  80913d:	89 44 24 04          	mov    %eax,0x4(%esp)
  809141:	8b 45 08             	mov    0x8(%ebp),%eax
  809144:	89 04 24             	mov    %eax,(%esp)
  809147:	e8 f4 bb ff ff       	call   804d40 <pbuf_header>
  80914c:	84 c0                	test   %al,%al
  80914e:	74 10                	je     809160 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  809150:	8b 45 08             	mov    0x8(%ebp),%eax
  809153:	89 04 24             	mov    %eax,(%esp)
  809156:	e8 c9 bc ff ff       	call   804e24 <pbuf_free>
    goto end;
  80915b:	e9 09 03 00 00       	jmp    809469 <udp_input+0x379>
  }

  udphdr = (struct udp_hdr *)p->payload;
  809160:	8b 45 08             	mov    0x8(%ebp),%eax
  809163:	8b 40 04             	mov    0x4(%eax),%eax
  809166:	89 c6                	mov    %eax,%esi
  809168:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80916b:	0f b7 00             	movzwl (%eax),%eax
  80916e:	89 04 24             	mov    %eax,(%esp)
  809171:	e8 3d ec ff ff       	call   807db3 <ntohs>
  809176:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  dest = ntohs(udphdr->dest);
  80917a:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80917e:	89 04 24             	mov    %eax,(%esp)
  809181:	e8 2d ec ff ff       	call   807db3 <ntohs>
  809186:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  809188:	66 83 f8 44          	cmp    $0x44,%ax
  80918c:	75 5a                	jne    8091e8 <udp_input+0xf8>
  80918e:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  809195:	66 83 7d de 43       	cmpw   $0x43,-0x22(%ebp)
  80919a:	0f 85 14 01 00 00    	jne    8092b4 <udp_input+0x1c4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  8091a0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8091a3:	8b 40 20             	mov    0x20(%eax),%eax
  8091a6:	85 c0                	test   %eax,%eax
  8091a8:	0f 84 ff 00 00 00    	je     8092ad <udp_input+0x1bd>
  8091ae:	8b 40 08             	mov    0x8(%eax),%eax
  8091b1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  8091b4:	85 c0                	test   %eax,%eax
  8091b6:	0f 84 f8 00 00 00    	je     8092b4 <udp_input+0x1c4>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  8091bc:	83 f8 fc             	cmp    $0xfffffffc,%eax
  8091bf:	0f 84 01 01 00 00    	je     8092c6 <udp_input+0x1d6>
  8091c5:	8b 40 04             	mov    0x4(%eax),%eax
  8091c8:	85 c0                	test   %eax,%eax
  8091ca:	0f 84 f6 00 00 00    	je     8092c6 <udp_input+0x1d6>
  8091d0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8091d3:	3b 41 0c             	cmp    0xc(%ecx),%eax
  8091d6:	0f 84 ea 00 00 00    	je     8092c6 <udp_input+0x1d6>
  8091dc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8091e3:	e9 cc 00 00 00       	jmp    8092b4 <udp_input+0x1c4>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  8091e8:	8b 1d 74 c2 b3 00    	mov    0xb3c274,%ebx
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  8091ee:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  8091f5:	bf 00 00 00 00       	mov    $0x0,%edi
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  8091fa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8091fd:	83 c0 10             	add    $0x10,%eax
  809200:	89 45 d8             	mov    %eax,-0x28(%ebp)
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809203:	e9 95 00 00 00       	jmp    80929d <udp_input+0x1ad>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  809208:	66 39 73 12          	cmp    %si,0x12(%ebx)
  80920c:	0f 85 86 00 00 00    	jne    809298 <udp_input+0x1a8>
  809212:	85 db                	test   %ebx,%ebx
  809214:	74 24                	je     80923a <udp_input+0x14a>
          (ip_addr_isany(&pcb->local_ip) ||
  809216:	8b 03                	mov    (%ebx),%eax
  809218:	85 c0                	test   %eax,%eax
  80921a:	74 1e                	je     80923a <udp_input+0x14a>
  80921c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80921f:	3b 41 10             	cmp    0x10(%ecx),%eax
  809222:	74 16                	je     80923a <udp_input+0x14a>
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  809224:	8b 45 0c             	mov    0xc(%ebp),%eax
  809227:	89 44 24 04          	mov    %eax,0x4(%esp)
  80922b:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80922e:	89 04 24             	mov    %eax,(%esp)
  809231:	e8 8b d8 ff ff       	call   806ac1 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  809236:	84 c0                	test   %al,%al
  809238:	74 5e                	je     809298 <udp_input+0x1a8>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80923a:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80923e:	0f 85 0a 02 00 00    	jne    80944e <udp_input+0x35e>
  809244:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  809248:	83 e0 04             	and    $0x4,%eax
  80924b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80924e:	0f 44 c3             	cmove  %ebx,%eax
  809251:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809254:	e9 f5 01 00 00       	jmp    80944e <udp_input+0x35e>
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  809259:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80925c:	74 13                	je     809271 <udp_input+0x181>
          (ip_addr_isany(&pcb->remote_ip) ||
  80925e:	8b 43 04             	mov    0x4(%ebx),%eax
  809261:	85 c0                	test   %eax,%eax
  809263:	74 10                	je     809275 <udp_input+0x185>
  809265:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809268:	3b 42 0c             	cmp    0xc(%edx),%eax
  80926b:	75 2b                	jne    809298 <udp_input+0x1a8>
  80926d:	89 d8                	mov    %ebx,%eax
  80926f:	eb 06                	jmp    809277 <udp_input+0x187>
  809271:	89 d8                	mov    %ebx,%eax
  809273:	eb 02                	jmp    809277 <udp_input+0x187>
  809275:	89 d8                	mov    %ebx,%eax
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  809277:	85 ff                	test   %edi,%edi
  809279:	0f 84 e2 01 00 00    	je     809461 <udp_input+0x371>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80927f:	8b 50 0c             	mov    0xc(%eax),%edx
  809282:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  809285:	8b 15 74 c2 b3 00    	mov    0xb3c274,%edx
  80928b:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  80928e:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  809293:	e9 c9 01 00 00       	jmp    809461 <udp_input+0x371>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  809298:	89 df                	mov    %ebx,%edi
  80929a:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80929d:	85 db                	test   %ebx,%ebx
  80929f:	0f 85 63 ff ff ff    	jne    809208 <udp_input+0x118>
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  8092a5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  8092a9:	75 1b                	jne    8092c6 <udp_input+0x1d6>
  8092ab:	eb 07                	jmp    8092b4 <udp_input+0x1c4>
  8092ad:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  8092b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8092b7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8092ba:	8b 49 10             	mov    0x10(%ecx),%ecx
  8092bd:	39 48 04             	cmp    %ecx,0x4(%eax)
  8092c0:	0f 85 7b 01 00 00    	jne    809441 <udp_input+0x351>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  8092c6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8092c9:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  8092ce:	74 48                	je     809318 <udp_input+0x228>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  8092d0:	8b 45 08             	mov    0x8(%ebp),%eax
  8092d3:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8092d7:	89 44 24 10          	mov    %eax,0x10(%esp)
  8092db:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  8092e2:	00 
  8092e3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8092e6:	89 d0                	mov    %edx,%eax
  8092e8:	83 c0 10             	add    $0x10,%eax
  8092eb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8092ef:	89 d0                	mov    %edx,%eax
  8092f1:	83 c0 0c             	add    $0xc,%eax
  8092f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8092f8:	8b 45 08             	mov    0x8(%ebp),%eax
  8092fb:	89 04 24             	mov    %eax,(%esp)
  8092fe:	e8 5b e7 ff ff       	call   807a5e <inet_chksum_pseudo>
  809303:	66 85 c0             	test   %ax,%ax
  809306:	74 10                	je     809318 <udp_input+0x228>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  809308:	8b 45 08             	mov    0x8(%ebp),%eax
  80930b:	89 04 24             	mov    %eax,(%esp)
  80930e:	e8 11 bb ff ff       	call   804e24 <pbuf_free>
          goto end;
  809313:	e9 51 01 00 00       	jmp    809469 <udp_input+0x379>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  809318:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80931f:	ff 
  809320:	8b 45 08             	mov    0x8(%ebp),%eax
  809323:	89 04 24             	mov    %eax,(%esp)
  809326:	e8 15 ba ff ff       	call   804d40 <pbuf_header>
  80932b:	84 c0                	test   %al,%al
  80932d:	74 1c                	je     80934b <udp_input+0x25b>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80932f:	c7 44 24 08 63 32 81 	movl   $0x813263,0x8(%esp)
  809336:	00 
  809337:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80933e:	00 
  80933f:	c7 04 24 8e 32 81 00 	movl   $0x81328e,(%esp)
  809346:	e8 4f 5d 00 00       	call   80f09a <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80934b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80934e:	85 c9                	test   %ecx,%ecx
  809350:	74 43                	je     809395 <udp_input+0x2a5>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  809352:	8b 41 18             	mov    0x18(%ecx),%eax
  809355:	85 c0                	test   %eax,%eax
  809357:	74 2a                	je     809383 <udp_input+0x293>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  809359:	0f b7 55 de          	movzwl -0x22(%ebp),%edx
  80935d:	89 54 24 10          	mov    %edx,0x10(%esp)
  809361:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809364:	83 c2 0c             	add    $0xc,%edx
  809367:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80936b:	8b 55 08             	mov    0x8(%ebp),%edx
  80936e:	89 54 24 08          	mov    %edx,0x8(%esp)
  809372:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809376:	8b 51 1c             	mov    0x1c(%ecx),%edx
  809379:	89 14 24             	mov    %edx,(%esp)
  80937c:	ff d0                	call   *%eax
  80937e:	e9 e6 00 00 00       	jmp    809469 <udp_input+0x379>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  809383:	8b 45 08             	mov    0x8(%ebp),%eax
  809386:	89 04 24             	mov    %eax,(%esp)
  809389:	e8 96 ba ff ff       	call   804e24 <pbuf_free>
        goto end;
  80938e:	66 90                	xchg   %ax,%ax
  809390:	e9 d4 00 00 00       	jmp    809469 <udp_input+0x379>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  809395:	8b 45 0c             	mov    0xc(%ebp),%eax
  809398:	89 44 24 04          	mov    %eax,0x4(%esp)
  80939c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80939f:	89 f0                	mov    %esi,%eax
  8093a1:	83 c0 10             	add    $0x10,%eax
  8093a4:	89 04 24             	mov    %eax,(%esp)
  8093a7:	e8 15 d7 ff ff       	call   806ac1 <ip_addr_isbroadcast>
  8093ac:	84 c0                	test   %al,%al
  8093ae:	0f 85 80 00 00 00    	jne    809434 <udp_input+0x344>
          !ip_addr_ismulticast(&iphdr->dest)) {
  8093b4:	8b 5e 10             	mov    0x10(%esi),%ebx
  8093b7:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  8093be:	e8 37 ec ff ff       	call   807ffa <ntohl>
  8093c3:	21 c3                	and    %eax,%ebx
  8093c5:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  8093cc:	e8 29 ec ff ff       	call   807ffa <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  8093d1:	39 c3                	cmp    %eax,%ebx
  8093d3:	74 5f                	je     809434 <udp_input+0x344>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  8093d5:	0f b7 06             	movzwl (%esi),%eax
  8093d8:	89 04 24             	mov    %eax,(%esp)
  8093db:	e8 d3 e9 ff ff       	call   807db3 <ntohs>
  8093e0:	66 c1 e8 08          	shr    $0x8,%ax
  8093e4:	83 e0 0f             	and    $0xf,%eax
  8093e7:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  8093ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8093f2:	8b 45 08             	mov    0x8(%ebp),%eax
  8093f5:	89 04 24             	mov    %eax,(%esp)
  8093f8:	e8 43 b9 ff ff       	call   804d40 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  8093fd:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809400:	39 71 04             	cmp    %esi,0x4(%ecx)
  809403:	74 1c                	je     809421 <udp_input+0x331>
  809405:	c7 44 24 08 a2 32 81 	movl   $0x8132a2,0x8(%esp)
  80940c:	00 
  80940d:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  809414:	00 
  809415:	c7 04 24 8e 32 81 00 	movl   $0x81328e,(%esp)
  80941c:	e8 79 5c 00 00       	call   80f09a <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  809421:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  809428:	00 
  809429:	8b 45 08             	mov    0x8(%ebp),%eax
  80942c:	89 04 24             	mov    %eax,(%esp)
  80942f:	e8 e1 59 00 00       	call   80ee15 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  809434:	8b 45 08             	mov    0x8(%ebp),%eax
  809437:	89 04 24             	mov    %eax,(%esp)
  80943a:	e8 e5 b9 ff ff       	call   804e24 <pbuf_free>
  80943f:	eb 28                	jmp    809469 <udp_input+0x379>
    }
  } else {
    pbuf_free(p);
  809441:	8b 45 08             	mov    0x8(%ebp),%eax
  809444:	89 04 24             	mov    %eax,(%esp)
  809447:	e8 d8 b9 ff ff       	call   804e24 <pbuf_free>
  80944c:	eb 1b                	jmp    809469 <udp_input+0x379>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80944e:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  809452:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  809456:	0f 85 3c fe ff ff    	jne    809298 <udp_input+0x1a8>
  80945c:	e9 f8 fd ff ff       	jmp    809259 <udp_input+0x169>
  809461:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  809464:	e9 5d fe ff ff       	jmp    8092c6 <udp_input+0x1d6>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  809469:	83 c4 3c             	add    $0x3c,%esp
  80946c:	5b                   	pop    %ebx
  80946d:	5e                   	pop    %esi
  80946e:	5f                   	pop    %edi
  80946f:	5d                   	pop    %ebp
  809470:	c3                   	ret    

00809471 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809471:	55                   	push   %ebp
  809472:	89 e5                	mov    %esp,%ebp
  809474:	57                   	push   %edi
  809475:	56                   	push   %esi
  809476:	53                   	push   %ebx
  809477:	83 ec 1c             	sub    $0x1c,%esp
  80947a:	8b 55 08             	mov    0x8(%ebp),%edx
  80947d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809480:	8b 45 10             	mov    0x10(%ebp),%eax
  809483:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809486:	89 c1                	mov    %eax,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809488:	a1 74 c2 b3 00       	mov    0xb3c274,%eax

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  80948d:	be 00 00 00 00       	mov    $0x0,%esi
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  809492:	eb 2e                	jmp    8094c2 <udp_bind+0x51>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  809494:	39 c2                	cmp    %eax,%edx
  809496:	75 27                	jne    8094bf <udp_bind+0x4e>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  809498:	89 f3                	mov    %esi,%ebx
  80949a:	84 db                	test   %bl,%bl
  80949c:	74 1c                	je     8094ba <udp_bind+0x49>
  80949e:	c7 44 24 08 b6 32 81 	movl   $0x8132b6,0x8(%esp)
  8094a5:	00 
  8094a6:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  8094ad:	00 
  8094ae:	c7 04 24 8e 32 81 00 	movl   $0x81328e,(%esp)
  8094b5:	e8 e0 5b 00 00       	call   80f09a <_panic>
      /* pcb already in list, just rebind */
      rebind = 1;
  8094ba:	be 01 00 00 00       	mov    $0x1,%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8094bf:	8b 40 0c             	mov    0xc(%eax),%eax
  8094c2:	85 c0                	test   %eax,%eax
  8094c4:	75 ce                	jne    809494 <udp_bind+0x23>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  8094c6:	85 ff                	test   %edi,%edi
  8094c8:	74 04                	je     8094ce <udp_bind+0x5d>
  8094ca:	8b 07                	mov    (%edi),%eax
  8094cc:	eb 05                	jmp    8094d3 <udp_bind+0x62>
  8094ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8094d3:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  8094d5:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  8094da:	75 36                	jne    809512 <udp_bind+0xa1>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  8094dc:	8b 3d 74 c2 b3 00    	mov    0xb3c274,%edi
  8094e2:	89 f8                	mov    %edi,%eax
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  8094e4:	b9 00 10 00 00       	mov    $0x1000,%ecx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8094e9:	eb 13                	jmp    8094fe <udp_bind+0x8d>
      if (ipcb->local_port == port) {
  8094eb:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  8094ef:	66 39 cb             	cmp    %cx,%bx
  8094f2:	75 07                	jne    8094fb <udp_bind+0x8a>
        /* port is already used by another udp_pcb */
        port++;
  8094f4:	8d 4b 01             	lea    0x1(%ebx),%ecx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  8094f7:	89 f8                	mov    %edi,%eax
  8094f9:	eb 03                	jmp    8094fe <udp_bind+0x8d>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  8094fb:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  8094fe:	85 c0                	test   %eax,%eax
  809500:	0f 95 c3             	setne  %bl
  809503:	66 81 f9 ff 7f       	cmp    $0x7fff,%cx
  809508:	74 04                	je     80950e <udp_bind+0x9d>
  80950a:	84 db                	test   %bl,%bl
  80950c:	75 dd                	jne    8094eb <udp_bind+0x7a>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80950e:	84 db                	test   %bl,%bl
  809510:	75 24                	jne    809536 <udp_bind+0xc5>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  809512:	66 89 4a 12          	mov    %cx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  809516:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80951b:	89 f1                	mov    %esi,%ecx
  80951d:	84 c9                	test   %cl,%cl
  80951f:	75 1a                	jne    80953b <udp_bind+0xca>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  809521:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  809526:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  809529:	89 15 74 c2 b3 00    	mov    %edx,0xb3c274
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  80952f:	b8 00 00 00 00       	mov    $0x0,%eax
  809534:	eb 05                	jmp    80953b <udp_bind+0xca>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  809536:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80953b:	83 c4 1c             	add    $0x1c,%esp
  80953e:	5b                   	pop    %ebx
  80953f:	5e                   	pop    %esi
  809540:	5f                   	pop    %edi
  809541:	5d                   	pop    %ebp
  809542:	c3                   	ret    

00809543 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  809543:	55                   	push   %ebp
  809544:	89 e5                	mov    %esp,%ebp
  809546:	57                   	push   %edi
  809547:	56                   	push   %esi
  809548:	53                   	push   %ebx
  809549:	83 ec 2c             	sub    $0x2c,%esp
  80954c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80954f:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  809552:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  809557:	75 1c                	jne    809575 <udp_sendto_if+0x32>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  809559:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809560:	00 
  809561:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809565:	89 1c 24             	mov    %ebx,(%esp)
  809568:	e8 04 ff ff ff       	call   809471 <udp_bind>
    if (err != ERR_OK) {
  80956d:	84 c0                	test   %al,%al
  80956f:	0f 85 76 01 00 00    	jne    8096eb <udp_sendto_if+0x1a8>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  809575:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80957c:	00 
  80957d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809580:	89 04 24             	mov    %eax,(%esp)
  809583:	e8 b8 b7 ff ff       	call   804d40 <pbuf_header>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  809588:	8b 75 0c             	mov    0xc(%ebp),%esi
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80958b:	84 c0                	test   %al,%al
  80958d:	74 35                	je     8095c4 <udp_sendto_if+0x81>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80958f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809596:	00 
  809597:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80959e:	00 
  80959f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  8095a6:	e8 5a b9 ff ff       	call   804f05 <pbuf_alloc>
  8095ab:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  8095ad:	85 c0                	test   %eax,%eax
  8095af:	0f 84 31 01 00 00    	je     8096e6 <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  8095b5:	8b 45 0c             	mov    0xc(%ebp),%eax
  8095b8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8095bc:	89 34 24             	mov    %esi,(%esp)
  8095bf:	e8 96 bd ff ff       	call   80535a <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  8095c4:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  8095c9:	77 1c                	ja     8095e7 <udp_sendto_if+0xa4>
  8095cb:	c7 44 24 08 c4 32 81 	movl   $0x8132c4,0x8(%esp)
  8095d2:	00 
  8095d3:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  8095da:	00 
  8095db:	c7 04 24 8e 32 81 00 	movl   $0x81328e,(%esp)
  8095e2:	e8 b3 5a 00 00       	call   80f09a <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  8095e7:	8b 46 04             	mov    0x4(%esi),%eax
  8095ea:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  udphdr->src = htons(pcb->local_port);
  8095ed:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  8095f1:	89 04 24             	mov    %eax,(%esp)
  8095f4:	e8 ad e7 ff ff       	call   807da6 <htons>
  8095f9:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8095fc:	66 89 01             	mov    %ax,(%ecx)
  udphdr->dest = htons(dst_port);
  8095ff:	0f b7 ff             	movzwl %di,%edi
  809602:	89 3c 24             	mov    %edi,(%esp)
  809605:	e8 9c e7 ff ff       	call   807da6 <htons>
  80960a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80960d:	66 89 41 02          	mov    %ax,0x2(%ecx)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  809611:	66 c7 41 06 00 00    	movw   $0x0,0x6(%ecx)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  809617:	89 df                	mov    %ebx,%edi
  809619:	85 db                	test   %ebx,%ebx
  80961b:	74 06                	je     809623 <udp_sendto_if+0xe0>
  80961d:	8b 03                	mov    (%ebx),%eax
  80961f:	85 c0                	test   %eax,%eax
  809621:	75 08                	jne    80962b <udp_sendto_if+0xe8>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  809623:	8b 45 18             	mov    0x18(%ebp),%eax
  809626:	8d 78 04             	lea    0x4(%eax),%edi
  809629:	eb 28                	jmp    809653 <udp_sendto_if+0x110>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80962b:	8b 55 18             	mov    0x18(%ebp),%edx
  80962e:	3b 42 04             	cmp    0x4(%edx),%eax
  809631:	74 20                	je     809653 <udp_sendto_if+0x110>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  809633:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  809638:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80963b:	0f 84 aa 00 00 00    	je     8096eb <udp_sendto_if+0x1a8>
        /* free the header pbuf */
        pbuf_free(q);
  809641:	89 34 24             	mov    %esi,(%esp)
  809644:	e8 db b7 ff ff       	call   804e24 <pbuf_free>
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  809649:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80964e:	e9 98 00 00 00       	jmp    8096eb <udp_sendto_if+0x1a8>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  809653:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809657:	89 04 24             	mov    %eax,(%esp)
  80965a:	e8 47 e7 ff ff       	call   807da6 <htons>
  80965f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809662:	66 89 42 04          	mov    %ax,0x4(%edx)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  809666:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80966a:	75 35                	jne    8096a1 <udp_sendto_if+0x15e>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80966c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  809670:	89 44 24 10          	mov    %eax,0x10(%esp)
  809674:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80967b:	00 
  80967c:	8b 45 10             	mov    0x10(%ebp),%eax
  80967f:	89 44 24 08          	mov    %eax,0x8(%esp)
  809683:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809687:	89 34 24             	mov    %esi,(%esp)
  80968a:	e8 cf e3 ff ff       	call   807a5e <inet_chksum_pseudo>
  80968f:	66 85 c0             	test   %ax,%ax
  809692:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  809697:	0f 44 c2             	cmove  %edx,%eax
  80969a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80969d:	66 89 42 06          	mov    %ax,0x6(%edx)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  8096a1:	8b 45 18             	mov    0x18(%ebp),%eax
  8096a4:	89 44 24 18          	mov    %eax,0x18(%esp)
  8096a8:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  8096af:	00 
  8096b0:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  8096b4:	89 44 24 10          	mov    %eax,0x10(%esp)
  8096b8:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  8096bc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8096c0:	8b 45 10             	mov    0x10(%ebp),%eax
  8096c3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8096c7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8096cb:	89 34 24             	mov    %esi,(%esp)
  8096ce:	e8 7b d7 ff ff       	call   806e4e <ip_output_if>
  8096d3:	89 c3                	mov    %eax,%ebx
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  8096d5:	3b 75 0c             	cmp    0xc(%ebp),%esi
  8096d8:	74 11                	je     8096eb <udp_sendto_if+0x1a8>
    /* free the header pbuf */
    pbuf_free(q);
  8096da:	89 34 24             	mov    %esi,(%esp)
  8096dd:	e8 42 b7 ff ff       	call   804e24 <pbuf_free>
    q = NULL;
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
  8096e2:	89 d8                	mov    %ebx,%eax
  8096e4:	eb 05                	jmp    8096eb <udp_sendto_if+0x1a8>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  8096e6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  8096eb:	83 c4 2c             	add    $0x2c,%esp
  8096ee:	5b                   	pop    %ebx
  8096ef:	5e                   	pop    %esi
  8096f0:	5f                   	pop    %edi
  8096f1:	5d                   	pop    %ebp
  8096f2:	c3                   	ret    

008096f3 <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  8096f3:	55                   	push   %ebp
  8096f4:	89 e5                	mov    %esp,%ebp
  8096f6:	56                   	push   %esi
  8096f7:	53                   	push   %ebx
  8096f8:	83 ec 20             	sub    $0x20,%esp
  8096fb:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8096fe:	8b 75 14             	mov    0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  809701:	89 1c 24             	mov    %ebx,(%esp)
  809704:	e8 07 d4 ff ff       	call   806b10 <ip_route>
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  809709:	85 c0                	test   %eax,%eax
  80970b:	74 23                	je     809730 <udp_sendto+0x3d>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80970d:	89 44 24 10          	mov    %eax,0x10(%esp)
  809711:	0f b7 f6             	movzwl %si,%esi
  809714:	89 74 24 0c          	mov    %esi,0xc(%esp)
  809718:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80971c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80971f:	89 44 24 04          	mov    %eax,0x4(%esp)
  809723:	8b 45 08             	mov    0x8(%ebp),%eax
  809726:	89 04 24             	mov    %eax,(%esp)
  809729:	e8 15 fe ff ff       	call   809543 <udp_sendto_if>
  80972e:	eb 05                	jmp    809735 <udp_sendto+0x42>

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  809730:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
}
  809735:	83 c4 20             	add    $0x20,%esp
  809738:	5b                   	pop    %ebx
  809739:	5e                   	pop    %esi
  80973a:	5d                   	pop    %ebp
  80973b:	c3                   	ret    

0080973c <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80973c:	55                   	push   %ebp
  80973d:	89 e5                	mov    %esp,%ebp
  80973f:	83 ec 18             	sub    $0x18,%esp
  809742:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  809745:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  809749:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80974d:	8d 50 04             	lea    0x4(%eax),%edx
  809750:	89 54 24 08          	mov    %edx,0x8(%esp)
  809754:	8b 55 0c             	mov    0xc(%ebp),%edx
  809757:	89 54 24 04          	mov    %edx,0x4(%esp)
  80975b:	89 04 24             	mov    %eax,(%esp)
  80975e:	e8 90 ff ff ff       	call   8096f3 <udp_sendto>
}
  809763:	c9                   	leave  
  809764:	c3                   	ret    

00809765 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809765:	55                   	push   %ebp
  809766:	89 e5                	mov    %esp,%ebp
  809768:	57                   	push   %edi
  809769:	56                   	push   %esi
  80976a:	53                   	push   %ebx
  80976b:	83 ec 1c             	sub    $0x1c,%esp
  80976e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809771:	8b 75 0c             	mov    0xc(%ebp),%esi
  809774:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  809777:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80977c:	75 1a                	jne    809798 <udp_connect+0x33>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80977e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809785:	00 
  809786:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80978a:	89 1c 24             	mov    %ebx,(%esp)
  80978d:	e8 df fc ff ff       	call   809471 <udp_bind>
  809792:	89 c2                	mov    %eax,%edx
    if (err != ERR_OK)
  809794:	84 d2                	test   %dl,%dl
  809796:	75 3f                	jne    8097d7 <udp_connect+0x72>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  809798:	85 f6                	test   %esi,%esi
  80979a:	74 06                	je     8097a2 <udp_connect+0x3d>
  80979c:	8b 06                	mov    (%esi),%eax
  80979e:	66 90                	xchg   %ax,%ax
  8097a0:	eb 05                	jmp    8097a7 <udp_connect+0x42>
  8097a2:	b8 00 00 00 00       	mov    $0x0,%eax
  8097a7:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  8097aa:	66 89 7b 14          	mov    %di,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  8097ae:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8097b2:	8b 15 74 c2 b3 00    	mov    0xb3c274,%edx
  8097b8:	89 d0                	mov    %edx,%eax
  8097ba:	eb 07                	jmp    8097c3 <udp_connect+0x5e>
    if (pcb == ipcb) {
  8097bc:	39 c3                	cmp    %eax,%ebx
  8097be:	74 12                	je     8097d2 <udp_connect+0x6d>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  8097c0:	8b 40 0c             	mov    0xc(%eax),%eax
  8097c3:	85 c0                	test   %eax,%eax
  8097c5:	75 f5                	jne    8097bc <udp_connect+0x57>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  8097c7:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  8097ca:	89 1d 74 c2 b3 00    	mov    %ebx,0xb3c274
  return ERR_OK;
  8097d0:	eb 05                	jmp    8097d7 <udp_connect+0x72>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  8097d2:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  8097d7:	83 c4 1c             	add    $0x1c,%esp
  8097da:	5b                   	pop    %ebx
  8097db:	5e                   	pop    %esi
  8097dc:	5f                   	pop    %edi
  8097dd:	5d                   	pop    %ebp
  8097de:	c3                   	ret    

008097df <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  8097df:	55                   	push   %ebp
  8097e0:	89 e5                	mov    %esp,%ebp
  8097e2:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  8097e5:	8b 15 00 2f 81 00    	mov    0x812f00,%edx
  8097eb:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  8097ee:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  8097f4:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  8097f8:	5d                   	pop    %ebp
  8097f9:	c3                   	ret    

008097fa <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  8097fa:	55                   	push   %ebp
  8097fb:	89 e5                	mov    %esp,%ebp
  8097fd:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  809800:	8b 55 0c             	mov    0xc(%ebp),%edx
  809803:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  809806:	8b 55 10             	mov    0x10(%ebp),%edx
  809809:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80980c:	5d                   	pop    %ebp
  80980d:	c3                   	ret    

0080980e <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80980e:	55                   	push   %ebp
  80980f:	89 e5                	mov    %esp,%ebp
  809811:	83 ec 18             	sub    $0x18,%esp
  809814:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  809817:	a1 74 c2 b3 00       	mov    0xb3c274,%eax
  80981c:	39 c8                	cmp    %ecx,%eax
  80981e:	75 1e                	jne    80983e <udp_remove+0x30>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  809820:	8b 40 0c             	mov    0xc(%eax),%eax
  809823:	a3 74 c2 b3 00       	mov    %eax,0xb3c274
  809828:	eb 18                	jmp    809842 <udp_remove+0x34>
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80982a:	8b 50 0c             	mov    0xc(%eax),%edx
  80982d:	85 d2                	test   %edx,%edx
  80982f:	74 0a                	je     80983b <udp_remove+0x2d>
  809831:	39 d1                	cmp    %edx,%ecx
  809833:	75 06                	jne    80983b <udp_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  809835:	8b 51 0c             	mov    0xc(%ecx),%edx
  809838:	89 50 0c             	mov    %edx,0xc(%eax)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80983b:	8b 40 0c             	mov    0xc(%eax),%eax
  80983e:	85 c0                	test   %eax,%eax
  809840:	75 e8                	jne    80982a <udp_remove+0x1c>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  809842:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  809846:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80984d:	e8 20 b2 ff ff       	call   804a72 <memp_free>
}
  809852:	c9                   	leave  
  809853:	c3                   	ret    

00809854 <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  809854:	55                   	push   %ebp
  809855:	89 e5                	mov    %esp,%ebp
  809857:	53                   	push   %ebx
  809858:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80985b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809862:	e8 ab b1 ff ff       	call   804a12 <memp_malloc>
  809867:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  809869:	85 c0                	test   %eax,%eax
  80986b:	74 1c                	je     809889 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80986d:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  809874:	00 
  809875:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80987c:	00 
  80987d:	89 04 24             	mov    %eax,(%esp)
  809880:	e8 82 60 00 00       	call   80f907 <memset>
    pcb->ttl = UDP_TTL;
  809885:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  809889:	89 d8                	mov    %ebx,%eax
  80988b:	83 c4 14             	add    $0x14,%esp
  80988e:	5b                   	pop    %ebx
  80988f:	5d                   	pop    %ebp
  809890:	c3                   	ret    
  809891:	66 90                	xchg   %ax,%ax
  809893:	66 90                	xchg   %ax,%ax
  809895:	66 90                	xchg   %ax,%ax
  809897:	66 90                	xchg   %ax,%ax
  809899:	66 90                	xchg   %ax,%ax
  80989b:	66 90                	xchg   %ax,%ax
  80989d:	66 90                	xchg   %ax,%ax
  80989f:	90                   	nop

008098a0 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  8098a0:	55                   	push   %ebp
  8098a1:	89 e5                	mov    %esp,%ebp
  8098a3:	56                   	push   %esi
  8098a4:	53                   	push   %ebx
  8098a5:	83 ec 10             	sub    $0x10,%esp
  8098a8:	89 c3                	mov    %eax,%ebx
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  8098aa:	85 c0                	test   %eax,%eax
  8098ac:	75 1c                	jne    8098ca <free_etharp_q+0x2a>
  8098ae:	c7 44 24 08 08 2a 81 	movl   $0x812a08,0x8(%esp)
  8098b5:	00 
  8098b6:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  8098bd:	00 
  8098be:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  8098c5:	e8 d0 57 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  8098ca:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8098ce:	75 1c                	jne    8098ec <free_etharp_q+0x4c>
  8098d0:	c7 44 24 08 0a 33 81 	movl   $0x81330a,0x8(%esp)
  8098d7:	00 
  8098d8:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  8098df:	00 
  8098e0:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  8098e7:	e8 ae 57 00 00       	call   80f09a <_panic>
  while (q) {
    r = q;
    q = q->next;
  8098ec:	8b 33                	mov    (%ebx),%esi
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  8098ee:	8b 43 04             	mov    0x4(%ebx),%eax
  8098f1:	85 c0                	test   %eax,%eax
  8098f3:	75 1c                	jne    809911 <free_etharp_q+0x71>
  8098f5:	c7 44 24 08 17 33 81 	movl   $0x813317,0x8(%esp)
  8098fc:	00 
  8098fd:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  809904:	00 
  809905:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  80990c:	e8 89 57 00 00       	call   80f09a <_panic>
    pbuf_free(r->p);
  809911:	89 04 24             	mov    %eax,(%esp)
  809914:	e8 0b b5 ff ff       	call   804e24 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  809919:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80991d:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809924:	e8 49 b1 ff ff       	call   804a72 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  809929:	85 f6                	test   %esi,%esi
  80992b:	74 04                	je     809931 <free_etharp_q+0x91>
    r = q;
    q = q->next;
  80992d:	89 f3                	mov    %esi,%ebx
  80992f:	eb bb                	jmp    8098ec <free_etharp_q+0x4c>
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  809931:	83 c4 10             	add    $0x10,%esp
  809934:	5b                   	pop    %ebx
  809935:	5e                   	pop    %esi
  809936:	5d                   	pop    %ebp
  809937:	c3                   	ret    

00809938 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  809938:	55                   	push   %ebp
  809939:	89 e5                	mov    %esp,%ebp
  80993b:	57                   	push   %edi
  80993c:	56                   	push   %esi
  80993d:	53                   	push   %ebx
  80993e:	83 ec 2c             	sub    $0x2c,%esp
  809941:	89 c3                	mov    %eax,%ebx
  809943:	89 55 dc             	mov    %edx,-0x24(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  809946:	85 c0                	test   %eax,%eax
  809948:	75 2f                	jne    809979 <find_entry+0x41>
  80994a:	ba 54 5a b3 00       	mov    $0xb35a54,%edx
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
          old_pending = i;
          age_pending = arp_table[i].ctime;
  80994f:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809953:	c6 45 e0 0a          	movb   $0xa,-0x20(%ebp)
  809957:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  80995b:	c6 45 db 00          	movb   $0x0,-0x25(%ebp)
  80995f:	b9 00 00 00 00       	mov    $0x0,%ecx
  809964:	b8 0a 00 00 00       	mov    $0xa,%eax
  809969:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
  80996d:	c6 45 da 0a          	movb   $0xa,-0x26(%ebp)
  809971:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  809974:	e9 b8 00 00 00       	jmp    809a31 <find_entry+0xf9>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  809979:	0f b6 05 20 5a b3 00 	movzbl 0xb35a20,%eax
  809980:	0f b6 d0             	movzbl %al,%edx
  809983:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809986:	83 b9 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%ecx)
  80998d:	75 bb                	jne    80994a <find_entry+0x12>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80998f:	8b b9 44 5a b3 00    	mov    0xb35a44(%ecx),%edi
  809995:	39 3b                	cmp    %edi,(%ebx)
  809997:	75 b1                	jne    80994a <find_entry+0x12>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  809999:	e9 a7 01 00 00       	jmp    809b45 <find_entry+0x20d>
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80999e:	3c 0a                	cmp    $0xa,%al
  8099a0:	75 0a                	jne    8099ac <find_entry+0x74>
  8099a2:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  8099a6:	75 04                	jne    8099ac <find_entry+0x74>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  8099a8:	89 c8                	mov    %ecx,%eax
  8099aa:	eb 7f                	jmp    809a2b <find_entry+0xf3>
  8099ac:	89 d7                	mov    %edx,%edi
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  8099ae:	8b 72 fc             	mov    -0x4(%edx),%esi
  8099b1:	83 fe 01             	cmp    $0x1,%esi
  8099b4:	75 45                	jne    8099fb <find_entry+0xc3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  8099b6:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8099b9:	85 f6                	test   %esi,%esi
  8099bb:	74 14                	je     8099d1 <find_entry+0x99>
  8099bd:	8b 5a f0             	mov    -0x10(%edx),%ebx
  8099c0:	39 1e                	cmp    %ebx,(%esi)
  8099c2:	75 0d                	jne    8099d1 <find_entry+0x99>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  8099c4:	88 0d 20 5a b3 00    	mov    %cl,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  8099ca:	89 c8                	mov    %ecx,%eax
  8099cc:	e9 74 01 00 00       	jmp    809b45 <find_entry+0x20d>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  8099d1:	83 7f ec 00          	cmpl   $0x0,-0x14(%edi)
  8099d5:	74 12                	je     8099e9 <find_entry+0xb1>
        if (arp_table[i].ctime >= age_queue) {
  8099d7:	0f b6 37             	movzbl (%edi),%esi
  8099da:	89 f3                	mov    %esi,%ebx
  8099dc:	38 5d e3             	cmp    %bl,-0x1d(%ebp)
  8099df:	77 4a                	ja     809a2b <find_entry+0xf3>
          old_queue = i;
  8099e1:	88 4d e0             	mov    %cl,-0x20(%ebp)
          age_queue = arp_table[i].ctime;
  8099e4:	88 5d e3             	mov    %bl,-0x1d(%ebp)
  8099e7:	eb 42                	jmp    809a2b <find_entry+0xf3>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  8099e9:	0f b6 37             	movzbl (%edi),%esi
  8099ec:	89 f3                	mov    %esi,%ebx
  8099ee:	38 5d db             	cmp    %bl,-0x25(%ebp)
  8099f1:	77 38                	ja     809a2b <find_entry+0xf3>
          old_pending = i;
  8099f3:	88 4d da             	mov    %cl,-0x26(%ebp)
          age_pending = arp_table[i].ctime;
  8099f6:	88 5d db             	mov    %bl,-0x25(%ebp)
  8099f9:	eb 30                	jmp    809a2b <find_entry+0xf3>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  8099fb:	83 fe 02             	cmp    $0x2,%esi
  8099fe:	75 2b                	jne    809a2b <find_entry+0xf3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  809a00:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  809a03:	85 f6                	test   %esi,%esi
  809a05:	74 14                	je     809a1b <find_entry+0xe3>
  809a07:	8b 5a f0             	mov    -0x10(%edx),%ebx
  809a0a:	39 1e                	cmp    %ebx,(%esi)
  809a0c:	75 0d                	jne    809a1b <find_entry+0xe3>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  809a0e:	88 0d 20 5a b3 00    	mov    %cl,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  809a14:	89 c8                	mov    %ecx,%eax
  809a16:	e9 2a 01 00 00       	jmp    809b45 <find_entry+0x20d>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  809a1b:	0f b6 37             	movzbl (%edi),%esi
  809a1e:	89 f3                	mov    %esi,%ebx
  809a20:	38 5d e2             	cmp    %bl,-0x1e(%ebp)
  809a23:	77 06                	ja     809a2b <find_entry+0xf3>
        old_stable = i;
  809a25:	88 4d e1             	mov    %cl,-0x1f(%ebp)
        age_stable = arp_table[i].ctime;
  809a28:	88 5d e2             	mov    %bl,-0x1e(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809a2b:	83 c1 01             	add    $0x1,%ecx
  809a2e:	83 c2 1c             	add    $0x1c,%edx
  809a31:	80 f9 0a             	cmp    $0xa,%cl
  809a34:	0f 85 64 ff ff ff    	jne    80999e <find_entry+0x66>
  809a3a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  809a3d:	3c 0a                	cmp    $0xa,%al
  809a3f:	75 0f                	jne    809a50 <find_entry+0x118>
  809a41:	f6 45 dc 01          	testb  $0x1,-0x24(%ebp)
  809a45:	0f 85 ee 00 00 00    	jne    809b39 <find_entry+0x201>
  809a4b:	e9 cd 00 00 00       	jmp    809b1d <find_entry+0x1e5>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809a50:	f6 45 dc 02          	testb  $0x2,-0x24(%ebp)
  809a54:	0f 85 ca 00 00 00    	jne    809b24 <find_entry+0x1ec>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  809a5a:	89 c6                	mov    %eax,%esi
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  809a5c:	3c 09                	cmp    $0x9,%al
  809a5e:	66 90                	xchg   %ax,%ax
  809a60:	7e 68                	jle    809aca <find_entry+0x192>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  809a62:	80 7d e1 09          	cmpb   $0x9,-0x1f(%ebp)
  809a66:	7f 31                	jg     809a99 <find_entry+0x161>
    /* recycle oldest stable*/
    i = old_stable;
  809a68:	0f b6 45 e1          	movzbl -0x1f(%ebp),%eax
  809a6c:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  809a6e:	0f b6 c0             	movzbl %al,%eax
  809a71:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809a74:	83 b8 40 5a b3 00 00 	cmpl   $0x0,0xb35a40(%eax)
  809a7b:	74 4d                	je     809aca <find_entry+0x192>
  809a7d:	c7 44 24 08 24 33 81 	movl   $0x813324,0x8(%esp)
  809a84:	00 
  809a85:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  809a8c:	00 
  809a8d:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809a94:	e8 01 56 00 00       	call   80f09a <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  809a99:	80 7d da 09          	cmpb   $0x9,-0x26(%ebp)
  809a9d:	7f 06                	jg     809aa5 <find_entry+0x16d>
    /* recycle oldest pending */
    i = old_pending;
  809a9f:	0f b6 75 da          	movzbl -0x26(%ebp),%esi
  809aa3:	eb 25                	jmp    809aca <find_entry+0x192>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  809aa5:	0f b6 45 e0          	movzbl -0x20(%ebp),%eax
  809aa9:	3c 09                	cmp    $0x9,%al
  809aab:	7f 7e                	jg     809b2b <find_entry+0x1f3>
    /* recycle oldest pending */
    i = old_queue;
  809aad:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  809aaf:	0f b6 f8             	movzbl %al,%edi
  809ab2:	6b ff 1c             	imul   $0x1c,%edi,%edi
  809ab5:	8b 87 40 5a b3 00    	mov    0xb35a40(%edi),%eax
  809abb:	e8 e0 fd ff ff       	call   8098a0 <free_etharp_q>
    arp_table[i].q = NULL;
  809ac0:	c7 87 40 5a b3 00 00 	movl   $0x0,0xb35a40(%edi)
  809ac7:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  809aca:	89 f0                	mov    %esi,%eax
  809acc:	3c 09                	cmp    $0x9,%al
  809ace:	76 1c                	jbe    809aec <find_entry+0x1b4>
  809ad0:	c7 44 24 08 3b 33 81 	movl   $0x81333b,0x8(%esp)
  809ad7:	00 
  809ad8:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  809adf:	00 
  809ae0:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809ae7:	e8 ae 55 00 00       	call   80f09a <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  809aec:	89 f0                	mov    %esi,%eax
  809aee:	0f b6 c0             	movzbl %al,%eax
  809af1:	6b d0 1c             	imul   $0x1c,%eax,%edx
  809af4:	c7 82 50 5a b3 00 00 	movl   $0x0,0xb35a50(%edx)
  809afb:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  809afe:	85 db                	test   %ebx,%ebx
  809b00:	74 08                	je     809b0a <find_entry+0x1d2>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  809b02:	8b 0b                	mov    (%ebx),%ecx
  809b04:	89 8a 44 5a b3 00    	mov    %ecx,0xb35a44(%edx)
  }
  arp_table[i].ctime = 0;
  809b0a:	6b c0 1c             	imul   $0x1c,%eax,%eax
  809b0d:	c6 80 54 5a b3 00 00 	movb   $0x0,0xb35a54(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  809b14:	89 f0                	mov    %esi,%eax
  809b16:	a2 20 5a b3 00       	mov    %al,0xb35a20
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  809b1b:	eb 28                	jmp    809b45 <find_entry+0x20d>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809b1d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809b22:	eb 21                	jmp    809b45 <find_entry+0x20d>
  809b24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809b29:	eb 1a                	jmp    809b45 <find_entry+0x20d>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  809b2b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809b30:	eb 13                	jmp    809b45 <find_entry+0x20d>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  809b32:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809b37:	eb 0c                	jmp    809b45 <find_entry+0x20d>
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
  809b39:	f6 45 dc 02          	testb  $0x2,-0x24(%ebp)
  809b3d:	0f 84 1f ff ff ff    	je     809a62 <find_entry+0x12a>
  809b43:	eb ed                	jmp    809b32 <find_entry+0x1fa>
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  809b45:	83 c4 2c             	add    $0x2c,%esp
  809b48:	5b                   	pop    %ebx
  809b49:	5e                   	pop    %esi
  809b4a:	5f                   	pop    %edi
  809b4b:	5d                   	pop    %ebp
  809b4c:	c3                   	ret    

00809b4d <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  809b4d:	55                   	push   %ebp
  809b4e:	89 e5                	mov    %esp,%ebp
  809b50:	57                   	push   %edi
  809b51:	56                   	push   %esi
  809b52:	53                   	push   %ebx
  809b53:	83 ec 2c             	sub    $0x2c,%esp
  809b56:	89 c6                	mov    %eax,%esi
  809b58:	89 55 e0             	mov    %edx,-0x20(%ebp)
  809b5b:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  809b5e:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809b61:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  809b65:	74 1c                	je     809b83 <etharp_send_ip+0x36>
  809b67:	c7 44 24 08 68 33 81 	movl   $0x813368,0x8(%esp)
  809b6e:	00 
  809b6f:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  809b76:	00 
  809b77:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809b7e:	e8 17 55 00 00       	call   80f09a <_panic>
  809b83:	b8 06 00 00 00       	mov    $0x6,%eax
  809b88:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  809b8b:	83 e8 01             	sub    $0x1,%eax
    ethhdr->dest.addr[k] = dst->addr[k];
  809b8e:	0f b6 d0             	movzbl %al,%edx
  809b91:	0f b6 0c 17          	movzbl (%edi,%edx,1),%ecx
  809b95:	88 0c 13             	mov    %cl,(%ebx,%edx,1)
    ethhdr->src.addr[k]  = src->addr[k];
  809b98:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809b9b:	0f b6 0c 11          	movzbl (%ecx,%edx,1),%ecx
  809b9f:	88 4c 13 06          	mov    %cl,0x6(%ebx,%edx,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  809ba3:	84 c0                	test   %al,%al
  809ba5:	75 e4                	jne    809b8b <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  809ba7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809bae:	e8 f3 e1 ff ff       	call   807da6 <htons>
  809bb3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  809bb7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  809bba:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bbe:	89 34 24             	mov    %esi,(%esp)
  809bc1:	ff 56 18             	call   *0x18(%esi)
}
  809bc4:	83 c4 2c             	add    $0x2c,%esp
  809bc7:	5b                   	pop    %ebx
  809bc8:	5e                   	pop    %esi
  809bc9:	5f                   	pop    %edi
  809bca:	5d                   	pop    %ebp
  809bcb:	c3                   	ret    

00809bcc <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  809bcc:	55                   	push   %ebp
  809bcd:	89 e5                	mov    %esp,%ebp
  809bcf:	57                   	push   %edi
  809bd0:	56                   	push   %esi
  809bd1:	53                   	push   %ebx
  809bd2:	83 ec 2c             	sub    $0x2c,%esp
  809bd5:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809bd8:	89 cb                	mov    %ecx,%ebx
  809bda:	8b 4d 08             	mov    0x8(%ebp),%ecx
  809bdd:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  809be0:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809be4:	74 1c                	je     809c02 <update_arp_entry+0x36>
  809be6:	c7 44 24 08 ac 33 81 	movl   $0x8133ac,0x8(%esp)
  809bed:	00 
  809bee:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  809bf5:	00 
  809bf6:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809bfd:	e8 98 54 00 00       	call   80f09a <_panic>
  809c02:	89 d6                	mov    %edx,%esi
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809c04:	85 d2                	test   %edx,%edx
  809c06:	0f 84 e2 00 00 00    	je     809cee <update_arp_entry+0x122>
  809c0c:	83 3a 00             	cmpl   $0x0,(%edx)
  809c0f:	0f 84 e0 00 00 00    	je     809cf5 <update_arp_entry+0x129>
      ip_addr_isbroadcast(ipaddr, netif) ||
  809c15:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809c18:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c1c:	89 14 24             	mov    %edx,(%esp)
  809c1f:	e8 9d ce ff ff       	call   806ac1 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  809c24:	84 c0                	test   %al,%al
  809c26:	0f 85 d0 00 00 00    	jne    809cfc <update_arp_entry+0x130>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  809c2c:	8b 3e                	mov    (%esi),%edi
  809c2e:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809c35:	e8 c0 e3 ff ff       	call   807ffa <ntohl>
  809c3a:	21 c7                	and    %eax,%edi
  809c3c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809c43:	e8 b2 e3 ff ff       	call   807ffa <ntohl>
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
  809c48:	39 c7                	cmp    %eax,%edi
  809c4a:	0f 84 b3 00 00 00    	je     809d03 <update_arp_entry+0x137>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  809c50:	0f b6 55 e0          	movzbl -0x20(%ebp),%edx
  809c54:	89 f0                	mov    %esi,%eax
  809c56:	e8 dd fc ff ff       	call   809938 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  809c5b:	84 c0                	test   %al,%al
  809c5d:	0f 88 a5 00 00 00    	js     809d08 <update_arp_entry+0x13c>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  809c63:	0f be f8             	movsbl %al,%edi
  809c66:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c69:	c7 80 50 5a b3 00 02 	movl   $0x2,0xb35a50(%eax)
  809c70:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  809c73:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  809c76:	89 88 58 5a b3 00    	mov    %ecx,0xb35a58(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  809c7c:	ba 06 00 00 00       	mov    $0x6,%edx
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809c81:	89 c6                	mov    %eax,%esi

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  809c83:	83 ea 01             	sub    $0x1,%edx
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  809c86:	0f b6 c2             	movzbl %dl,%eax
  809c89:	0f b6 0c 03          	movzbl (%ebx,%eax,1),%ecx
  809c8d:	88 8c 30 48 5a b3 00 	mov    %cl,0xb35a48(%eax,%esi,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  809c94:	84 d2                	test   %dl,%dl
  809c96:	75 eb                	jne    809c83 <update_arp_entry+0xb7>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  809c98:	6b c7 1c             	imul   $0x1c,%edi,%eax
  809c9b:	c6 80 54 5a b3 00 00 	movb   $0x0,0xb35a54(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809ca2:	89 c7                	mov    %eax,%edi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809ca4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809ca7:	83 c0 25             	add    $0x25,%eax
  809caa:	89 45 e0             	mov    %eax,-0x20(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809cad:	eb 33                	jmp    809ce2 <update_arp_entry+0x116>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  809caf:	8b 10                	mov    (%eax),%edx
  809cb1:	89 97 40 5a b3 00    	mov    %edx,0xb35a40(%edi)
    /* get the packet pointer */
    p = q->p;
  809cb7:	8b 70 04             	mov    0x4(%eax),%esi
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  809cba:	89 44 24 04          	mov    %eax,0x4(%esp)
  809cbe:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  809cc5:	e8 a8 ad ff ff       	call   804a72 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  809cca:	89 1c 24             	mov    %ebx,(%esp)
  809ccd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  809cd0:	89 f2                	mov    %esi,%edx
  809cd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809cd5:	e8 73 fe ff ff       	call   809b4d <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  809cda:	89 34 24             	mov    %esi,(%esp)
  809cdd:	e8 42 b1 ff ff       	call   804e24 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  809ce2:	8b 87 40 5a b3 00    	mov    0xb35a40(%edi),%eax
  809ce8:	85 c0                	test   %eax,%eax
  809cea:	75 c3                	jne    809caf <update_arp_entry+0xe3>
  809cec:	eb 1a                	jmp    809d08 <update_arp_entry+0x13c>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  809cee:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809cf3:	eb 13                	jmp    809d08 <update_arp_entry+0x13c>
  809cf5:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809cfa:	eb 0c                	jmp    809d08 <update_arp_entry+0x13c>
  809cfc:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  809d01:	eb 05                	jmp    809d08 <update_arp_entry+0x13c>
  809d03:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  809d08:	83 c4 2c             	add    $0x2c,%esp
  809d0b:	5b                   	pop    %ebx
  809d0c:	5e                   	pop    %esi
  809d0d:	5f                   	pop    %edi
  809d0e:	5d                   	pop    %ebp
  809d0f:	c3                   	ret    

00809d10 <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  809d10:	55                   	push   %ebp
  809d11:	89 e5                	mov    %esp,%ebp
  809d13:	57                   	push   %edi
  809d14:	56                   	push   %esi
  809d15:	53                   	push   %ebx
  809d16:	83 ec 0c             	sub    $0xc,%esp
  809d19:	bb 54 5a b3 00       	mov    $0xb35a54,%ebx
  809d1e:	bf 6c 5b b3 00       	mov    $0xb35b6c,%edi
  809d23:	89 de                	mov    %ebx,%esi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  809d25:	0f b6 03             	movzbl (%ebx),%eax
  809d28:	8d 50 01             	lea    0x1(%eax),%edx
  809d2b:	88 13                	mov    %dl,(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  809d2d:	8b 43 fc             	mov    -0x4(%ebx),%eax
  809d30:	83 f8 02             	cmp    $0x2,%eax
  809d33:	75 07                	jne    809d3c <etharp_tmr+0x2c>
  809d35:	80 fa ef             	cmp    $0xef,%dl
  809d38:	77 0d                	ja     809d47 <etharp_tmr+0x37>
  809d3a:	eb 25                	jmp    809d61 <etharp_tmr+0x51>
         (arp_table[i].ctime >= ARP_MAXAGE)) ||
  809d3c:	83 f8 01             	cmp    $0x1,%eax
  809d3f:	90                   	nop
  809d40:	75 1f                	jne    809d61 <etharp_tmr+0x51>
        ((arp_table[i].state == ETHARP_STATE_PENDING)  &&
  809d42:	80 fa 01             	cmp    $0x1,%dl
  809d45:	76 1a                	jbe    809d61 <etharp_tmr+0x51>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  809d47:	8b 46 ec             	mov    -0x14(%esi),%eax
  809d4a:	85 c0                	test   %eax,%eax
  809d4c:	74 0c                	je     809d5a <etharp_tmr+0x4a>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  809d4e:	e8 4d fb ff ff       	call   8098a0 <free_etharp_q>
        arp_table[i].q = NULL;
  809d53:	c7 46 ec 00 00 00 00 	movl   $0x0,-0x14(%esi)
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  809d5a:	c7 46 fc 00 00 00 00 	movl   $0x0,-0x4(%esi)
  809d61:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  809d64:	39 fb                	cmp    %edi,%ebx
  809d66:	75 bb                	jne    809d23 <etharp_tmr+0x13>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  809d68:	83 c4 0c             	add    $0xc,%esp
  809d6b:	5b                   	pop    %ebx
  809d6c:	5e                   	pop    %esi
  809d6d:	5f                   	pop    %edi
  809d6e:	5d                   	pop    %ebp
  809d6f:	c3                   	ret    

00809d70 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  809d70:	55                   	push   %ebp
  809d71:	89 e5                	mov    %esp,%ebp
  809d73:	53                   	push   %ebx
  809d74:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  809d77:	ba 02 00 00 00       	mov    $0x2,%edx
  809d7c:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d7f:	e8 b4 fb ff ff       	call   809938 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  809d84:	84 c0                	test   %al,%al
  809d86:	78 29                	js     809db1 <etharp_find_addr+0x41>
  809d88:	0f be d0             	movsbl %al,%edx
  809d8b:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  809d8e:	83 b9 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%ecx)
  809d95:	75 21                	jne    809db8 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  809d97:	89 ca                	mov    %ecx,%edx
  809d99:	8d 99 48 5a b3 00    	lea    0xb35a48(%ecx),%ebx
  809d9f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  809da2:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  809da4:	81 c2 44 5a b3 00    	add    $0xb35a44,%edx
  809daa:	8b 4d 14             	mov    0x14(%ebp),%ecx
  809dad:	89 11                	mov    %edx,(%ecx)
      return i;
  809daf:	eb 0c                	jmp    809dbd <etharp_find_addr+0x4d>
  }
  return -1;
  809db1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809db6:	eb 05                	jmp    809dbd <etharp_find_addr+0x4d>
  809db8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  809dbd:	83 c4 04             	add    $0x4,%esp
  809dc0:	5b                   	pop    %ebx
  809dc1:	5d                   	pop    %ebp
  809dc2:	c3                   	ret    

00809dc3 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  809dc3:	55                   	push   %ebp
  809dc4:	89 e5                	mov    %esp,%ebp
  809dc6:	83 ec 18             	sub    $0x18,%esp
  809dc9:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809dcc:	85 c0                	test   %eax,%eax
  809dce:	75 1c                	jne    809dec <etharp_ip_input+0x29>
  809dd0:	c7 44 24 08 62 26 81 	movl   $0x812662,0x8(%esp)
  809dd7:	00 
  809dd8:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  809ddf:	00 
  809de0:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809de7:	e8 ae 52 00 00       	call   80f09a <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  809dec:	8b 55 0c             	mov    0xc(%ebp),%edx
  809def:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  809df2:	8b 48 04             	mov    0x4(%eax),%ecx
  809df5:	33 4a 1c             	xor    0x1c(%edx),%ecx
  809df8:	85 48 08             	test   %ecx,0x8(%eax)
  809dfb:	75 12                	jne    809e0f <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  809dfd:	8d 4a 06             	lea    0x6(%edx),%ecx
  809e00:	83 c2 1c             	add    $0x1c,%edx
  809e03:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809e0a:	e8 bd fd ff ff       	call   809bcc <update_arp_entry>
}
  809e0f:	c9                   	leave  
  809e10:	c3                   	ret    

00809e11 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  809e11:	55                   	push   %ebp
  809e12:	89 e5                	mov    %esp,%ebp
  809e14:	57                   	push   %edi
  809e15:	56                   	push   %esi
  809e16:	53                   	push   %ebx
  809e17:	83 ec 2c             	sub    $0x2c,%esp
  809e1a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  809e1d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  809e21:	75 1c                	jne    809e3f <etharp_arp_input+0x2e>
  809e23:	c7 44 24 08 62 26 81 	movl   $0x812662,0x8(%esp)
  809e2a:	00 
  809e2b:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  809e32:	00 
  809e33:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809e3a:	e8 5b 52 00 00       	call   80f09a <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  809e3f:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  809e44:	77 0d                	ja     809e53 <etharp_arp_input+0x42>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809e46:	89 1c 24             	mov    %ebx,(%esp)
  809e49:	e8 d6 af ff ff       	call   804e24 <pbuf_free>
    return;
  809e4e:	e9 a6 01 00 00       	jmp    809ff9 <etharp_arp_input+0x1e8>
  }

  hdr = p->payload;
  809e53:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809e56:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  809e5a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809e61:	e8 40 df ff ff       	call   807da6 <htons>
  809e66:	66 39 c7             	cmp    %ax,%di
  809e69:	75 3f                	jne    809eaa <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809e6b:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  809e6f:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  809e76:	e8 2b df ff ff       	call   807da6 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  809e7b:	66 39 c7             	cmp    %ax,%di
  809e7e:	75 2a                	jne    809eaa <etharp_arp_input+0x99>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809e80:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  809e84:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  809e8b:	e8 16 df ff ff       	call   807da6 <htons>

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  809e90:	66 39 c7             	cmp    %ax,%di
  809e93:	75 15                	jne    809eaa <etharp_arp_input+0x99>
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  809e95:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  809e99:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  809ea0:	e8 01 df ff ff       	call   807da6 <htons>
  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  809ea5:	66 39 c7             	cmp    %ax,%di
  809ea8:	74 0d                	je     809eb7 <etharp_arp_input+0xa6>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  809eaa:	89 1c 24             	mov    %ebx,(%esp)
  809ead:	e8 72 af ff ff       	call   804e24 <pbuf_free>
    return;
  809eb2:	e9 42 01 00 00       	jmp    809ff9 <etharp_arp_input+0x1e8>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  809eb7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809ebe:	00 
  809ebf:	8d 46 1c             	lea    0x1c(%esi),%eax
  809ec2:	89 44 24 04          	mov    %eax,0x4(%esp)
  809ec6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809ec9:	89 04 24             	mov    %eax,(%esp)
  809ecc:	e8 eb 5a 00 00       	call   80f9bc <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  809ed1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  809ed8:	00 
  809ed9:	8d 46 26             	lea    0x26(%esi),%eax
  809edc:	89 44 24 04          	mov    %eax,0x4(%esp)
  809ee0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809ee3:	89 04 24             	mov    %eax,(%esp)
  809ee6:	e8 d1 5a 00 00       	call   80f9bc <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  809eeb:	8b 45 08             	mov    0x8(%ebp),%eax
  809eee:	8b 40 04             	mov    0x4(%eax),%eax
  809ef1:	85 c0                	test   %eax,%eax
  809ef3:	74 21                	je     809f16 <etharp_arp_input+0x105>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  809ef5:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  809ef8:	0f 94 c0             	sete   %al
  809efb:	89 c7                	mov    %eax,%edi
  809efd:	75 1c                	jne    809f1b <etharp_arp_input+0x10a>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  809eff:	8d 4e 16             	lea    0x16(%esi),%ecx
  809f02:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  809f09:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809f0c:	8b 45 08             	mov    0x8(%ebp),%eax
  809f0f:	e8 b8 fc ff ff       	call   809bcc <update_arp_entry>
  809f14:	eb 1a                	jmp    809f30 <etharp_arp_input+0x11f>
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
    for_us = 0;
  809f16:	bf 00 00 00 00       	mov    $0x0,%edi
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  809f1b:	8d 4e 16             	lea    0x16(%esi),%ecx
  809f1e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809f25:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  809f28:	8b 45 08             	mov    0x8(%ebp),%eax
  809f2b:	e8 9c fc ff ff       	call   809bcc <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  809f30:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  809f34:	89 04 24             	mov    %eax,(%esp)
  809f37:	e8 6a de ff ff       	call   807da6 <htons>
  809f3c:	66 83 f8 01          	cmp    $0x1,%ax
  809f40:	74 0f                	je     809f51 <etharp_arp_input+0x140>
  809f42:	66 83 f8 02          	cmp    $0x2,%ax
  809f46:	0f 84 93 00 00 00    	je     809fdf <etharp_arp_input+0x1ce>
  809f4c:	e9 a0 00 00 00       	jmp    809ff1 <etharp_arp_input+0x1e0>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  809f51:	89 f8                	mov    %edi,%eax
  809f53:	84 c0                	test   %al,%al
  809f55:	0f 84 96 00 00 00    	je     809ff1 <etharp_arp_input+0x1e0>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  809f5b:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809f62:	e8 3f de ff ff       	call   807da6 <htons>
  809f67:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  809f6b:	8b 46 1c             	mov    0x1c(%esi),%eax
  809f6e:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  809f71:	8b 45 08             	mov    0x8(%ebp),%eax
  809f74:	8b 40 04             	mov    0x4(%eax),%eax
  809f77:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  809f7a:	ba 06 00 00 00       	mov    $0x6,%edx
  809f7f:	8b 45 08             	mov    0x8(%ebp),%eax
  809f82:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  809f86:	74 1c                	je     809fa4 <etharp_arp_input+0x193>
  809f88:	c7 44 24 08 68 33 81 	movl   $0x813368,0x8(%esp)
  809f8f:	00 
  809f90:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  809f97:	00 
  809f98:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  809f9f:	e8 f6 50 00 00       	call   80f09a <_panic>
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  809fa4:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  809fa7:	0f b6 c2             	movzbl %dl,%eax
  809faa:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  809faf:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  809fb3:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  809fb6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809fb9:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809fbd:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  809fc1:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  809fc4:	0f b6 0c 01          	movzbl (%ecx,%eax,1),%ecx
  809fc8:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  809fcc:	84 d2                	test   %dl,%dl
  809fce:	75 d4                	jne    809fa4 <etharp_arp_input+0x193>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  809fd0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809fd4:	8b 45 08             	mov    0x8(%ebp),%eax
  809fd7:	89 04 24             	mov    %eax,(%esp)
  809fda:	ff 50 18             	call   *0x18(%eax)
  809fdd:	eb 12                	jmp    809ff1 <etharp_arp_input+0x1e0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  809fdf:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809fe2:	89 44 24 04          	mov    %eax,0x4(%esp)
  809fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  809fe9:	89 04 24             	mov    %eax,(%esp)
  809fec:	e8 1d 9e ff ff       	call   803e0e <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  809ff1:	89 1c 24             	mov    %ebx,(%esp)
  809ff4:	e8 2b ae ff ff       	call   804e24 <pbuf_free>
}
  809ff9:	83 c4 2c             	add    $0x2c,%esp
  809ffc:	5b                   	pop    %ebx
  809ffd:	5e                   	pop    %esi
  809ffe:	5f                   	pop    %edi
  809fff:	5d                   	pop    %ebp
  80a000:	c3                   	ret    

0080a001 <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80a001:	55                   	push   %ebp
  80a002:	89 e5                	mov    %esp,%ebp
  80a004:	57                   	push   %edi
  80a005:	56                   	push   %esi
  80a006:	53                   	push   %ebx
  80a007:	83 ec 1c             	sub    $0x1c,%esp
  80a00a:	8b 75 08             	mov    0x8(%ebp),%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80a00d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a014:	00 
  80a015:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80a01c:	00 
  80a01d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a024:	e8 dc ae ff ff       	call   804f05 <pbuf_alloc>
  80a029:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80a02b:	85 c0                	test   %eax,%eax
  80a02d:	0f 84 f4 00 00 00    	je     80a127 <etharp_request+0x126>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80a033:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80a038:	77 1c                	ja     80a056 <etharp_request+0x55>
  80a03a:	c7 44 24 08 d4 33 81 	movl   $0x8133d4,0x8(%esp)
  80a041:	00 
  80a042:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80a049:	00 
  80a04a:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  80a051:	e8 44 50 00 00       	call   80f09a <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80a056:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80a059:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a060:	e8 41 dd ff ff       	call   807da6 <htons>
  80a065:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80a069:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80a06d:	74 1c                	je     80a08b <etharp_request+0x8a>
  80a06f:	c7 44 24 08 68 33 81 	movl   $0x813368,0x8(%esp)
  80a076:	00 
  80a077:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80a07e:	00 
  80a07f:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  80a086:	e8 0f 50 00 00       	call   80f09a <_panic>
  80a08b:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80a090:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80a093:	0f b6 c2             	movzbl %dl,%eax
  80a096:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80a09b:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80a09f:	0f b6 88 51 34 81 00 	movzbl 0x813451(%eax),%ecx
  80a0a6:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80a0aa:	0f b6 88 57 34 81 00 	movzbl 0x813457(%eax),%ecx
  80a0b1:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80a0b4:	0f b6 4c 06 25       	movzbl 0x25(%esi,%eax,1),%ecx
  80a0b9:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80a0bd:	84 d2                	test   %dl,%dl
  80a0bf:	75 cf                	jne    80a090 <etharp_request+0x8f>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80a0c1:	8b 46 04             	mov    0x4(%esi),%eax
  80a0c4:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80a0c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a0ca:	8b 00                	mov    (%eax),%eax
  80a0cc:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80a0cf:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80a0d6:	e8 cb dc ff ff       	call   807da6 <htons>
  80a0db:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80a0df:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80a0e6:	e8 bb dc ff ff       	call   807da6 <htons>
  80a0eb:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80a0ef:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80a0f6:	e8 ab dc ff ff       	call   807da6 <htons>
  80a0fb:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80a0ff:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80a106:	e8 9b dc ff ff       	call   807da6 <htons>
  80a10b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80a10f:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a113:	89 34 24             	mov    %esi,(%esp)
  80a116:	ff 56 18             	call   *0x18(%esi)
  80a119:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80a11b:	89 3c 24             	mov    %edi,(%esp)
  80a11e:	e8 01 ad ff ff       	call   804e24 <pbuf_free>
  p = NULL;
  /* could not allocate pbuf for ARP request */

  return result;
  80a123:	89 d8                	mov    %ebx,%eax
  80a125:	eb 05                	jmp    80a12c <etharp_request+0x12b>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80a127:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80a12c:	83 c4 1c             	add    $0x1c,%esp
  80a12f:	5b                   	pop    %ebx
  80a130:	5e                   	pop    %esi
  80a131:	5f                   	pop    %edi
  80a132:	5d                   	pop    %ebp
  80a133:	c3                   	ret    

0080a134 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80a134:	55                   	push   %ebp
  80a135:	89 e5                	mov    %esp,%ebp
  80a137:	57                   	push   %edi
  80a138:	56                   	push   %esi
  80a139:	53                   	push   %ebx
  80a13a:	83 ec 1c             	sub    $0x1c,%esp
  80a13d:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a140:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a143:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a147:	89 1c 24             	mov    %ebx,(%esp)
  80a14a:	e8 72 c9 ff ff       	call   806ac1 <ip_addr_isbroadcast>
  80a14f:	84 c0                	test   %al,%al
  80a151:	0f 85 ad 01 00 00    	jne    80a304 <etharp_query+0x1d0>
      ip_addr_ismulticast(ipaddr) ||
  80a157:	8b 33                	mov    (%ebx),%esi
  80a159:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a160:	e8 95 de ff ff       	call   807ffa <ntohl>
  80a165:	21 c6                	and    %eax,%esi
  80a167:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a16e:	e8 87 de ff ff       	call   807ffa <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80a173:	39 c6                	cmp    %eax,%esi
  80a175:	0f 84 93 01 00 00    	je     80a30e <etharp_query+0x1da>
      ip_addr_ismulticast(ipaddr) ||
  80a17b:	85 db                	test   %ebx,%ebx
  80a17d:	0f 84 95 01 00 00    	je     80a318 <etharp_query+0x1e4>
      ip_addr_isany(ipaddr)) {
  80a183:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a186:	0f 84 93 01 00 00    	je     80a31f <etharp_query+0x1eb>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80a18c:	ba 01 00 00 00       	mov    $0x1,%edx
  80a191:	89 d8                	mov    %ebx,%eax
  80a193:	e8 a0 f7 ff ff       	call   809938 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80a198:	84 c0                	test   %al,%al
  80a19a:	0f 88 fb 01 00 00    	js     80a39b <etharp_query+0x267>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80a1a0:	0f be f0             	movsbl %al,%esi
  80a1a3:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a1a6:	8b 80 50 5a b3 00    	mov    0xb35a50(%eax),%eax
  80a1ac:	85 c0                	test   %eax,%eax
  80a1ae:	75 0f                	jne    80a1bf <etharp_query+0x8b>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80a1b0:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a1b3:	c7 80 50 5a b3 00 01 	movl   $0x1,0xb35a50(%eax)
  80a1ba:	00 00 00 
  80a1bd:	eb 38                	jmp    80a1f7 <etharp_query+0xc3>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80a1bf:	8d 50 ff             	lea    -0x1(%eax),%edx
  80a1c2:	83 fa 01             	cmp    $0x1,%edx
  80a1c5:	76 1c                	jbe    80a1e3 <etharp_query+0xaf>
  80a1c7:	c7 44 24 08 08 34 81 	movl   $0x813408,0x8(%esp)
  80a1ce:	00 
  80a1cf:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80a1d6:	00 
  80a1d7:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  80a1de:	e8 b7 4e 00 00       	call   80f09a <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80a1e3:	83 f8 01             	cmp    $0x1,%eax
  80a1e6:	74 0f                	je     80a1f7 <etharp_query+0xc3>
  80a1e8:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a1ec:	0f 85 94 01 00 00    	jne    80a386 <etharp_query+0x252>
  80a1f2:	e9 81 01 00 00       	jmp    80a378 <etharp_query+0x244>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a1f7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a1fb:	89 3c 24             	mov    %edi,(%esp)
  80a1fe:	e8 fe fd ff ff       	call   80a001 <etharp_request>
  80a203:	89 c3                	mov    %eax,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80a205:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80a209:	0f 84 17 01 00 00    	je     80a326 <etharp_query+0x1f2>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a20f:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a212:	8b 90 50 5a b3 00    	mov    0xb35a50(%eax),%edx
  80a218:	83 fa 02             	cmp    $0x2,%edx
  80a21b:	75 1e                	jne    80a23b <etharp_query+0x107>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80a21d:	8d 4f 25             	lea    0x25(%edi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80a220:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80a223:	81 c6 48 5a b3 00    	add    $0xb35a48,%esi
  80a229:	89 34 24             	mov    %esi,(%esp)
  80a22c:	8b 55 10             	mov    0x10(%ebp),%edx
  80a22f:	89 f8                	mov    %edi,%eax
  80a231:	e8 17 f9 ff ff       	call   809b4d <etharp_send_ip>
  80a236:	e9 60 01 00 00       	jmp    80a39b <etharp_query+0x267>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a23b:	89 d8                	mov    %ebx,%eax
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80a23d:	83 fa 01             	cmp    $0x1,%edx
  80a240:	0f 85 55 01 00 00    	jne    80a39b <etharp_query+0x267>
  80a246:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80a249:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
  80a24d:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80a251:	75 21                	jne    80a274 <etharp_query+0x140>
  80a253:	83 38 00             	cmpl   $0x0,(%eax)
  80a256:	74 1c                	je     80a274 <etharp_query+0x140>
  80a258:	c7 44 24 08 4e 33 81 	movl   $0x81334e,0x8(%esp)
  80a25f:	00 
  80a260:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80a267:	00 
  80a268:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  80a26f:	e8 26 4e 00 00       	call   80f09a <_panic>
        if(p->type != PBUF_ROM) {
  80a274:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80a278:	0f 85 b7 00 00 00    	jne    80a335 <etharp_query+0x201>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80a27e:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80a280:	85 c0                	test   %eax,%eax
  80a282:	75 c5                	jne    80a249 <etharp_query+0x115>
  80a284:	e9 9f 00 00 00       	jmp    80a328 <etharp_query+0x1f4>
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  80a289:	8b 45 10             	mov    0x10(%ebp),%eax
  80a28c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a290:	89 3c 24             	mov    %edi,(%esp)
  80a293:	e8 9c b1 ff ff       	call   805434 <pbuf_copy>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a298:	89 7d 10             	mov    %edi,0x10(%ebp)
        if(p != NULL) {
          if (pbuf_copy(p, q) != ERR_OK) {
  80a29b:	84 c0                	test   %al,%al
  80a29d:	0f 84 bc 00 00 00    	je     80a35f <etharp_query+0x22b>
            pbuf_free(p);
  80a2a3:	89 3c 24             	mov    %edi,(%esp)
  80a2a6:	e8 79 ab ff ff       	call   804e24 <pbuf_free>
  80a2ab:	e9 ab 00 00 00       	jmp    80a35b <etharp_query+0x227>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  80a2b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80a2b6:	8b 7d 10             	mov    0x10(%ebp),%edi
  80a2b9:	89 78 04             	mov    %edi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80a2bc:	6b d6 1c             	imul   $0x1c,%esi,%edx
  80a2bf:	8b 8a 40 5a b3 00    	mov    0xb35a40(%edx),%ecx
  80a2c5:	85 c9                	test   %ecx,%ecx
  80a2c7:	74 16                	je     80a2df <etharp_query+0x1ab>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80a2c9:	8b 11                	mov    (%ecx),%edx
  80a2cb:	85 d2                	test   %edx,%edx
  80a2cd:	74 04                	je     80a2d3 <etharp_query+0x19f>
              r = r->next;
  80a2cf:	89 d1                	mov    %edx,%ecx
  80a2d1:	eb f6                	jmp    80a2c9 <etharp_query+0x195>
            }
            r->next = new_entry;
  80a2d3:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a2d5:	b8 00 00 00 00       	mov    $0x0,%eax
  80a2da:	e9 bc 00 00 00       	jmp    80a39b <etharp_query+0x267>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80a2df:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80a2e2:	89 86 40 5a b3 00    	mov    %eax,0xb35a40(%esi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80a2e8:	b8 00 00 00 00       	mov    $0x0,%eax
  80a2ed:	e9 a9 00 00 00       	jmp    80a39b <etharp_query+0x267>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80a2f2:	8b 45 10             	mov    0x10(%ebp),%eax
  80a2f5:	89 04 24             	mov    %eax,(%esp)
  80a2f8:	e8 27 ab ff ff       	call   804e24 <pbuf_free>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a2fd:	89 d8                	mov    %ebx,%eax
  80a2ff:	e9 97 00 00 00       	jmp    80a39b <etharp_query+0x267>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80a304:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a309:	e9 8d 00 00 00       	jmp    80a39b <etharp_query+0x267>
  80a30e:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a313:	e9 83 00 00 00       	jmp    80a39b <etharp_query+0x267>
  80a318:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a31d:	eb 7c                	jmp    80a39b <etharp_query+0x267>
  80a31f:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80a324:	eb 75                	jmp    80a39b <etharp_query+0x267>
  80a326:	eb 73                	jmp    80a39b <etharp_query+0x267>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80a328:	8b 45 10             	mov    0x10(%ebp),%eax
  80a32b:	89 04 24             	mov    %eax,(%esp)
  80a32e:	e8 9f af ff ff       	call   8052d2 <pbuf_ref>
  80a333:	eb 2a                	jmp    80a35f <etharp_query+0x22b>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80a335:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80a339:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a340:	00 
  80a341:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a345:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80a34c:	e8 b4 ab ff ff       	call   804f05 <pbuf_alloc>
  80a351:	89 c7                	mov    %eax,%edi
        if(p != NULL) {
  80a353:	85 c0                	test   %eax,%eax
  80a355:	0f 85 2e ff ff ff    	jne    80a289 <etharp_query+0x155>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a35b:	89 d8                	mov    %ebx,%eax
  80a35d:	eb 3c                	jmp    80a39b <etharp_query+0x267>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80a35f:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80a366:	e8 a7 a6 ff ff       	call   804a12 <memp_malloc>
        if (new_entry != NULL) {
  80a36b:	85 c0                	test   %eax,%eax
  80a36d:	0f 85 3d ff ff ff    	jne    80a2b0 <etharp_query+0x17c>
  80a373:	e9 7a ff ff ff       	jmp    80a2f2 <etharp_query+0x1be>
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80a378:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a37c:	89 3c 24             	mov    %edi,(%esp)
  80a37f:	e8 7d fc ff ff       	call   80a001 <etharp_request>
  80a384:	eb 15                	jmp    80a39b <etharp_query+0x267>
  }
  
  /* packet given? */
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80a386:	6b c6 1c             	imul   $0x1c,%esi,%eax
  80a389:	83 b8 50 5a b3 00 02 	cmpl   $0x2,0xb35a50(%eax)
  80a390:	0f 84 87 fe ff ff    	je     80a21d <etharp_query+0xe9>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80a396:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80a39b:	83 c4 1c             	add    $0x1c,%esp
  80a39e:	5b                   	pop    %ebx
  80a39f:	5e                   	pop    %esi
  80a3a0:	5f                   	pop    %edi
  80a3a1:	5d                   	pop    %ebp
  80a3a2:	c3                   	ret    

0080a3a3 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80a3a3:	55                   	push   %ebp
  80a3a4:	89 e5                	mov    %esp,%ebp
  80a3a6:	57                   	push   %edi
  80a3a7:	56                   	push   %esi
  80a3a8:	53                   	push   %ebx
  80a3a9:	83 ec 2c             	sub    $0x2c,%esp
  80a3ac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a3af:	8b 75 10             	mov    0x10(%ebp),%esi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80a3b2:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80a3b9:	00 
  80a3ba:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a3bd:	89 04 24             	mov    %eax,(%esp)
  80a3c0:	e8 7b a9 ff ff       	call   804d40 <pbuf_header>
  80a3c5:	84 c0                	test   %al,%al
  80a3c7:	0f 85 b4 00 00 00    	jne    80a481 <etharp_output+0xde>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80a3cd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a3d1:	89 34 24             	mov    %esi,(%esp)
  80a3d4:	e8 e8 c6 ff ff       	call   806ac1 <ip_addr_isbroadcast>
  80a3d9:	84 c0                	test   %al,%al
  80a3db:	0f 85 89 00 00 00    	jne    80a46a <etharp_output+0xc7>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80a3e1:	8b 3e                	mov    (%esi),%edi
  80a3e3:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80a3ea:	e8 0b dc ff ff       	call   807ffa <ntohl>
  80a3ef:	21 c7                	and    %eax,%edi
  80a3f1:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80a3f8:	e8 fd db ff ff       	call   807ffa <ntohl>
  80a3fd:	39 c7                	cmp    %eax,%edi
  80a3ff:	75 41                	jne    80a442 <etharp_output+0x9f>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80a401:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80a405:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80a409:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80a40d:	8b 06                	mov    (%esi),%eax
  80a40f:	89 04 24             	mov    %eax,(%esp)
  80a412:	e8 e3 db ff ff       	call   807ffa <ntohl>
  80a417:	c1 e8 10             	shr    $0x10,%eax
  80a41a:	83 e0 7f             	and    $0x7f,%eax
  80a41d:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80a420:	8b 06                	mov    (%esi),%eax
  80a422:	89 04 24             	mov    %eax,(%esp)
  80a425:	e8 d0 db ff ff       	call   807ffa <ntohl>
  80a42a:	c1 e8 08             	shr    $0x8,%eax
  80a42d:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80a430:	8b 06                	mov    (%esi),%eax
  80a432:	89 04 24             	mov    %eax,(%esp)
  80a435:	e8 c0 db ff ff       	call   807ffa <ntohl>
  80a43a:	88 45 e7             	mov    %al,-0x19(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80a43d:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  80a440:	eb 2d                	jmp    80a46f <etharp_output+0xcc>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80a442:	8b 43 04             	mov    0x4(%ebx),%eax
  80a445:	33 06                	xor    (%esi),%eax
  80a447:	85 43 08             	test   %eax,0x8(%ebx)
  80a44a:	74 09                	je     80a455 <etharp_output+0xb2>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80a44c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80a450:	74 36                	je     80a488 <etharp_output+0xe5>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80a452:	8d 73 0c             	lea    0xc(%ebx),%esi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80a455:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a458:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a45c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a460:	89 1c 24             	mov    %ebx,(%esp)
  80a463:	e8 cc fc ff ff       	call   80a134 <etharp_query>
  80a468:	eb 23                	jmp    80a48d <etharp_output+0xea>
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80a46a:	b8 57 34 81 00       	mov    $0x813457,%eax
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80a46f:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80a472:	89 04 24             	mov    %eax,(%esp)
  80a475:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a478:	89 d8                	mov    %ebx,%eax
  80a47a:	e8 ce f6 ff ff       	call   809b4d <etharp_send_ip>
  80a47f:	eb 0c                	jmp    80a48d <etharp_output+0xea>
  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80a481:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80a486:	eb 05                	jmp    80a48d <etharp_output+0xea>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80a488:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
}
  80a48d:	83 c4 2c             	add    $0x2c,%esp
  80a490:	5b                   	pop    %ebx
  80a491:	5e                   	pop    %esi
  80a492:	5f                   	pop    %edi
  80a493:	5d                   	pop    %ebp
  80a494:	c3                   	ret    

0080a495 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80a495:	55                   	push   %ebp
  80a496:	89 e5                	mov    %esp,%ebp
  80a498:	56                   	push   %esi
  80a499:	53                   	push   %ebx
  80a49a:	83 ec 10             	sub    $0x10,%esp
  80a49d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a4a0:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80a4a3:	8b 43 04             	mov    0x4(%ebx),%eax
  80a4a6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80a4aa:	89 04 24             	mov    %eax,(%esp)
  80a4ad:	e8 f4 d8 ff ff       	call   807da6 <htons>
  80a4b2:	66 3d 00 08          	cmp    $0x800,%ax
  80a4b6:	74 0a                	je     80a4c2 <ethernet_input+0x2d>
  80a4b8:	66 3d 06 08          	cmp    $0x806,%ax
  80a4bc:	74 4e                	je     80a50c <ethernet_input+0x77>
  80a4be:	66 90                	xchg   %ax,%ax
  80a4c0:	eb 5f                	jmp    80a521 <ethernet_input+0x8c>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80a4c2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a4c6:	89 34 24             	mov    %esi,(%esp)
  80a4c9:	e8 f5 f8 ff ff       	call   809dc3 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80a4ce:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80a4d5:	ff 
  80a4d6:	89 1c 24             	mov    %ebx,(%esp)
  80a4d9:	e8 62 a8 ff ff       	call   804d40 <pbuf_header>
  80a4de:	84 c0                	test   %al,%al
  80a4e0:	74 1c                	je     80a4fe <ethernet_input+0x69>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80a4e2:	c7 44 24 08 30 34 81 	movl   $0x813430,0x8(%esp)
  80a4e9:	00 
  80a4ea:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80a4f1:	00 
  80a4f2:	c7 04 24 f2 32 81 00 	movl   $0x8132f2,(%esp)
  80a4f9:	e8 9c 4b 00 00       	call   80f09a <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80a4fe:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a502:	89 1c 24             	mov    %ebx,(%esp)
  80a505:	e8 66 c6 ff ff       	call   806b70 <ip_input>
      }
      break;
  80a50a:	eb 1d                	jmp    80a529 <ethernet_input+0x94>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80a50c:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80a510:	8d 46 25             	lea    0x25(%esi),%eax
  80a513:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a517:	89 34 24             	mov    %esi,(%esp)
  80a51a:	e8 f2 f8 ff ff       	call   809e11 <etharp_arp_input>
      break;
  80a51f:	eb 08                	jmp    80a529 <ethernet_input+0x94>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80a521:	89 1c 24             	mov    %ebx,(%esp)
  80a524:	e8 fb a8 ff ff       	call   804e24 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80a529:	b8 00 00 00 00       	mov    $0x0,%eax
  80a52e:	83 c4 10             	add    $0x10,%esp
  80a531:	5b                   	pop    %ebx
  80a532:	5e                   	pop    %esi
  80a533:	5d                   	pop    %ebp
  80a534:	c3                   	ret    
  80a535:	66 90                	xchg   %ax,%ax
  80a537:	66 90                	xchg   %ax,%ax
  80a539:	66 90                	xchg   %ax,%ax
  80a53b:	66 90                	xchg   %ax,%ax
  80a53d:	66 90                	xchg   %ax,%ax
  80a53f:	90                   	nop

0080a540 <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80a540:	55                   	push   %ebp
  80a541:	89 e5                	mov    %esp,%ebp
  80a543:	53                   	push   %ebx
  80a544:	83 ec 14             	sub    $0x14,%esp
  80a547:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80a54a:	8b 43 04             	mov    0x4(%ebx),%eax
  80a54d:	89 04 24             	mov    %eax,(%esp)
  80a550:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80a552:	89 1c 24             	mov    %ebx,(%esp)
  80a555:	e8 e6 6c 00 00       	call   811240 <free>
}
  80a55a:	83 c4 14             	add    $0x14,%esp
  80a55d:	5b                   	pop    %ebx
  80a55e:	5d                   	pop    %ebp
  80a55f:	c3                   	ret    

0080a560 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80a560:	55                   	push   %ebp
  80a561:	89 e5                	mov    %esp,%ebp
  80a563:	83 ec 18             	sub    $0x18,%esp
  80a566:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a569:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80a56e:	89 c8                	mov    %ecx,%eax
  80a570:	f7 e2                	mul    %edx
  80a572:	c1 ea 08             	shr    $0x8,%edx
  80a575:	89 d0                	mov    %edx,%eax
  80a577:	c1 e0 08             	shl    $0x8,%eax
  80a57a:	01 c2                	add    %eax,%edx
  80a57c:	89 c8                	mov    %ecx,%eax
  80a57e:	29 d0                	sub    %edx,%eax
  80a580:	8b 14 85 60 5b b3 00 	mov    0xb35b60(,%eax,4),%edx
  80a587:	eb 26                	jmp    80a5af <timeout_cleanup+0x4f>
	if (t->tid == tid) {
  80a589:	39 0a                	cmp    %ecx,(%edx)
  80a58b:	75 1f                	jne    80a5ac <timeout_cleanup+0x4c>
	    LIST_REMOVE(t, link);
  80a58d:	8b 42 08             	mov    0x8(%edx),%eax
  80a590:	85 c0                	test   %eax,%eax
  80a592:	74 06                	je     80a59a <timeout_cleanup+0x3a>
  80a594:	8b 4a 0c             	mov    0xc(%edx),%ecx
  80a597:	89 48 0c             	mov    %ecx,0xc(%eax)
  80a59a:	8b 42 0c             	mov    0xc(%edx),%eax
  80a59d:	8b 4a 08             	mov    0x8(%edx),%ecx
  80a5a0:	89 08                	mov    %ecx,(%eax)
	    free(t);
  80a5a2:	89 14 24             	mov    %edx,(%esp)
  80a5a5:	e8 96 6c 00 00       	call   811240 <free>
	    goto done;
  80a5aa:	eb 07                	jmp    80a5b3 <timeout_cleanup+0x53>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80a5ac:	8b 52 08             	mov    0x8(%edx),%edx
  80a5af:	85 d2                	test   %edx,%edx
  80a5b1:	75 d6                	jne    80a589 <timeout_cleanup+0x29>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80a5b3:	c9                   	leave  
  80a5b4:	c3                   	ret    

0080a5b5 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80a5b5:	55                   	push   %ebp
  80a5b6:	89 e5                	mov    %esp,%ebp
  80a5b8:	56                   	push   %esi
  80a5b9:	53                   	push   %ebx
  80a5ba:	8b 15 80 ad b3 00    	mov    0xb3ad80,%edx
  80a5c0:	b8 a0 ad b3 00       	mov    $0xb3ada0,%eax
  80a5c5:	be a0 c1 b3 00       	mov    $0xb3c1a0,%esi
  80a5ca:	89 c1                	mov    %eax,%ecx
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80a5cc:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a5d2:	89 50 0c             	mov    %edx,0xc(%eax)
  80a5d5:	85 d2                	test   %edx,%edx
  80a5d7:	74 06                	je     80a5df <sys_init+0x2a>
  80a5d9:	8d 58 0c             	lea    0xc(%eax),%ebx
  80a5dc:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a5df:	c7 41 10 80 ad b3 00 	movl   $0xb3ad80,0x10(%ecx)
  80a5e6:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80a5e9:	39 f0                	cmp    %esi,%eax
  80a5eb:	74 04                	je     80a5f1 <sys_init+0x3c>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80a5ed:	89 ca                	mov    %ecx,%edx
  80a5ef:	eb d9                	jmp    80a5ca <sys_init+0x15>
  80a5f1:	c7 05 80 ad b3 00 8c 	movl   $0xb3c18c,0xb3ad80
  80a5f8:	c1 b3 00 
  80a5fb:	8b 15 64 5f b3 00    	mov    0xb35f64,%edx
  80a601:	b8 80 5f b3 00       	mov    $0xb35f80,%eax
  80a606:	be 80 ad b3 00       	mov    $0xb3ad80,%esi
  80a60b:	89 c1                	mov    %eax,%ecx
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80a60d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a613:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80a619:	85 d2                	test   %edx,%edx
  80a61b:	74 0c                	je     80a629 <sys_init+0x74>
  80a61d:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80a623:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80a629:	c7 81 98 00 00 00 64 	movl   $0xb35f64,0x98(%ecx)
  80a630:	5f b3 00 
  80a633:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80a638:	39 f0                	cmp    %esi,%eax
  80a63a:	74 04                	je     80a640 <sys_init+0x8b>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80a63c:	89 ca                	mov    %ecx,%edx
  80a63e:	eb cb                	jmp    80a60b <sys_init+0x56>
  80a640:	c7 05 64 5f b3 00 e4 	movl   $0xb3ace4,0xb35f64
  80a647:	ac b3 00 
    }
}
  80a64a:	5b                   	pop    %ebx
  80a64b:	5e                   	pop    %esi
  80a64c:	5d                   	pop    %ebp
  80a64d:	c3                   	ret    

0080a64e <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80a64e:	55                   	push   %ebp
  80a64f:	89 e5                	mov    %esp,%ebp
  80a651:	53                   	push   %ebx
  80a652:	83 ec 14             	sub    $0x14,%esp
  80a655:	8b 4d 08             	mov    0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80a658:	a1 80 ad b3 00       	mov    0xb3ad80,%eax
    if (!se) {
  80a65d:	85 c0                	test   %eax,%eax
  80a65f:	75 13                	jne    80a674 <sys_sem_new+0x26>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80a661:	c7 04 24 60 34 81 00 	movl   $0x813460,(%esp)
  80a668:	e8 26 4b 00 00       	call   80f193 <cprintf>
	return SYS_SEM_NULL;
  80a66d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a672:	eb 5d                	jmp    80a6d1 <sys_sem_new+0x83>
    }
    LIST_REMOVE(se, link);
  80a674:	8b 50 0c             	mov    0xc(%eax),%edx
  80a677:	85 d2                	test   %edx,%edx
  80a679:	74 06                	je     80a681 <sys_sem_new+0x33>
  80a67b:	8b 58 10             	mov    0x10(%eax),%ebx
  80a67e:	89 5a 10             	mov    %ebx,0x10(%edx)
  80a681:	8b 50 10             	mov    0x10(%eax),%edx
  80a684:	8b 58 0c             	mov    0xc(%eax),%ebx
  80a687:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80a689:	83 38 00             	cmpl   $0x0,(%eax)
  80a68c:	75 24                	jne    80a6b2 <sys_sem_new+0x64>
  80a68e:	c7 44 24 0c d5 35 81 	movl   $0x8135d5,0xc(%esp)
  80a695:	00 
  80a696:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a69d:	00 
  80a69e:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80a6a5:	00 
  80a6a6:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a6ad:	e8 e8 49 00 00       	call   80f09a <_panic>
    se->freed = 0;
  80a6b2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80a6b8:	0f b6 c9             	movzbl %cl,%ecx
  80a6bb:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80a6bf:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80a6c3:	2d a0 ad b3 00       	sub    $0xb3ada0,%eax
  80a6c8:	c1 f8 02             	sar    $0x2,%eax
  80a6cb:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80a6d1:	83 c4 14             	add    $0x14,%esp
  80a6d4:	5b                   	pop    %ebx
  80a6d5:	5d                   	pop    %ebp
  80a6d6:	c3                   	ret    

0080a6d7 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80a6d7:	55                   	push   %ebp
  80a6d8:	89 e5                	mov    %esp,%ebp
  80a6da:	83 ec 18             	sub    $0x18,%esp
  80a6dd:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a6e0:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a6e3:	83 3c 95 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%edx,4)
  80a6ea:	00 
  80a6eb:	74 24                	je     80a711 <sys_sem_free+0x3a>
  80a6ed:	c7 44 24 0c 11 36 81 	movl   $0x813611,0xc(%esp)
  80a6f4:	00 
  80a6f5:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a6fc:	00 
  80a6fd:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80a704:	00 
  80a705:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a70c:	e8 89 49 00 00       	call   80f09a <_panic>
    sems[sem].freed = 1;
  80a711:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80a714:	c1 e1 02             	shl    $0x2,%ecx
  80a717:	8d 91 a0 ad b3 00    	lea    0xb3ada0(%ecx),%edx
  80a71d:	c7 81 a0 ad b3 00 01 	movl   $0x1,0xb3ada0(%ecx)
  80a724:	00 00 00 
    sems[sem].gen++;
  80a727:	83 42 04 01          	addl   $0x1,0x4(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80a72b:	8b 0d 80 ad b3 00    	mov    0xb3ad80,%ecx
  80a731:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80a734:	85 c9                	test   %ecx,%ecx
  80a736:	74 0d                	je     80a745 <sys_sem_free+0x6e>
  80a738:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a73b:	8d 14 95 ac ad b3 00 	lea    0xb3adac(,%edx,4),%edx
  80a742:	89 51 10             	mov    %edx,0x10(%ecx)
  80a745:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a74c:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a74f:	8d 0c 8d a0 ad b3 00 	lea    0xb3ada0(,%ecx,4),%ecx
  80a756:	89 0d 80 ad b3 00    	mov    %ecx,0xb3ad80
  80a75c:	01 d0                	add    %edx,%eax
  80a75e:	c7 04 85 b0 ad b3 00 	movl   $0xb3ad80,0xb3adb0(,%eax,4)
  80a765:	80 ad b3 00 
}
  80a769:	c9                   	leave  
  80a76a:	c3                   	ret    

0080a76b <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80a76b:	55                   	push   %ebp
  80a76c:	89 e5                	mov    %esp,%ebp
  80a76e:	57                   	push   %edi
  80a76f:	56                   	push   %esi
  80a770:	53                   	push   %ebx
  80a771:	83 ec 1c             	sub    $0x1c,%esp
  80a774:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80a777:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80a77d:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80a784:	74 24                	je     80a7aa <sys_mbox_free+0x3f>
  80a786:	c7 44 24 0c 22 36 81 	movl   $0x813622,0xc(%esp)
  80a78d:	00 
  80a78e:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a795:	00 
  80a796:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80a79d:	00 
  80a79e:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a7a5:	e8 f0 48 00 00       	call   80f09a <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80a7aa:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80a7b0:	8b 86 0c 60 b3 00    	mov    0xb3600c(%esi),%eax
  80a7b6:	89 04 24             	mov    %eax,(%esp)
  80a7b9:	e8 19 ff ff ff       	call   80a6d7 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80a7be:	8b 86 10 60 b3 00    	mov    0xb36010(%esi),%eax
  80a7c4:	89 04 24             	mov    %eax,(%esp)
  80a7c7:	e8 0b ff ff ff       	call   80a6d7 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80a7cc:	a1 64 5f b3 00       	mov    0xb35f64,%eax
  80a7d1:	89 86 14 60 b3 00    	mov    %eax,0xb36014(%esi)
  80a7d7:	85 c0                	test   %eax,%eax
  80a7d9:	74 0e                	je     80a7e9 <sys_mbox_free+0x7e>
  80a7db:	89 f2                	mov    %esi,%edx
  80a7dd:	81 c2 14 60 b3 00    	add    $0xb36014,%edx
  80a7e3:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a7e9:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80a7ef:	8d 83 80 5f b3 00    	lea    0xb35f80(%ebx),%eax
  80a7f5:	a3 64 5f b3 00       	mov    %eax,0xb35f64
  80a7fa:	c7 83 18 60 b3 00 64 	movl   $0xb35f64,0xb36018(%ebx)
  80a801:	5f b3 00 
    mboxes[mbox].freed = 1;
  80a804:	c7 83 80 5f b3 00 01 	movl   $0x1,0xb35f80(%ebx)
  80a80b:	00 00 00 
}
  80a80e:	83 c4 1c             	add    $0x1c,%esp
  80a811:	5b                   	pop    %ebx
  80a812:	5e                   	pop    %esi
  80a813:	5f                   	pop    %edi
  80a814:	5d                   	pop    %ebp
  80a815:	c3                   	ret    

0080a816 <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80a816:	55                   	push   %ebp
  80a817:	89 e5                	mov    %esp,%ebp
  80a819:	56                   	push   %esi
  80a81a:	53                   	push   %ebx
  80a81b:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80a81e:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80a822:	7e 24                	jle    80a848 <sys_mbox_new+0x32>
  80a824:	c7 44 24 0c 36 36 81 	movl   $0x813636,0xc(%esp)
  80a82b:	00 
  80a82c:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a833:	00 
  80a834:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80a83b:	00 
  80a83c:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a843:	e8 52 48 00 00       	call   80f09a <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80a848:	8b 1d 64 5f b3 00    	mov    0xb35f64,%ebx
    if (!mbe) {
  80a84e:	85 db                	test   %ebx,%ebx
  80a850:	75 16                	jne    80a868 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80a852:	c7 04 24 88 34 81 00 	movl   $0x813488,(%esp)
  80a859:	e8 35 49 00 00       	call   80f193 <cprintf>
	return SYS_MBOX_NULL;
  80a85e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a863:	e9 c1 00 00 00       	jmp    80a929 <sys_mbox_new+0x113>
    }
    LIST_REMOVE(mbe, link);
  80a868:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a86e:	85 c0                	test   %eax,%eax
  80a870:	74 0c                	je     80a87e <sys_mbox_new+0x68>
  80a872:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80a878:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80a87e:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a884:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80a88a:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80a88c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a88f:	75 24                	jne    80a8b5 <sys_mbox_new+0x9f>
  80a891:	c7 44 24 0c 47 36 81 	movl   $0x813647,0xc(%esp)
  80a898:	00 
  80a899:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a8a0:	00 
  80a8a1:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80a8a8:	00 
  80a8a9:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a8b0:	e8 e5 47 00 00       	call   80f09a <_panic>
    mbe->freed = 0;
  80a8b5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80a8bb:	89 de                	mov    %ebx,%esi
  80a8bd:	81 ee 80 5f b3 00    	sub    $0xb35f80,%esi
  80a8c3:	c1 fe 02             	sar    $0x2,%esi
  80a8c6:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80a8cc:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80a8d3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80a8da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80a8e1:	e8 68 fd ff ff       	call   80a64e <sys_sem_new>
  80a8e6:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80a8ec:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80a8f3:	e8 56 fd ff ff       	call   80a64e <sys_sem_new>
  80a8f8:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80a8fe:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80a905:	74 05                	je     80a90c <sys_mbox_new+0xf6>
  80a907:	83 f8 ff             	cmp    $0xffffffff,%eax
  80a90a:	75 1b                	jne    80a927 <sys_mbox_new+0x111>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80a90c:	89 34 24             	mov    %esi,(%esp)
  80a90f:	e8 57 fe ff ff       	call   80a76b <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80a914:	c7 04 24 b0 34 81 00 	movl   $0x8134b0,(%esp)
  80a91b:	e8 73 48 00 00       	call   80f193 <cprintf>
	return SYS_MBOX_NULL;
  80a920:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80a925:	eb 02                	jmp    80a929 <sys_mbox_new+0x113>
    }
    return i;
  80a927:	89 f0                	mov    %esi,%eax
}
  80a929:	83 c4 10             	add    $0x10,%esp
  80a92c:	5b                   	pop    %ebx
  80a92d:	5e                   	pop    %esi
  80a92e:	5d                   	pop    %ebp
  80a92f:	c3                   	ret    

0080a930 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80a930:	55                   	push   %ebp
  80a931:	89 e5                	mov    %esp,%ebp
  80a933:	83 ec 18             	sub    $0x18,%esp
  80a936:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80a939:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a93c:	83 3c 95 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%edx,4)
  80a943:	00 
  80a944:	74 24                	je     80a96a <sys_sem_signal+0x3a>
  80a946:	c7 44 24 0c 11 36 81 	movl   $0x813611,0xc(%esp)
  80a94d:	00 
  80a94e:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a955:	00 
  80a956:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80a95d:	00 
  80a95e:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a965:	e8 30 47 00 00       	call   80f09a <_panic>
    sems[sem].counter++;
  80a96a:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80a96d:	8d 14 95 a0 ad b3 00 	lea    0xb3ada0(,%edx,4),%edx
  80a974:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80a979:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80a97e:	74 23                	je     80a9a3 <sys_sem_signal+0x73>
	sems[sem].waiters = 0;
  80a980:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
  80a987:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
  80a98a:	66 c7 04 8d aa ad b3 	movw   $0x0,0xb3adaa(,%ecx,4)
  80a991:	00 00 00 
	thread_wakeup(&sems[sem].v);
  80a994:	8d 04 8d a8 ad b3 00 	lea    0xb3ada8(,%ecx,4),%eax
  80a99b:	89 04 24             	mov    %eax,(%esp)
  80a99e:	e8 3c 05 00 00       	call   80aedf <thread_wakeup>
    }
}
  80a9a3:	c9                   	leave  
  80a9a4:	c3                   	ret    

0080a9a5 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80a9a5:	55                   	push   %ebp
  80a9a6:	89 e5                	mov    %esp,%ebp
  80a9a8:	57                   	push   %edi
  80a9a9:	56                   	push   %esi
  80a9aa:	53                   	push   %ebx
  80a9ab:	83 ec 2c             	sub    $0x2c,%esp
  80a9ae:	8b 75 0c             	mov    0xc(%ebp),%esi
    assert(!sems[sem].freed);
  80a9b1:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9b4:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a9b7:	83 3c 85 a0 ad b3 00 	cmpl   $0x0,0xb3ada0(,%eax,4)
  80a9be:	00 
  80a9bf:	74 24                	je     80a9e5 <sys_arch_sem_wait+0x40>
  80a9c1:	c7 44 24 0c 11 36 81 	movl   $0x813611,0xc(%esp)
  80a9c8:	00 
  80a9c9:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80a9d0:	00 
  80a9d1:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80a9d8:	00 
  80a9d9:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80a9e0:	e8 b5 46 00 00       	call   80f09a <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80a9e5:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9e8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80a9eb:	8b 04 85 a4 ad b3 00 	mov    0xb3ada4(,%eax,4),%eax
  80a9f2:	89 45 dc             	mov    %eax,-0x24(%ebp)

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80a9f5:	bf 00 00 00 00       	mov    $0x0,%edi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80a9fa:	8b 45 08             	mov    0x8(%ebp),%eax
  80a9fd:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80aa00:	89 45 e0             	mov    %eax,-0x20(%ebp)
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80aa03:	e9 90 00 00 00       	jmp    80aa98 <sys_arch_sem_wait+0xf3>
	if (sems[sem].counter > 0) {
  80aa08:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80aa0b:	0f b7 04 85 a8 ad b3 	movzwl 0xb3ada8(,%eax,4),%eax
  80aa12:	00 
  80aa13:	66 85 c0             	test   %ax,%ax
  80aa16:	74 18                	je     80aa30 <sys_arch_sem_wait+0x8b>
	    sems[sem].counter--;
  80aa18:	8b 55 08             	mov    0x8(%ebp),%edx
  80aa1b:	8d 14 92             	lea    (%edx,%edx,4),%edx
  80aa1e:	83 e8 01             	sub    $0x1,%eax
  80aa21:	66 89 04 95 a8 ad b3 	mov    %ax,0xb3ada8(,%edx,4)
  80aa28:	00 
	    return waited;
  80aa29:	89 f8                	mov    %edi,%eax
  80aa2b:	e9 84 00 00 00       	jmp    80aab4 <sys_arch_sem_wait+0x10f>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80aa30:	83 fe fe             	cmp    $0xfffffffe,%esi
  80aa33:	74 7a                	je     80aaaf <sys_arch_sem_wait+0x10a>
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80aa35:	e8 01 54 00 00       	call   80fe3b <sys_time_msec>
  80aa3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80aa3d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa42:	85 f6                	test   %esi,%esi
  80aa44:	74 07                	je     80aa4d <sys_arch_sem_wait+0xa8>
  80aa46:	89 f0                	mov    %esi,%eax
  80aa48:	29 f8                	sub    %edi,%eax
  80aa4a:	03 45 e4             	add    -0x1c(%ebp),%eax
	    sems[sem].waiters = 1;
  80aa4d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80aa50:	8d 1c 8d a0 ad b3 00 	lea    0xb3ada0(,%ecx,4),%ebx
  80aa57:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80aa5d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80aa61:	8b 43 08             	mov    0x8(%ebx),%eax
  80aa64:	89 44 24 04          	mov    %eax,0x4(%esp)
  80aa68:	8d 43 08             	lea    0x8(%ebx),%eax
  80aa6b:	89 04 24             	mov    %eax,(%esp)
  80aa6e:	e8 a6 06 00 00       	call   80b119 <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80aa73:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80aa76:	39 43 04             	cmp    %eax,0x4(%ebx)
  80aa79:	74 13                	je     80aa8e <sys_arch_sem_wait+0xe9>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80aa7b:	c7 04 24 dc 34 81 00 	movl   $0x8134dc,(%esp)
  80aa82:	e8 0c 47 00 00       	call   80f193 <cprintf>
		return SYS_ARCH_TIMEOUT;
  80aa87:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aa8c:	eb 26                	jmp    80aab4 <sys_arch_sem_wait+0x10f>
	    }
	    uint32_t b = sys_time_msec();
  80aa8e:	e8 a8 53 00 00       	call   80fe3b <sys_time_msec>
	    waited += (b - a);
  80aa93:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80aa96:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80aa98:	39 f7                	cmp    %esi,%edi
  80aa9a:	0f 82 68 ff ff ff    	jb     80aa08 <sys_arch_sem_wait+0x63>
  80aaa0:	85 f6                	test   %esi,%esi
  80aaa2:	0f 84 60 ff ff ff    	je     80aa08 <sys_arch_sem_wait+0x63>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80aaa8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80aaad:	eb 05                	jmp    80aab4 <sys_arch_sem_wait+0x10f>
    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80aaaf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80aab4:	83 c4 2c             	add    $0x2c,%esp
  80aab7:	5b                   	pop    %ebx
  80aab8:	5e                   	pop    %esi
  80aab9:	5f                   	pop    %edi
  80aaba:	5d                   	pop    %ebp
  80aabb:	c3                   	ret    

0080aabc <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80aabc:	55                   	push   %ebp
  80aabd:	89 e5                	mov    %esp,%ebp
  80aabf:	56                   	push   %esi
  80aac0:	53                   	push   %ebx
  80aac1:	83 ec 10             	sub    $0x10,%esp
  80aac4:	8b 5d 08             	mov    0x8(%ebp),%ebx
    assert(!mboxes[mbox].freed);
  80aac7:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80aacd:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80aad4:	74 24                	je     80aafa <sys_mbox_trypost+0x3e>
  80aad6:	c7 44 24 0c 22 36 81 	movl   $0x813622,0xc(%esp)
  80aadd:	00 
  80aade:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80aae5:	00 
  80aae6:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80aaed:	00 
  80aaee:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80aaf5:	e8 a0 45 00 00       	call   80f09a <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80aafa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ab01:	00 
  80ab02:	69 f3 9c 00 00 00    	imul   $0x9c,%ebx,%esi
  80ab08:	8b 86 10 60 b3 00    	mov    0xb36010(%esi),%eax
  80ab0e:	89 04 24             	mov    %eax,(%esp)
  80ab11:	e8 8f fe ff ff       	call   80a9a5 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80ab16:	8b 86 88 5f b3 00    	mov    0xb35f88(%esi),%eax
  80ab1c:	81 c6 80 5f b3 00    	add    $0xb35f80,%esi
  80ab22:	3b 46 04             	cmp    0x4(%esi),%eax
  80ab25:	74 53                	je     80ab7a <sys_mbox_trypost+0xbe>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80ab27:	89 f2                	mov    %esi,%edx
  80ab29:	8d 70 01             	lea    0x1(%eax),%esi
  80ab2c:	89 f1                	mov    %esi,%ecx
  80ab2e:	c1 f9 1f             	sar    $0x1f,%ecx
  80ab31:	c1 e9 1b             	shr    $0x1b,%ecx
  80ab34:	01 ce                	add    %ecx,%esi
  80ab36:	83 e6 1f             	and    $0x1f,%esi
  80ab39:	29 ce                	sub    %ecx,%esi
  80ab3b:	89 72 08             	mov    %esi,0x8(%edx)
    mboxes[mbox].msg[slot] = msg;
  80ab3e:	6b cb 27             	imul   $0x27,%ebx,%ecx
  80ab41:	01 c1                	add    %eax,%ecx
  80ab43:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ab46:	89 34 8d 8c 5f b3 00 	mov    %esi,0xb35f8c(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80ab4d:	83 7a 04 ff          	cmpl   $0xffffffff,0x4(%edx)
  80ab51:	75 0c                	jne    80ab5f <sys_mbox_trypost+0xa3>
	mboxes[mbox].head = slot;
  80ab53:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80ab59:	89 82 84 5f b3 00    	mov    %eax,0xb35f84(%edx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80ab5f:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80ab65:	8b 83 0c 60 b3 00    	mov    0xb3600c(%ebx),%eax
  80ab6b:	89 04 24             	mov    %eax,(%esp)
  80ab6e:	e8 bd fd ff ff       	call   80a930 <sys_sem_signal>

    return ERR_OK;
  80ab73:	b8 00 00 00 00       	mov    $0x0,%eax
  80ab78:	eb 05                	jmp    80ab7f <sys_mbox_trypost+0xc3>
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
	return ERR_MEM;
  80ab7a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	mboxes[mbox].head = slot;

    sys_sem_signal(mboxes[mbox].queued_msg);

    return ERR_OK;
}
  80ab7f:	83 c4 10             	add    $0x10,%esp
  80ab82:	5b                   	pop    %ebx
  80ab83:	5e                   	pop    %esi
  80ab84:	5d                   	pop    %ebp
  80ab85:	c3                   	ret    

0080ab86 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80ab86:	55                   	push   %ebp
  80ab87:	89 e5                	mov    %esp,%ebp
  80ab89:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80ab8c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ab8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ab93:	8b 45 08             	mov    0x8(%ebp),%eax
  80ab96:	89 04 24             	mov    %eax,(%esp)
  80ab99:	e8 1e ff ff ff       	call   80aabc <sys_mbox_trypost>
  80ab9e:	84 c0                	test   %al,%al
  80aba0:	74 24                	je     80abc6 <sys_mbox_post+0x40>
  80aba2:	c7 44 24 0c 08 35 81 	movl   $0x813508,0xc(%esp)
  80aba9:	00 
  80abaa:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80abb1:	00 
  80abb2:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80abb9:	00 
  80abba:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80abc1:	e8 d4 44 00 00       	call   80f09a <_panic>
}
  80abc6:	c9                   	leave  
  80abc7:	c3                   	ret    

0080abc8 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80abc8:	55                   	push   %ebp
  80abc9:	89 e5                	mov    %esp,%ebp
  80abcb:	57                   	push   %edi
  80abcc:	56                   	push   %esi
  80abcd:	53                   	push   %ebx
  80abce:	83 ec 1c             	sub    $0x1c,%esp
  80abd1:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80abd4:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80abd7:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80abdd:	83 b8 80 5f b3 00 00 	cmpl   $0x0,0xb35f80(%eax)
  80abe4:	74 24                	je     80ac0a <sys_arch_mbox_fetch+0x42>
  80abe6:	c7 44 24 0c 22 36 81 	movl   $0x813622,0xc(%esp)
  80abed:	00 
  80abee:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  80abf5:	00 
  80abf6:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80abfd:	00 
  80abfe:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ac05:	e8 90 44 00 00       	call   80f09a <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80ac0a:	8b 45 10             	mov    0x10(%ebp),%eax
  80ac0d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ac11:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ac17:	8b 80 0c 60 b3 00    	mov    0xb3600c(%eax),%eax
  80ac1d:	89 04 24             	mov    %eax,(%esp)
  80ac20:	e8 80 fd ff ff       	call   80a9a5 <sys_arch_sem_wait>
  80ac25:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80ac27:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ac2a:	0f 84 88 00 00 00    	je     80acb8 <sys_arch_mbox_fetch+0xf0>
	return waited;

    int slot = mboxes[mbox].head;
  80ac30:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ac36:	8b 80 84 5f b3 00    	mov    0xb35f84(%eax),%eax
    if (slot == -1)
  80ac3c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ac3f:	75 1c                	jne    80ac5d <sys_arch_mbox_fetch+0x95>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80ac41:	c7 44 24 08 30 35 81 	movl   $0x813530,0x8(%esp)
  80ac48:	00 
  80ac49:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80ac50:	00 
  80ac51:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ac58:	e8 3d 44 00 00       	call   80f09a <_panic>
    if (msg)
  80ac5d:	85 ff                	test   %edi,%edi
  80ac5f:	74 0e                	je     80ac6f <sys_arch_mbox_fetch+0xa7>
	*msg = mboxes[mbox].msg[slot];
  80ac61:	6b d3 27             	imul   $0x27,%ebx,%edx
  80ac64:	01 c2                	add    %eax,%edx
  80ac66:	8b 14 95 8c 5f b3 00 	mov    0xb35f8c(,%edx,4),%edx
  80ac6d:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80ac6f:	83 c0 01             	add    $0x1,%eax
  80ac72:	99                   	cltd   
  80ac73:	c1 ea 1b             	shr    $0x1b,%edx
  80ac76:	01 d0                	add    %edx,%eax
  80ac78:	83 e0 1f             	and    $0x1f,%eax
  80ac7b:	29 d0                	sub    %edx,%eax
  80ac7d:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80ac83:	89 82 84 5f b3 00    	mov    %eax,0xb35f84(%edx)
  80ac89:	81 c2 80 5f b3 00    	add    $0xb35f80,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80ac8f:	3b 42 08             	cmp    0x8(%edx),%eax
  80ac92:	75 10                	jne    80aca4 <sys_arch_mbox_fetch+0xdc>
	mboxes[mbox].head = -1;
  80ac94:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80ac9a:	c7 80 84 5f b3 00 ff 	movl   $0xffffffff,0xb35f84(%eax)
  80aca1:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80aca4:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80acaa:	8b 83 10 60 b3 00    	mov    0xb36010(%ebx),%eax
  80acb0:	89 04 24             	mov    %eax,(%esp)
  80acb3:	e8 78 fc ff ff       	call   80a930 <sys_sem_signal>
    return waited;
}
  80acb8:	89 f0                	mov    %esi,%eax
  80acba:	83 c4 1c             	add    $0x1c,%esp
  80acbd:	5b                   	pop    %ebx
  80acbe:	5e                   	pop    %esi
  80acbf:	5f                   	pop    %edi
  80acc0:	5d                   	pop    %ebp
  80acc1:	c3                   	ret    

0080acc2 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80acc2:	55                   	push   %ebp
  80acc3:	89 e5                	mov    %esp,%ebp
  80acc5:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80acc8:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80accf:	ff 
  80acd0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80acd3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80acd7:	8b 45 08             	mov    0x8(%ebp),%eax
  80acda:	89 04 24             	mov    %eax,(%esp)
  80acdd:	e8 e6 fe ff ff       	call   80abc8 <sys_arch_mbox_fetch>
}
  80ace2:	c9                   	leave  
  80ace3:	c3                   	ret    

0080ace4 <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80ace4:	55                   	push   %ebp
  80ace5:	89 e5                	mov    %esp,%ebp
  80ace7:	83 ec 28             	sub    $0x28,%esp
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80acea:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80acf1:	e8 1c 66 00 00       	call   811312 <malloc>
    if (lt == 0)
  80acf6:	85 c0                	test   %eax,%eax
  80acf8:	75 1c                	jne    80ad16 <sys_thread_new+0x32>
	panic("sys_thread_new: cannot allocate thread struct");
  80acfa:	c7 44 24 08 58 35 81 	movl   $0x813558,0x8(%esp)
  80ad01:	00 
  80ad02:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80ad09:	00 
  80ad0a:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ad11:	e8 84 43 00 00       	call   80f09a <_panic>

    if (stacksize > PGSIZE)
  80ad16:	81 7d 14 00 10 00 00 	cmpl   $0x1000,0x14(%ebp)
  80ad1d:	7e 23                	jle    80ad42 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80ad1f:	8b 45 14             	mov    0x14(%ebp),%eax
  80ad22:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad26:	c7 44 24 08 52 36 81 	movl   $0x813652,0x8(%esp)
  80ad2d:	00 
  80ad2e:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80ad35:	00 
  80ad36:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ad3d:	e8 58 43 00 00       	call   80f09a <_panic>

    lt->func = thread;
  80ad42:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ad45:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80ad47:	8b 55 10             	mov    0x10(%ebp),%edx
  80ad4a:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80ad4d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad51:	c7 44 24 08 40 a5 80 	movl   $0x80a540,0x8(%esp)
  80ad58:	00 
  80ad59:	8b 45 08             	mov    0x8(%ebp),%eax
  80ad5c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ad60:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80ad63:	89 04 24             	mov    %eax,(%esp)
  80ad66:	e8 e2 01 00 00       	call   80af4d <thread_create>

    if (r < 0)
  80ad6b:	85 c0                	test   %eax,%eax
  80ad6d:	79 28                	jns    80ad97 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80ad6f:	89 04 24             	mov    %eax,(%esp)
  80ad72:	e8 39 05 00 00       	call   80b2b0 <e2s>
  80ad77:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ad7b:	c7 44 24 08 88 35 81 	movl   $0x813588,0x8(%esp)
  80ad82:	00 
  80ad83:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80ad8a:	00 
  80ad8b:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ad92:	e8 03 43 00 00       	call   80f09a <_panic>

    return tid;
}
  80ad97:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80ad9a:	c9                   	leave  
  80ad9b:	c3                   	ret    

0080ad9c <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80ad9c:	55                   	push   %ebp
  80ad9d:	89 e5                	mov    %esp,%ebp
  80ad9f:	57                   	push   %edi
  80ada0:	56                   	push   %esi
  80ada1:	53                   	push   %ebx
  80ada2:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80ada5:	e8 29 01 00 00       	call   80aed3 <thread_id>
  80adaa:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80adac:	bf 01 ff 00 ff       	mov    $0xff00ff01,%edi
  80adb1:	f7 e7                	mul    %edi
  80adb3:	c1 ea 08             	shr    $0x8,%edx
  80adb6:	89 d7                	mov    %edx,%edi
  80adb8:	89 d0                	mov    %edx,%eax
  80adba:	c1 e0 08             	shl    $0x8,%eax
  80adbd:	01 c7                	add    %eax,%edi
  80adbf:	89 f0                	mov    %esi,%eax
  80adc1:	29 f8                	sub    %edi,%eax
  80adc3:	89 c7                	mov    %eax,%edi
  80adc5:	8b 1c 85 60 5b b3 00 	mov    0xb35b60(,%eax,4),%ebx
  80adcc:	eb 0b                	jmp    80add9 <sys_arch_timeouts+0x3d>
	if (t->tid == tid)
  80adce:	39 33                	cmp    %esi,(%ebx)
  80add0:	0f 84 b6 00 00 00    	je     80ae8c <sys_arch_timeouts+0xf0>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80add6:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80add9:	85 db                	test   %ebx,%ebx
  80addb:	75 f1                	jne    80adce <sys_arch_timeouts+0x32>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80addd:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80ade4:	e8 29 65 00 00       	call   811312 <malloc>
  80ade9:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80adeb:	85 c0                	test   %eax,%eax
  80aded:	75 1c                	jne    80ae0b <sys_arch_timeouts+0x6f>
	panic("sys_arch_timeouts: cannot malloc");
  80adef:	c7 44 24 08 b4 35 81 	movl   $0x8135b4,0x8(%esp)
  80adf6:	00 
  80adf7:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80adfe:	00 
  80adff:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ae06:	e8 8f 42 00 00       	call   80f09a <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80ae0b:	c7 04 24 60 a5 80 00 	movl   $0x80a560,(%esp)
  80ae12:	e8 0a 01 00 00       	call   80af21 <thread_onhalt>
    if (r < 0)
  80ae17:	85 c0                	test   %eax,%eax
  80ae19:	79 28                	jns    80ae43 <sys_arch_timeouts+0xa7>
	panic("thread_onhalt failed: %s", e2s(r));
  80ae1b:	89 04 24             	mov    %eax,(%esp)
  80ae1e:	e8 8d 04 00 00       	call   80b2b0 <e2s>
  80ae23:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ae27:	c7 44 24 08 61 36 81 	movl   $0x813661,0x8(%esp)
  80ae2e:	00 
  80ae2f:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80ae36:	00 
  80ae37:	c7 04 24 f4 35 81 00 	movl   $0x8135f4,(%esp)
  80ae3e:	e8 57 42 00 00       	call   80f09a <_panic>

    t->tid = tid;
  80ae43:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80ae45:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ae4c:	00 
  80ae4d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ae54:	00 
  80ae55:	8d 43 04             	lea    0x4(%ebx),%eax
  80ae58:	89 04 24             	mov    %eax,(%esp)
  80ae5b:	e8 a7 4a 00 00       	call   80f907 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80ae60:	8b 04 bd 60 5b b3 00 	mov    0xb35b60(,%edi,4),%eax
  80ae67:	89 43 08             	mov    %eax,0x8(%ebx)
  80ae6a:	85 c0                	test   %eax,%eax
  80ae6c:	74 0d                	je     80ae7b <sys_arch_timeouts+0xdf>
  80ae6e:	8b 04 bd 60 5b b3 00 	mov    0xb35b60(,%edi,4),%eax
  80ae75:	8d 53 08             	lea    0x8(%ebx),%edx
  80ae78:	89 50 0c             	mov    %edx,0xc(%eax)
  80ae7b:	89 1c bd 60 5b b3 00 	mov    %ebx,0xb35b60(,%edi,4)
  80ae82:	8d 04 bd 60 5b b3 00 	lea    0xb35b60(,%edi,4),%eax
  80ae89:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80ae8c:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80ae8f:	83 c4 1c             	add    $0x1c,%esp
  80ae92:	5b                   	pop    %ebx
  80ae93:	5e                   	pop    %esi
  80ae94:	5f                   	pop    %edi
  80ae95:	5d                   	pop    %ebp
  80ae96:	c3                   	ret    

0080ae97 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80ae97:	55                   	push   %ebp
  80ae98:	89 e5                	mov    %esp,%ebp
}
  80ae9a:	5d                   	pop    %ebp
  80ae9b:	c3                   	ret    

0080ae9c <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80ae9c:	55                   	push   %ebp
  80ae9d:	89 e5                	mov    %esp,%ebp
}
  80ae9f:	5d                   	pop    %ebp
  80aea0:	c3                   	ret    
  80aea1:	66 90                	xchg   %ax,%ax
  80aea3:	66 90                	xchg   %ax,%ax
  80aea5:	66 90                	xchg   %ax,%ax
  80aea7:	66 90                	xchg   %ax,%ax
  80aea9:	66 90                	xchg   %ax,%ax
  80aeab:	66 90                	xchg   %ax,%ax
  80aead:	66 90                	xchg   %ax,%ax
  80aeaf:	90                   	nop

0080aeb0 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80aeb0:	55                   	push   %ebp
  80aeb1:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80aeb3:	c7 05 a8 c1 b3 00 00 	movl   $0x0,0xb3c1a8
  80aeba:	00 00 00 
    tq->tq_last = 0;
  80aebd:	c7 05 ac c1 b3 00 00 	movl   $0x0,0xb3c1ac
  80aec4:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80aec7:	c7 05 b4 c1 b3 00 00 	movl   $0x0,0xb3c1b4
  80aece:	00 00 00 
}
  80aed1:	5d                   	pop    %ebp
  80aed2:	c3                   	ret    

0080aed3 <thread_id>:

uint32_t
thread_id(void) {
  80aed3:	55                   	push   %ebp
  80aed4:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80aed6:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80aedb:	8b 00                	mov    (%eax),%eax
}
  80aedd:	5d                   	pop    %ebp
  80aede:	c3                   	ret    

0080aedf <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80aedf:	55                   	push   %ebp
  80aee0:	89 e5                	mov    %esp,%ebp
  80aee2:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80aee5:	a1 a8 c1 b3 00       	mov    0xb3c1a8,%eax
    while (tc) {
  80aeea:	eb 0c                	jmp    80aef8 <thread_wakeup+0x19>
	if (tc->tc_wait_addr == addr)
  80aeec:	39 50 48             	cmp    %edx,0x48(%eax)
  80aeef:	75 04                	jne    80aef5 <thread_wakeup+0x16>
	    tc->tc_wakeup = 1;
  80aef1:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80aef5:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80aef8:	85 c0                	test   %eax,%eax
  80aefa:	75 f0                	jne    80aeec <thread_wakeup+0xd>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80aefc:	5d                   	pop    %ebp
  80aefd:	c3                   	ret    

0080aefe <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80aefe:	55                   	push   %ebp
  80aeff:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80af01:	8b 15 a8 c1 b3 00    	mov    0xb3c1a8,%edx
    int n = 0;
  80af07:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc) {
  80af0c:	eb 0d                	jmp    80af1b <thread_wakeups_pending+0x1d>
	if (tc->tc_wakeup)
  80af0e:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80af12:	80 f9 01             	cmp    $0x1,%cl
  80af15:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80af18:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80af1b:	85 d2                	test   %edx,%edx
  80af1d:	75 ef                	jne    80af0e <thread_wakeups_pending+0x10>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80af1f:	5d                   	pop    %ebp
  80af20:	c3                   	ret    

0080af21 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80af21:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80af26:	8b 50 60             	mov    0x60(%eax),%edx
  80af29:	83 fa 03             	cmp    $0x3,%edx
  80af2c:	7f 17                	jg     80af45 <thread_onhalt+0x24>
    }
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80af2e:	55                   	push   %ebp
  80af2f:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80af31:	8d 4a 01             	lea    0x1(%edx),%ecx
  80af34:	89 48 60             	mov    %ecx,0x60(%eax)
  80af37:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80af3a:	89 4c 90 50          	mov    %ecx,0x50(%eax,%edx,4)
    return 0;
  80af3e:	b8 00 00 00 00       	mov    $0x0,%eax
  80af43:	eb 06                	jmp    80af4b <thread_onhalt+0x2a>
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
	return -E_NO_MEM;
  80af45:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80af4a:	c3                   	ret    

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
    return 0;
}
  80af4b:	5d                   	pop    %ebp
  80af4c:	c3                   	ret    

0080af4d <thread_create>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80af4d:	55                   	push   %ebp
  80af4e:	89 e5                	mov    %esp,%ebp
  80af50:	57                   	push   %edi
  80af51:	56                   	push   %esi
  80af52:	53                   	push   %ebx
  80af53:	83 ec 1c             	sub    $0x1c,%esp
  80af56:	8b 75 08             	mov    0x8(%ebp),%esi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80af59:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80af60:	e8 ad 63 00 00       	call   811312 <malloc>
  80af65:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80af67:	85 c0                	test   %eax,%eax
  80af69:	0f 84 16 01 00 00    	je     80b085 <thread_create+0x138>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80af6f:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80af76:	00 
  80af77:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80af7e:	00 
  80af7f:	89 04 24             	mov    %eax,(%esp)
  80af82:	e8 80 49 00 00       	call   80f907 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80af87:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80af8e:	00 
  80af8f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80af92:	89 44 24 04          	mov    %eax,0x4(%esp)
  80af96:	8d 43 08             	lea    0x8(%ebx),%eax
  80af99:	89 04 24             	mov    %eax,(%esp)
  80af9c:	e8 61 48 00 00       	call   80f802 <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80afa1:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80afa5:	8b 15 b4 c1 b3 00    	mov    0xb3c1b4,%edx
  80afab:	8d 42 01             	lea    0x1(%edx),%eax
  80afae:	a3 b4 c1 b3 00       	mov    %eax,0xb3c1b4
    if (max_tid == (uint32_t)~0)
  80afb3:	83 f8 ff             	cmp    $0xffffffff,%eax
  80afb6:	75 1c                	jne    80afd4 <thread_create+0x87>
	panic("alloc_tid: no more thread ids");
  80afb8:	c7 44 24 08 7a 36 81 	movl   $0x81367a,0x8(%esp)
  80afbf:	00 
  80afc0:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80afc7:	00 
  80afc8:	c7 04 24 98 36 81 00 	movl   $0x813698,(%esp)
  80afcf:	e8 c6 40 00 00       	call   80f09a <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80afd4:	89 13                	mov    %edx,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80afd6:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80afdd:	e8 30 63 00 00       	call   811312 <malloc>
  80afe2:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80afe5:	85 c0                	test   %eax,%eax
  80afe7:	75 12                	jne    80affb <thread_create+0xae>
	free(tc);
  80afe9:	89 1c 24             	mov    %ebx,(%esp)
  80afec:	e8 4f 62 00 00       	call   811240 <free>
	return -E_NO_MEM;
  80aff1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80aff6:	e9 96 00 00 00       	jmp    80b091 <thread_create+0x144>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80affb:	8d b8 fc 0f 00 00    	lea    0xffc(%eax),%edi
    memset(stacktop, 0, 4);
  80b001:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80b008:	00 
  80b009:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b010:	00 
  80b011:	89 3c 24             	mov    %edi,(%esp)
  80b014:	e8 ee 48 00 00       	call   80f907 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80b019:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80b020:	00 
  80b021:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b028:	00 
  80b029:	8d 43 30             	lea    0x30(%ebx),%eax
  80b02c:	89 04 24             	mov    %eax,(%esp)
  80b02f:	e8 d3 48 00 00       	call   80f907 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80b034:	89 7b 34             	mov    %edi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80b037:	c7 43 30 17 b2 80 00 	movl   $0x80b217,0x30(%ebx)
    tc->tc_entry = entry;
  80b03e:	8b 45 10             	mov    0x10(%ebp),%eax
  80b041:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80b044:	8b 45 14             	mov    0x14(%ebp),%eax
  80b047:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b04a:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80b051:	83 3d a8 c1 b3 00 00 	cmpl   $0x0,0xb3c1a8
  80b058:	75 0e                	jne    80b068 <thread_create+0x11b>
	tq->tq_first = tc;
  80b05a:	89 1d a8 c1 b3 00    	mov    %ebx,0xb3c1a8
	tq->tq_last = tc;
  80b060:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac
  80b066:	eb 0e                	jmp    80b076 <thread_create+0x129>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b068:	a1 ac c1 b3 00       	mov    0xb3c1ac,%eax
  80b06d:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80b070:	89 1d ac c1 b3 00    	mov    %ebx,0xb3c1ac

    threadq_push(&thread_queue, tc);

    if (tid)
  80b076:	85 f6                	test   %esi,%esi
  80b078:	74 12                	je     80b08c <thread_create+0x13f>
	*tid = tc->tc_tid;
  80b07a:	8b 03                	mov    (%ebx),%eax
  80b07c:	89 06                	mov    %eax,(%esi)
    return 0;
  80b07e:	b8 00 00 00 00       	mov    $0x0,%eax
  80b083:	eb 0c                	jmp    80b091 <thread_create+0x144>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80b085:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80b08a:	eb 05                	jmp    80b091 <thread_create+0x144>

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80b08c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80b091:	83 c4 1c             	add    $0x1c,%esp
  80b094:	5b                   	pop    %ebx
  80b095:	5e                   	pop    %esi
  80b096:	5f                   	pop    %edi
  80b097:	5d                   	pop    %ebp
  80b098:	c3                   	ret    

0080b099 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80b099:	55                   	push   %ebp
  80b09a:	89 e5                	mov    %esp,%ebp
  80b09c:	53                   	push   %ebx
  80b09d:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b0a0:	8b 1d a8 c1 b3 00    	mov    0xb3c1a8,%ebx
  80b0a6:	85 db                	test   %ebx,%ebx
  80b0a8:	74 69                	je     80b113 <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b0aa:	8b 43 64             	mov    0x64(%ebx),%eax
  80b0ad:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
    tc->tc_queue_link = 0;
  80b0b2:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80b0b9:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b0be:	85 c0                	test   %eax,%eax
  80b0c0:	74 3e                	je     80b100 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80b0c2:	83 c0 30             	add    $0x30,%eax
  80b0c5:	89 04 24             	mov    %eax,(%esp)
  80b0c8:	e8 73 01 00 00       	call   80b240 <jos_setjmp>
  80b0cd:	85 c0                	test   %eax,%eax
  80b0cf:	75 42                	jne    80b113 <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80b0d1:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b0d6:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b0dd:	83 3d a8 c1 b3 00 00 	cmpl   $0x0,0xb3c1a8
  80b0e4:	75 0c                	jne    80b0f2 <thread_yield+0x59>
	tq->tq_first = tc;
  80b0e6:	a3 a8 c1 b3 00       	mov    %eax,0xb3c1a8
	tq->tq_last = tc;
  80b0eb:	a3 ac c1 b3 00       	mov    %eax,0xb3c1ac
  80b0f0:	eb 0e                	jmp    80b100 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b0f2:	8b 15 ac c1 b3 00    	mov    0xb3c1ac,%edx
  80b0f8:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b0fb:	a3 ac c1 b3 00       	mov    %eax,0xb3c1ac
    }

    cur_tc = next_tc;
  80b100:	89 1d b0 c1 b3 00    	mov    %ebx,0xb3c1b0
    jos_longjmp(&cur_tc->tc_jb, 1);
  80b106:	8d 43 30             	lea    0x30(%ebx),%eax
  80b109:	ba 01 00 00 00       	mov    $0x1,%edx
  80b10e:	e8 5d 01 00 00       	call   80b270 <jos_longjmp>
}
  80b113:	83 c4 14             	add    $0x14,%esp
  80b116:	5b                   	pop    %ebx
  80b117:	5d                   	pop    %ebp
  80b118:	c3                   	ret    

0080b119 <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80b119:	55                   	push   %ebp
  80b11a:	89 e5                	mov    %esp,%ebp
  80b11c:	57                   	push   %edi
  80b11d:	56                   	push   %esi
  80b11e:	53                   	push   %ebx
  80b11f:	83 ec 0c             	sub    $0xc,%esp
  80b122:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b125:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80b128:	e8 0e 4d 00 00       	call   80fe3b <sys_time_msec>
  80b12d:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80b12f:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b134:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b137:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
    uint32_t s = sys_time_msec();
    uint32_t p = s;
  80b13b:	89 f0                	mov    %esi,%eax

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b13d:	eb 26                	jmp    80b165 <thread_wait+0x4c>
	if (p < s)
  80b13f:	39 f0                	cmp    %esi,%eax
  80b141:	72 26                	jb     80b169 <thread_wait+0x50>
	    break;
	if (addr && *addr != val)
  80b143:	85 db                	test   %ebx,%ebx
  80b145:	74 07                	je     80b14e <thread_wait+0x35>
  80b147:	8b 03                	mov    (%ebx),%eax
  80b149:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80b14c:	75 1b                	jne    80b169 <thread_wait+0x50>
	    break;
	if (cur_tc->tc_wakeup)
  80b14e:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b153:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80b157:	84 c0                	test   %al,%al
  80b159:	75 0e                	jne    80b169 <thread_wait+0x50>
	    break;

	thread_yield();
  80b15b:	e8 39 ff ff ff       	call   80b099 <thread_yield>
	p = sys_time_msec();
  80b160:	e8 d6 4c 00 00       	call   80fe3b <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80b165:	39 f8                	cmp    %edi,%eax
  80b167:	72 d6                	jb     80b13f <thread_wait+0x26>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80b169:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b16e:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80b175:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80b179:	83 c4 0c             	add    $0xc,%esp
  80b17c:	5b                   	pop    %ebx
  80b17d:	5e                   	pop    %esi
  80b17e:	5f                   	pop    %edi
  80b17f:	5d                   	pop    %ebp
  80b180:	c3                   	ret    

0080b181 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80b181:	55                   	push   %ebp
  80b182:	89 e5                	mov    %esp,%ebp
  80b184:	56                   	push   %esi
  80b185:	53                   	push   %ebx
  80b186:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80b189:	8b 1d a0 c1 b3 00    	mov    0xb3c1a0,%ebx
  80b18f:	85 db                	test   %ebx,%ebx
  80b191:	74 3a                	je     80b1cd <thread_halt+0x4c>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80b193:	8b 43 64             	mov    0x64(%ebx),%eax
  80b196:	a3 a0 c1 b3 00       	mov    %eax,0xb3c1a0
    tc->tc_queue_link = 0;
  80b19b:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
  80b1a2:	be 00 00 00 00       	mov    $0x0,%esi
  80b1a7:	eb 0c                	jmp    80b1b5 <thread_halt+0x34>
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
	tc->tc_onhalt[i](tc->tc_tid);
  80b1a9:	8b 03                	mov    (%ebx),%eax
  80b1ab:	89 04 24             	mov    %eax,(%esp)
  80b1ae:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80b1b2:	83 c6 01             	add    $0x1,%esi
  80b1b5:	3b 73 60             	cmp    0x60(%ebx),%esi
  80b1b8:	7c ef                	jl     80b1a9 <thread_halt+0x28>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80b1ba:	8b 43 04             	mov    0x4(%ebx),%eax
  80b1bd:	89 04 24             	mov    %eax,(%esp)
  80b1c0:	e8 7b 60 00 00       	call   811240 <free>
    free(tc);
  80b1c5:	89 1c 24             	mov    %ebx,(%esp)
  80b1c8:	e8 73 60 00 00       	call   811240 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80b1cd:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80b1d2:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80b1d9:	83 3d a0 c1 b3 00 00 	cmpl   $0x0,0xb3c1a0
  80b1e0:	75 0c                	jne    80b1ee <thread_halt+0x6d>
	tq->tq_first = tc;
  80b1e2:	a3 a0 c1 b3 00       	mov    %eax,0xb3c1a0
	tq->tq_last = tc;
  80b1e7:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
  80b1ec:	eb 0e                	jmp    80b1fc <thread_halt+0x7b>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80b1ee:	8b 15 a4 c1 b3 00    	mov    0xb3c1a4,%edx
  80b1f4:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80b1f7:	a3 a4 c1 b3 00       	mov    %eax,0xb3c1a4
    cur_tc = NULL;
  80b1fc:	c7 05 b0 c1 b3 00 00 	movl   $0x0,0xb3c1b0
  80b203:	00 00 00 
    thread_yield();
  80b206:	e8 8e fe ff ff       	call   80b099 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80b20b:	e8 71 3e 00 00       	call   80f081 <exit>
}
  80b210:	83 c4 10             	add    $0x10,%esp
  80b213:	5b                   	pop    %ebx
  80b214:	5e                   	pop    %esi
  80b215:	5d                   	pop    %ebp
  80b216:	c3                   	ret    

0080b217 <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80b217:	55                   	push   %ebp
  80b218:	89 e5                	mov    %esp,%ebp
  80b21a:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80b21d:	a1 b0 c1 b3 00       	mov    0xb3c1b0,%eax
  80b222:	8b 50 2c             	mov    0x2c(%eax),%edx
  80b225:	89 14 24             	mov    %edx,(%esp)
  80b228:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80b22b:	e8 51 ff ff ff       	call   80b181 <thread_halt>
}
  80b230:	c9                   	leave  
  80b231:	c3                   	ret    
  80b232:	66 90                	xchg   %ax,%ax
  80b234:	66 90                	xchg   %ax,%ax
  80b236:	66 90                	xchg   %ax,%ax
  80b238:	66 90                	xchg   %ax,%ax
  80b23a:	66 90                	xchg   %ax,%ax
  80b23c:	66 90                	xchg   %ax,%ax
  80b23e:	66 90                	xchg   %ax,%ax

0080b240 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80b240:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80b244:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80b247:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80b249:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80b24d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80b250:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80b253:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80b256:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80b259:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80b25c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80b261:	c3                   	ret    
  80b262:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80b269:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080b270 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80b270:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80b272:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80b275:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80b278:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80b27b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80b27e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80b281:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80b283:	ff e1                	jmp    *%ecx

0080b285 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80b285:	55                   	push   %ebp
  80b286:	89 e5                	mov    %esp,%ebp
  80b288:	83 ec 18             	sub    $0x18,%esp
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
	return sys_errlist[err];
  80b28b:	a1 00 c2 b3 00       	mov    0xb3c200,%eax
};

void
perror(const char *s) {
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80b290:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
  80b297:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b29b:	8b 45 08             	mov    0x8(%ebp),%eax
  80b29e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2a2:	c7 04 24 b3 36 81 00 	movl   $0x8136b3,(%esp)
  80b2a9:	e8 e5 3e 00 00       	call   80f193 <cprintf>
}
  80b2ae:	c9                   	leave  
  80b2af:	c3                   	ret    

0080b2b0 <e2s>:

const char *
e2s(int err) {
  80b2b0:	55                   	push   %ebp
  80b2b1:	89 e5                	mov    %esp,%ebp
	return sys_errlist[err];
  80b2b3:	8b 45 08             	mov    0x8(%ebp),%eax
  80b2b6:	8b 04 85 20 50 81 00 	mov    0x815020(,%eax,4),%eax
}
  80b2bd:	5d                   	pop    %ebp
  80b2be:	c3                   	ret    
  80b2bf:	90                   	nop

0080b2c0 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80b2c0:	55                   	push   %ebp
  80b2c1:	89 e5                	mov    %esp,%ebp
  80b2c3:	57                   	push   %edi
  80b2c4:	56                   	push   %esi
  80b2c5:	53                   	push   %ebx
  80b2c6:	83 ec 2c             	sub    $0x2c,%esp
  80b2c9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80b2cc:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80b2d3:	00 
  80b2d4:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b2db:	10 
  80b2dc:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b2e3:	e8 eb 48 00 00       	call   80fbd3 <sys_page_alloc>
    if (r < 0)
  80b2e8:	85 c0                	test   %eax,%eax
  80b2ea:	79 1c                	jns    80b308 <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80b2ec:	c7 44 24 08 98 3b 81 	movl   $0x813b98,0x8(%esp)
  80b2f3:	00 
  80b2f4:	c7 44 24 04 59 00 00 	movl   $0x59,0x4(%esp)
  80b2fb:	00 
  80b2fc:	c7 04 24 e9 3b 81 00 	movl   $0x813be9,(%esp)
  80b303:	e8 92 3d 00 00       	call   80f09a <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80b308:	8b 45 08             	mov    0x8(%ebp),%eax
  80b30b:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b30e:	89 45 e4             	mov    %eax,-0x1c(%ebp)

    char *txbuf = pkt->jp_data;
  80b311:	bf 04 00 00 10       	mov    $0x10000004,%edi
    int txsize = 0;
  80b316:	be 00 00 00 00       	mov    $0x0,%esi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b31b:	eb 57                	jmp    80b374 <low_level_output+0xb4>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80b31d:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b321:	0f b7 d0             	movzwl %ax,%edx
  80b324:	8d 0c 32             	lea    (%edx,%esi,1),%ecx
  80b327:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80b32d:	7e 24                	jle    80b353 <low_level_output+0x93>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80b32f:	89 74 24 10          	mov    %esi,0x10(%esp)
  80b333:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80b337:	c7 44 24 08 c0 3b 81 	movl   $0x813bc0,0x8(%esp)
  80b33e:	00 
  80b33f:	c7 44 24 04 68 00 00 	movl   $0x68,0x4(%esp)
  80b346:	00 
  80b347:	c7 04 24 e9 3b 81 00 	movl   $0x813be9,(%esp)
  80b34e:	e8 47 3d 00 00       	call   80f09a <_panic>
	memcpy(&txbuf[txsize], q->payload, q->len);
  80b353:	0f b7 c0             	movzwl %ax,%eax
  80b356:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b35a:	8b 43 04             	mov    0x4(%ebx),%eax
  80b35d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b361:	8d 04 37             	lea    (%edi,%esi,1),%eax
  80b364:	89 04 24             	mov    %eax,(%esp)
  80b367:	e8 50 46 00 00       	call   80f9bc <memcpy>
	txsize += q->len;
  80b36c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80b370:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b372:	8b 1b                	mov    (%ebx),%ebx
  80b374:	85 db                	test   %ebx,%ebx
  80b376:	75 a5                	jne    80b31d <low_level_output+0x5d>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80b378:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80b37e:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80b385:	00 
  80b386:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80b38d:	10 
  80b38e:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80b395:	00 
  80b396:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b399:	8b 40 04             	mov    0x4(%eax),%eax
  80b39c:	89 04 24             	mov    %eax,(%esp)
  80b39f:	e8 e4 4f 00 00       	call   810388 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80b3a4:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80b3ab:	10 
  80b3ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80b3b3:	e8 c2 48 00 00       	call   80fc7a <sys_page_unmap>

    return ERR_OK;
}
  80b3b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3bd:	83 c4 2c             	add    $0x2c,%esp
  80b3c0:	5b                   	pop    %ebx
  80b3c1:	5e                   	pop    %esi
  80b3c2:	5f                   	pop    %edi
  80b3c3:	5d                   	pop    %ebp
  80b3c4:	c3                   	ret    

0080b3c5 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80b3c5:	55                   	push   %ebp
  80b3c6:	89 e5                	mov    %esp,%ebp
  80b3c8:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80b3cb:	8b 45 10             	mov    0x10(%ebp),%eax
  80b3ce:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b3d2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b3d5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3d9:	8b 45 08             	mov    0x8(%ebp),%eax
  80b3dc:	89 04 24             	mov    %eax,(%esp)
  80b3df:	e8 bf ef ff ff       	call   80a3a3 <etharp_output>
}
  80b3e4:	c9                   	leave  
  80b3e5:	c3                   	ret    

0080b3e6 <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80b3e6:	55                   	push   %ebp
  80b3e7:	89 e5                	mov    %esp,%ebp
  80b3e9:	57                   	push   %edi
  80b3ea:	56                   	push   %esi
  80b3eb:	53                   	push   %ebx
  80b3ec:	83 ec 2c             	sub    $0x2c,%esp
  80b3ef:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80b3f2:	8b 45 08             	mov    0x8(%ebp),%eax
  80b3f5:	8b 40 1c             	mov    0x1c(%eax),%eax
  80b3f8:	89 45 d8             	mov    %eax,-0x28(%ebp)
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
    s16_t len = pkt->jp_len;
  80b3fb:	8b 03                	mov    (%ebx),%eax
  80b3fd:	89 c7                	mov    %eax,%edi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80b3ff:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80b406:	00 
  80b407:	0f b7 c0             	movzwl %ax,%eax
  80b40a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b40e:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80b415:	e8 eb 9a ff ff       	call   804f05 <pbuf_alloc>
  80b41a:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80b41d:	85 c0                	test   %eax,%eax
  80b41f:	0f 84 c1 00 00 00    	je     80b4e6 <jif_input+0x100>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80b425:	8d 53 04             	lea    0x4(%ebx),%edx
  80b428:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b42b:	89 c3                	mov    %eax,%ebx
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
  80b42d:	be 00 00 00 00       	mov    $0x0,%esi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  80b432:	0f bf c7             	movswl %di,%eax
  80b435:	89 45 e0             	mov    %eax,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80b438:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
	if (bytes > (len - copied))
  80b43c:	8b 7d e0             	mov    -0x20(%ebp),%edi
  80b43f:	29 f7                	sub    %esi,%edi
  80b441:	39 c7                	cmp    %eax,%edi
  80b443:	0f 4f f8             	cmovg  %eax,%edi
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80b446:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b44a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b44d:	01 f0                	add    %esi,%eax
  80b44f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b453:	8b 43 04             	mov    0x4(%ebx),%eax
  80b456:	89 04 24             	mov    %eax,(%esp)
  80b459:	e8 5e 45 00 00       	call   80f9bc <memcpy>
	copied += bytes;
  80b45e:	01 fe                	add    %edi,%esi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80b460:	8b 1b                	mov    (%ebx),%ebx
  80b462:	85 db                	test   %ebx,%ebx
  80b464:	75 d2                	jne    80b438 <jif_input+0x52>
  80b466:	eb 5e                	jmp    80b4c6 <jif_input+0xe0>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80b468:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80b46b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b46f:	8b 45 08             	mov    0x8(%ebp),%eax
  80b472:	89 04 24             	mov    %eax,(%esp)
  80b475:	e8 49 e9 ff ff       	call   809dc3 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80b47a:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80b481:	ff 
  80b482:	89 34 24             	mov    %esi,(%esp)
  80b485:	e8 b6 98 ff ff       	call   804d40 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80b48a:	8b 45 08             	mov    0x8(%ebp),%eax
  80b48d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b491:	89 34 24             	mov    %esi,(%esp)
  80b494:	8b 45 08             	mov    0x8(%ebp),%eax
  80b497:	ff 50 10             	call   *0x10(%eax)
	break;
  80b49a:	eb 4a                	jmp    80b4e6 <jif_input+0x100>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80b49c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b49f:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b4a3:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b4a6:	8b 00                	mov    (%eax),%eax
  80b4a8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b4ac:	8b 45 08             	mov    0x8(%ebp),%eax
  80b4af:	89 04 24             	mov    %eax,(%esp)
  80b4b2:	e8 5a e9 ff ff       	call   809e11 <etharp_arp_input>
	break;
  80b4b7:	eb 2d                	jmp    80b4e6 <jif_input+0x100>

    default:
	pbuf_free(p);
  80b4b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b4bc:	89 04 24             	mov    %eax,(%esp)
  80b4bf:	e8 60 99 ff ff       	call   804e24 <pbuf_free>
  80b4c4:	eb 20                	jmp    80b4e6 <jif_input+0x100>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80b4c6:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80b4c9:	8b 40 04             	mov    0x4(%eax),%eax
  80b4cc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b4d0:	89 04 24             	mov    %eax,(%esp)
  80b4d3:	e8 ce c8 ff ff       	call   807da6 <htons>
  80b4d8:	66 3d 00 08          	cmp    $0x800,%ax
  80b4dc:	74 8a                	je     80b468 <jif_input+0x82>
  80b4de:	66 3d 06 08          	cmp    $0x806,%ax
  80b4e2:	74 b8                	je     80b49c <jif_input+0xb6>
  80b4e4:	eb d3                	jmp    80b4b9 <jif_input+0xd3>
	break;

    default:
	pbuf_free(p);
    }
}
  80b4e6:	83 c4 2c             	add    $0x2c,%esp
  80b4e9:	5b                   	pop    %ebx
  80b4ea:	5e                   	pop    %esi
  80b4eb:	5f                   	pop    %edi
  80b4ec:	5d                   	pop    %ebp
  80b4ed:	c3                   	ret    

0080b4ee <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80b4ee:	55                   	push   %ebp
  80b4ef:	89 e5                	mov    %esp,%ebp
  80b4f1:	57                   	push   %edi
  80b4f2:	56                   	push   %esi
  80b4f3:	53                   	push   %ebx
  80b4f4:	83 ec 2c             	sub    $0x2c,%esp
  80b4f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80b4fa:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80b501:	e8 e9 92 ff ff       	call   8047ef <mem_malloc>
  80b506:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80b508:	85 c0                	test   %eax,%eax
  80b50a:	74 7c                	je     80b588 <jif_init+0x9a>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80b50c:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80b50f:	89 43 1c             	mov    %eax,0x1c(%ebx)
    netif->output = jif_output;
  80b512:	c7 43 14 c5 b3 80 00 	movl   $0x80b3c5,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80b519:	c7 43 18 c0 b2 80 00 	movl   $0x80b2c0,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80b520:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80b527:	00 
  80b528:	c7 44 24 04 08 49 81 	movl   $0x814908,0x4(%esp)
  80b52f:	00 
  80b530:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80b533:	89 04 24             	mov    %eax,(%esp)
  80b536:	e8 81 44 00 00       	call   80f9bc <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80b53b:	8d 43 25             	lea    0x25(%ebx),%eax
  80b53e:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80b540:	8b 17                	mov    (%edi),%edx
  80b542:	89 56 04             	mov    %edx,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80b545:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80b549:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80b54f:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)
    netif->hwaddr[3] = 0x12;
    netif->hwaddr[4] = 0x34;
    netif->hwaddr[5] = 0x56;
    */
    //syscall to get hwaddr from EEPROM
    sys_e1000_get_mac(netif->hwaddr);
  80b553:	89 04 24             	mov    %eax,(%esp)
  80b556:	e8 41 49 00 00       	call   80fe9c <sys_e1000_get_mac>
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80b55b:	c7 04 24 2b 1f 81 00 	movl   $0x811f2b,(%esp)
  80b562:	e8 6e ca ff ff       	call   807fd5 <inet_addr>
  80b567:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80b56a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b571:	00 
  80b572:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b575:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b579:	89 1c 24             	mov    %ebx,(%esp)
  80b57c:	e8 b3 eb ff ff       	call   80a134 <etharp_query>

    return ERR_OK;
  80b581:	b8 00 00 00 00       	mov    $0x0,%eax
  80b586:	eb 05                	jmp    80b58d <jif_init+0x9f>

    jif = mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  80b588:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);

    return ERR_OK;
}
  80b58d:	83 c4 2c             	add    $0x2c,%esp
  80b590:	5b                   	pop    %ebx
  80b591:	5e                   	pop    %esi
  80b592:	5f                   	pop    %edi
  80b593:	5d                   	pop    %ebp
  80b594:	c3                   	ret    

0080b595 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80b595:	55                   	push   %ebp
  80b596:	89 e5                	mov    %esp,%ebp
  80b598:	56                   	push   %esi
  80b599:	53                   	push   %ebx
  80b59a:	83 ec 30             	sub    $0x30,%esp
  80b59d:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80b5a0:	8b 45 10             	mov    0x10(%ebp),%eax
  80b5a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b5a7:	8b 45 08             	mov    0x8(%ebp),%eax
  80b5aa:	89 04 24             	mov    %eax,(%esp)
  80b5ad:	e8 48 10 00 00       	call   80c5fa <netconn_alloc>
  80b5b2:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80b5b4:	85 c0                	test   %eax,%eax
  80b5b6:	0f 84 d8 00 00 00    	je     80b694 <netconn_new_with_proto_and_callback+0xff>
    msg.function = do_newconn;
  80b5bc:	c7 45 e4 f3 c4 80 00 	movl   $0x80c4f3,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80b5c3:	89 f0                	mov    %esi,%eax
  80b5c5:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80b5c8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80b5cb:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b5ce:	89 04 24             	mov    %eax,(%esp)
  80b5d1:	e8 85 71 ff ff       	call   80275b <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80b5d6:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80b5da:	0f 84 b6 00 00 00    	je     80b696 <netconn_new_with_proto_and_callback+0x101>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80b5e0:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80b5e4:	74 1c                	je     80b602 <netconn_new_with_proto_and_callback+0x6d>
  80b5e6:	c7 44 24 08 00 3c 81 	movl   $0x813c00,0x8(%esp)
  80b5ed:	00 
  80b5ee:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80b5f5:	00 
  80b5f6:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b5fd:	e8 98 3a 00 00       	call   80f09a <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80b602:	8b 43 10             	mov    0x10(%ebx),%eax
  80b605:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b608:	75 1c                	jne    80b626 <netconn_new_with_proto_and_callback+0x91>
  80b60a:	c7 44 24 08 c9 3c 81 	movl   $0x813cc9,0x8(%esp)
  80b611:	00 
  80b612:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80b619:	00 
  80b61a:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b621:	e8 74 3a 00 00       	call   80f09a <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80b626:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80b62a:	75 1c                	jne    80b648 <netconn_new_with_proto_and_callback+0xb3>
  80b62c:	c7 44 24 08 e2 3c 81 	movl   $0x813ce2,0x8(%esp)
  80b633:	00 
  80b634:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80b63b:	00 
  80b63c:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b643:	e8 52 3a 00 00       	call   80f09a <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80b648:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80b64c:	74 1c                	je     80b66a <netconn_new_with_proto_and_callback+0xd5>
  80b64e:	c7 44 24 08 24 3c 81 	movl   $0x813c24,0x8(%esp)
  80b655:	00 
  80b656:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80b65d:	00 
  80b65e:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b665:	e8 30 3a 00 00       	call   80f09a <_panic>
      sys_sem_free(conn->op_completed);
  80b66a:	89 04 24             	mov    %eax,(%esp)
  80b66d:	e8 65 f0 ff ff       	call   80a6d7 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80b672:	8b 43 14             	mov    0x14(%ebx),%eax
  80b675:	89 04 24             	mov    %eax,(%esp)
  80b678:	e8 ee f0 ff ff       	call   80a76b <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80b67d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b681:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80b688:	e8 e5 93 ff ff       	call   804a72 <memp_free>
      return NULL;
  80b68d:	b8 00 00 00 00       	mov    $0x0,%eax
  80b692:	eb 04                	jmp    80b698 <netconn_new_with_proto_and_callback+0x103>
  80b694:	eb 02                	jmp    80b698 <netconn_new_with_proto_and_callback+0x103>
    }
  }
  return conn;
  80b696:	89 d8                	mov    %ebx,%eax
}
  80b698:	83 c4 30             	add    $0x30,%esp
  80b69b:	5b                   	pop    %ebx
  80b69c:	5e                   	pop    %esi
  80b69d:	5d                   	pop    %ebp
  80b69e:	c3                   	ret    

0080b69f <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80b69f:	55                   	push   %ebp
  80b6a0:	89 e5                	mov    %esp,%ebp
  80b6a2:	53                   	push   %ebx
  80b6a3:	83 ec 34             	sub    $0x34,%esp
  80b6a6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80b6a9:	85 db                	test   %ebx,%ebx
  80b6ab:	74 24                	je     80b6d1 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80b6ad:	c7 45 e4 4f c8 80 00 	movl   $0x80c84f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b6b4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80b6b7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b6ba:	89 04 24             	mov    %eax,(%esp)
  80b6bd:	e8 99 70 ff ff       	call   80275b <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80b6c2:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80b6c9:	89 1c 24             	mov    %ebx,(%esp)
  80b6cc:	e8 e7 0f 00 00       	call   80c6b8 <netconn_free>

  return ERR_OK;
}
  80b6d1:	b8 00 00 00 00       	mov    $0x0,%eax
  80b6d6:	83 c4 34             	add    $0x34,%esp
  80b6d9:	5b                   	pop    %ebx
  80b6da:	5d                   	pop    %ebp
  80b6db:	c3                   	ret    

0080b6dc <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80b6dc:	55                   	push   %ebp
  80b6dd:	89 e5                	mov    %esp,%ebp
  80b6df:	83 ec 18             	sub    $0x18,%esp
  80b6e2:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80b6e5:	85 c0                	test   %eax,%eax
  80b6e7:	75 1c                	jne    80b705 <netconn_type+0x29>
  80b6e9:	c7 44 24 08 f7 3c 81 	movl   $0x813cf7,0x8(%esp)
  80b6f0:	00 
  80b6f1:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80b6f8:	00 
  80b6f9:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b700:	e8 95 39 00 00       	call   80f09a <_panic>
  80b705:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80b707:	c9                   	leave  
  80b708:	c3                   	ret    

0080b709 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80b709:	55                   	push   %ebp
  80b70a:	89 e5                	mov    %esp,%ebp
  80b70c:	53                   	push   %ebx
  80b70d:	83 ec 34             	sub    $0x34,%esp
  80b710:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b713:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b716:	8b 45 10             	mov    0x10(%ebp),%eax
  80b719:	8b 4d 14             	mov    0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80b71c:	85 db                	test   %ebx,%ebx
  80b71e:	75 1c                	jne    80b73c <netconn_getaddr+0x33>
  80b720:	c7 44 24 08 12 3d 81 	movl   $0x813d12,0x8(%esp)
  80b727:	00 
  80b728:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80b72f:	00 
  80b730:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b737:	e8 5e 39 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80b73c:	85 d2                	test   %edx,%edx
  80b73e:	75 1c                	jne    80b75c <netconn_getaddr+0x53>
  80b740:	c7 44 24 08 30 3d 81 	movl   $0x813d30,0x8(%esp)
  80b747:	00 
  80b748:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b74f:	00 
  80b750:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b757:	e8 3e 39 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80b75c:	85 c0                	test   %eax,%eax
  80b75e:	75 1c                	jne    80b77c <netconn_getaddr+0x73>
  80b760:	c7 44 24 08 4e 3d 81 	movl   $0x813d4e,0x8(%esp)
  80b767:	00 
  80b768:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80b76f:	00 
  80b770:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b777:	e8 1e 39 00 00       	call   80f09a <_panic>

  msg.function = do_getaddr;
  80b77c:	c7 45 e4 c0 cc 80 00 	movl   $0x80ccc0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b783:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80b786:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80b789:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80b78c:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80b78f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b792:	89 04 24             	mov    %eax,(%esp)
  80b795:	e8 c1 6f ff ff       	call   80275b <tcpip_apimsg>

  return conn->err;
  80b79a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b79e:	83 c4 34             	add    $0x34,%esp
  80b7a1:	5b                   	pop    %ebx
  80b7a2:	5d                   	pop    %ebp
  80b7a3:	c3                   	ret    

0080b7a4 <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b7a4:	55                   	push   %ebp
  80b7a5:	89 e5                	mov    %esp,%ebp
  80b7a7:	53                   	push   %ebx
  80b7a8:	83 ec 34             	sub    $0x34,%esp
  80b7ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b7ae:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80b7b1:	85 db                	test   %ebx,%ebx
  80b7b3:	75 1c                	jne    80b7d1 <netconn_bind+0x2d>
  80b7b5:	c7 44 24 08 6c 3d 81 	movl   $0x813d6c,0x8(%esp)
  80b7bc:	00 
  80b7bd:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80b7c4:	00 
  80b7c5:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b7cc:	e8 c9 38 00 00       	call   80f09a <_panic>

  msg.function = do_bind;
  80b7d1:	c7 45 e4 01 c9 80 00 	movl   $0x80c901,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b7d8:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b7db:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b7de:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b7e1:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80b7e5:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b7e8:	89 04 24             	mov    %eax,(%esp)
  80b7eb:	e8 6b 6f ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80b7f0:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b7f4:	83 c4 34             	add    $0x34,%esp
  80b7f7:	5b                   	pop    %ebx
  80b7f8:	5d                   	pop    %ebp
  80b7f9:	c3                   	ret    

0080b7fa <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80b7fa:	55                   	push   %ebp
  80b7fb:	89 e5                	mov    %esp,%ebp
  80b7fd:	53                   	push   %ebx
  80b7fe:	83 ec 34             	sub    $0x34,%esp
  80b801:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b804:	8b 45 10             	mov    0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b807:	85 db                	test   %ebx,%ebx
  80b809:	75 1c                	jne    80b827 <netconn_connect+0x2d>
  80b80b:	c7 44 24 08 87 3d 81 	movl   $0x813d87,0x8(%esp)
  80b812:	00 
  80b813:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80b81a:	00 
  80b81b:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b822:	e8 73 38 00 00       	call   80f09a <_panic>

  msg.function = do_connect;
  80b827:	c7 45 e4 97 c9 80 00 	movl   $0x80c997,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b82e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80b831:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b834:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80b837:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80b83b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b83e:	89 04 24             	mov    %eax,(%esp)
  80b841:	e8 15 6f ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80b846:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b84a:	83 c4 34             	add    $0x34,%esp
  80b84d:	5b                   	pop    %ebx
  80b84e:	5d                   	pop    %ebp
  80b84f:	c3                   	ret    

0080b850 <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80b850:	55                   	push   %ebp
  80b851:	89 e5                	mov    %esp,%ebp
  80b853:	53                   	push   %ebx
  80b854:	83 ec 34             	sub    $0x34,%esp
  80b857:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80b85a:	85 db                	test   %ebx,%ebx
  80b85c:	75 1c                	jne    80b87a <netconn_disconnect+0x2a>
  80b85e:	c7 44 24 08 48 3c 81 	movl   $0x813c48,0x8(%esp)
  80b865:	00 
  80b866:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80b86d:	00 
  80b86e:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b875:	e8 20 38 00 00       	call   80f09a <_panic>

  msg.function = do_disconnect;
  80b87a:	c7 45 e4 5d ca 80 00 	movl   $0x80ca5d,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b881:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80b884:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b887:	89 04 24             	mov    %eax,(%esp)
  80b88a:	e8 cc 6e ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80b88f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b893:	83 c4 34             	add    $0x34,%esp
  80b896:	5b                   	pop    %ebx
  80b897:	5d                   	pop    %ebp
  80b898:	c3                   	ret    

0080b899 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80b899:	55                   	push   %ebp
  80b89a:	89 e5                	mov    %esp,%ebp
  80b89c:	53                   	push   %ebx
  80b89d:	83 ec 34             	sub    $0x34,%esp
  80b8a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80b8a3:	85 db                	test   %ebx,%ebx
  80b8a5:	75 1c                	jne    80b8c3 <netconn_listen_with_backlog+0x2a>
  80b8a7:	c7 44 24 08 a5 3d 81 	movl   $0x813da5,0x8(%esp)
  80b8ae:	00 
  80b8af:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80b8b6:	00 
  80b8b7:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b8be:	e8 d7 37 00 00       	call   80f09a <_panic>

  msg.function = do_listen;
  80b8c3:	c7 45 e4 94 ca 80 00 	movl   $0x80ca94,-0x1c(%ebp)
  msg.msg.conn = conn;
  80b8ca:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80b8cd:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80b8d0:	89 04 24             	mov    %eax,(%esp)
  80b8d3:	e8 83 6e ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80b8d8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80b8dc:	83 c4 34             	add    $0x34,%esp
  80b8df:	5b                   	pop    %ebx
  80b8e0:	5d                   	pop    %ebp
  80b8e1:	c3                   	ret    

0080b8e2 <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80b8e2:	55                   	push   %ebp
  80b8e3:	89 e5                	mov    %esp,%ebp
  80b8e5:	53                   	push   %ebx
  80b8e6:	83 ec 24             	sub    $0x24,%esp
  80b8e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80b8ec:	85 db                	test   %ebx,%ebx
  80b8ee:	75 1c                	jne    80b90c <netconn_accept+0x2a>
  80b8f0:	c7 44 24 08 c2 3d 81 	movl   $0x813dc2,0x8(%esp)
  80b8f7:	00 
  80b8f8:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80b8ff:	00 
  80b900:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b907:	e8 8e 37 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80b90c:	8b 43 18             	mov    0x18(%ebx),%eax
  80b90f:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b912:	75 1c                	jne    80b930 <netconn_accept+0x4e>
  80b914:	c7 44 24 08 6c 3c 81 	movl   $0x813c6c,0x8(%esp)
  80b91b:	00 
  80b91c:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80b923:	00 
  80b924:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b92b:	e8 6a 37 00 00       	call   80f09a <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80b930:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b937:	00 
  80b938:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80b93b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b93f:	89 04 24             	mov    %eax,(%esp)
  80b942:	e8 81 f2 ff ff       	call   80abc8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80b947:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80b94a:	85 c0                	test   %eax,%eax
  80b94c:	74 15                	je     80b963 <netconn_accept+0x81>
  80b94e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b955:	00 
  80b956:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b95d:	00 
  80b95e:	89 1c 24             	mov    %ebx,(%esp)
  80b961:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80b963:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80b966:	83 c4 24             	add    $0x24,%esp
  80b969:	5b                   	pop    %ebx
  80b96a:	5d                   	pop    %ebp
  80b96b:	c3                   	ret    

0080b96c <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80b96c:	55                   	push   %ebp
  80b96d:	89 e5                	mov    %esp,%ebp
  80b96f:	53                   	push   %ebx
  80b970:	83 ec 34             	sub    $0x34,%esp
  80b973:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80b976:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80b97d:	85 db                	test   %ebx,%ebx
  80b97f:	75 1c                	jne    80b99d <netconn_recv+0x31>
  80b981:	c7 44 24 08 df 3d 81 	movl   $0x813ddf,0x8(%esp)
  80b988:	00 
  80b989:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80b990:	00 
  80b991:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80b998:	e8 fd 36 00 00       	call   80f09a <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80b99d:	8b 43 14             	mov    0x14(%ebx),%eax
  80b9a0:	83 f8 ff             	cmp    $0xffffffff,%eax
  80b9a3:	75 0e                	jne    80b9b3 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80b9a5:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  80b9a9:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9ae:	e9 58 01 00 00       	jmp    80bb0b <netconn_recv+0x19f>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80b9b3:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80b9b7:	0f 8c 49 01 00 00    	jl     80bb06 <netconn_recv+0x19a>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80b9bd:	83 3b 10             	cmpl   $0x10,(%ebx)
  80b9c0:	0f 85 f5 00 00 00    	jne    80babb <netconn_recv+0x14f>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80b9c6:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80b9ca:	75 0e                	jne    80b9da <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80b9cc:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  80b9d0:	b8 00 00 00 00       	mov    $0x0,%eax
  80b9d5:	e9 31 01 00 00       	jmp    80bb0b <netconn_recv+0x19f>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80b9da:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80b9e1:	e8 2c 90 ff ff       	call   804a12 <memp_malloc>
  80b9e6:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80b9e9:	85 c0                	test   %eax,%eax
  80b9eb:	75 09                	jne    80b9f6 <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  80b9ed:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80b9f1:	e9 15 01 00 00       	jmp    80bb0b <netconn_recv+0x19f>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80b9f6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b9fd:	00 
  80b9fe:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80ba01:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ba05:	8b 43 14             	mov    0x14(%ebx),%eax
  80ba08:	89 04 24             	mov    %eax,(%esp)
  80ba0b:	e8 b8 f1 ff ff       	call   80abc8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80ba10:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ba13:	85 c0                	test   %eax,%eax
  80ba15:	74 0a                	je     80ba21 <netconn_recv+0xb5>
      len = p->tot_len;
  80ba17:	0f b7 50 08          	movzwl 0x8(%eax),%edx
      SYS_ARCH_DEC(conn->recv_avail, len);
  80ba1b:	66 29 53 20          	sub    %dx,0x20(%ebx)
  80ba1f:	eb 05                	jmp    80ba26 <netconn_recv+0xba>
    } else {
      len = 0;
  80ba21:	ba 00 00 00 00       	mov    $0x0,%edx
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80ba26:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ba29:	85 c0                	test   %eax,%eax
  80ba2b:	74 14                	je     80ba41 <netconn_recv+0xd5>
  80ba2d:	0f b7 d2             	movzwl %dx,%edx
  80ba30:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ba34:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80ba3b:	00 
  80ba3c:	89 1c 24             	mov    %ebx,(%esp)
  80ba3f:	ff d0                	call   *%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80ba41:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ba44:	85 c0                	test   %eax,%eax
  80ba46:	75 2b                	jne    80ba73 <netconn_recv+0x107>
      memp_free(MEMP_NETBUF, buf);
  80ba48:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ba4b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ba4f:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ba56:	e8 17 90 ff ff       	call   804a72 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
        conn->err = ERR_CLSD;
      }
      return NULL;
  80ba5b:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ba60:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ba64:	0f 85 a1 00 00 00    	jne    80bb0b <netconn_recv+0x19f>
        conn->err = ERR_CLSD;
  80ba6a:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80ba6e:	e9 98 00 00 00       	jmp    80bb0b <netconn_recv+0x19f>
      }
      return NULL;
    }

    buf->p = p;
  80ba73:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80ba76:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80ba78:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ba7b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ba7e:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80ba81:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80ba87:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80ba8e:	c7 45 e4 32 cc 80 00 	movl   $0x80cc32,-0x1c(%ebp)
    msg.msg.conn = conn;
  80ba95:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80ba98:	85 c0                	test   %eax,%eax
  80ba9a:	74 0c                	je     80baa8 <netconn_recv+0x13c>
      msg.msg.msg.r.len = buf->p->tot_len;
  80ba9c:	8b 00                	mov    (%eax),%eax
  80ba9e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80baa2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80baa6:	eb 06                	jmp    80baae <netconn_recv+0x142>
    } else {
      msg.msg.msg.r.len = 1;
  80baa8:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80baae:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bab1:	89 04 24             	mov    %eax,(%esp)
  80bab4:	e8 a2 6c ff ff       	call   80275b <tcpip_apimsg>
  80bab9:	eb 46                	jmp    80bb01 <netconn_recv+0x195>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80babb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bac2:	00 
  80bac3:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80bac6:	89 54 24 04          	mov    %edx,0x4(%esp)
  80baca:	89 04 24             	mov    %eax,(%esp)
  80bacd:	e8 f6 f0 ff ff       	call   80abc8 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80bad2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bad5:	85 c0                	test   %eax,%eax
  80bad7:	74 28                	je     80bb01 <netconn_recv+0x195>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80bad9:	8b 10                	mov    (%eax),%edx
  80badb:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80badf:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80bae3:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80bae6:	85 d2                	test   %edx,%edx
  80bae8:	74 17                	je     80bb01 <netconn_recv+0x195>
  80baea:	8b 00                	mov    (%eax),%eax
  80baec:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80baf0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80baf4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80bafb:	00 
  80bafc:	89 1c 24             	mov    %ebx,(%esp)
  80baff:	ff d2                	call   *%edx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80bb01:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bb04:	eb 05                	jmp    80bb0b <netconn_recv+0x19f>
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  80bb06:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
}
  80bb0b:	83 c4 34             	add    $0x34,%esp
  80bb0e:	5b                   	pop    %ebx
  80bb0f:	5d                   	pop    %ebp
  80bb10:	c3                   	ret    

0080bb11 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80bb11:	55                   	push   %ebp
  80bb12:	89 e5                	mov    %esp,%ebp
  80bb14:	53                   	push   %ebx
  80bb15:	83 ec 34             	sub    $0x34,%esp
  80bb18:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bb1b:	85 db                	test   %ebx,%ebx
  80bb1d:	75 1c                	jne    80bb3b <netconn_send+0x2a>
  80bb1f:	c7 44 24 08 fa 3d 81 	movl   $0x813dfa,0x8(%esp)
  80bb26:	00 
  80bb27:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80bb2e:	00 
  80bb2f:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80bb36:	e8 5f 35 00 00       	call   80f09a <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80bb3b:	c7 45 e4 7a cb 80 00 	movl   $0x80cb7a,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bb42:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80bb45:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb48:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80bb4b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bb4e:	89 04 24             	mov    %eax,(%esp)
  80bb51:	e8 05 6c ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80bb56:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bb5a:	83 c4 34             	add    $0x34,%esp
  80bb5d:	5b                   	pop    %ebx
  80bb5e:	5d                   	pop    %ebp
  80bb5f:	c3                   	ret    

0080bb60 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80bb60:	55                   	push   %ebp
  80bb61:	89 e5                	mov    %esp,%ebp
  80bb63:	83 ec 18             	sub    $0x18,%esp
  80bb66:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bb69:	8b 55 14             	mov    0x14(%ebp),%edx
  if (buf != NULL) {
  80bb6c:	85 c0                	test   %eax,%eax
  80bb6e:	74 1b                	je     80bb8b <netconn_sendto+0x2b>
    buf->addr = addr;
  80bb70:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80bb73:	89 48 08             	mov    %ecx,0x8(%eax)
    buf->port = port;
  80bb76:	66 89 50 0c          	mov    %dx,0xc(%eax)
    return netconn_send(conn, buf);
  80bb7a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb7e:	8b 45 08             	mov    0x8(%ebp),%eax
  80bb81:	89 04 24             	mov    %eax,(%esp)
  80bb84:	e8 88 ff ff ff       	call   80bb11 <netconn_send>
  80bb89:	eb 05                	jmp    80bb90 <netconn_sendto+0x30>
  }
  return ERR_VAL;
  80bb8b:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
}
  80bb90:	c9                   	leave  
  80bb91:	c3                   	ret    

0080bb92 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80bb92:	55                   	push   %ebp
  80bb93:	89 e5                	mov    %esp,%ebp
  80bb95:	53                   	push   %ebx
  80bb96:	83 ec 34             	sub    $0x34,%esp
  80bb99:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bb9c:	8b 45 14             	mov    0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bb9f:	85 db                	test   %ebx,%ebx
  80bba1:	75 1c                	jne    80bbbf <netconn_write+0x2d>
  80bba3:	c7 44 24 08 15 3e 81 	movl   $0x813e15,0x8(%esp)
  80bbaa:	00 
  80bbab:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80bbb2:	00 
  80bbb3:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80bbba:	e8 db 34 00 00       	call   80f09a <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80bbbf:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bbc2:	74 1c                	je     80bbe0 <netconn_write+0x4e>
  80bbc4:	c7 44 24 08 90 3c 81 	movl   $0x813c90,0x8(%esp)
  80bbcb:	00 
  80bbcc:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80bbd3:	00 
  80bbd4:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80bbdb:	e8 ba 34 00 00       	call   80f09a <_panic>

  msg.function = do_write;
  80bbe0:	c7 45 e4 73 cc 80 00 	movl   $0x80cc73,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bbe7:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80bbea:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bbed:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80bbf0:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80bbf3:	8b 45 10             	mov    0x10(%ebp),%eax
  80bbf6:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80bbf9:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bbfc:	89 04 24             	mov    %eax,(%esp)
  80bbff:	e8 57 6b ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80bc04:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bc08:	83 c4 34             	add    $0x34,%esp
  80bc0b:	5b                   	pop    %ebx
  80bc0c:	5d                   	pop    %ebp
  80bc0d:	c3                   	ret    

0080bc0e <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80bc0e:	55                   	push   %ebp
  80bc0f:	89 e5                	mov    %esp,%ebp
  80bc11:	53                   	push   %ebx
  80bc12:	83 ec 34             	sub    $0x34,%esp
  80bc15:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80bc18:	85 db                	test   %ebx,%ebx
  80bc1a:	75 1c                	jne    80bc38 <netconn_close+0x2a>
  80bc1c:	c7 44 24 08 31 3e 81 	movl   $0x813e31,0x8(%esp)
  80bc23:	00 
  80bc24:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80bc2b:	00 
  80bc2c:	c7 04 24 b2 3c 81 00 	movl   $0x813cb2,(%esp)
  80bc33:	e8 62 34 00 00       	call   80f09a <_panic>

  msg.function = do_close;
  80bc38:	c7 45 e4 81 cd 80 00 	movl   $0x80cd81,-0x1c(%ebp)
  msg.msg.conn = conn;
  80bc3f:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80bc42:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80bc45:	89 04 24             	mov    %eax,(%esp)
  80bc48:	e8 0e 6b ff ff       	call   80275b <tcpip_apimsg>
  return conn->err;
  80bc4d:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
}
  80bc51:	83 c4 34             	add    $0x34,%esp
  80bc54:	5b                   	pop    %ebx
  80bc55:	5d                   	pop    %ebp
  80bc56:	c3                   	ret    
  80bc57:	66 90                	xchg   %ax,%ax
  80bc59:	66 90                	xchg   %ax,%ax
  80bc5b:	66 90                	xchg   %ax,%ax
  80bc5d:	66 90                	xchg   %ax,%ax
  80bc5f:	90                   	nop

0080bc60 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80bc60:	55                   	push   %ebp
  80bc61:	89 e5                	mov    %esp,%ebp
  80bc63:	56                   	push   %esi
  80bc64:	53                   	push   %ebx
  80bc65:	83 ec 10             	sub    $0x10,%esp
  80bc68:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bc6b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bc6e:	8b 75 10             	mov    0x10(%ebp),%esi
  80bc71:	8b 55 14             	mov    0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80bc74:	85 c0                	test   %eax,%eax
  80bc76:	75 1c                	jne    80bc94 <recv_tcp+0x34>
  80bc78:	c7 44 24 08 50 3e 81 	movl   $0x813e50,0x8(%esp)
  80bc7f:	00 
  80bc80:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80bc87:	00 
  80bc88:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bc8f:	e8 06 34 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80bc94:	85 db                	test   %ebx,%ebx
  80bc96:	75 1c                	jne    80bcb4 <recv_tcp+0x54>
  80bc98:	c7 44 24 08 74 3e 81 	movl   $0x813e74,0x8(%esp)
  80bc9f:	00 
  80bca0:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80bca7:	00 
  80bca8:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bcaf:	e8 e6 33 00 00       	call   80f09a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80bcb4:	39 43 08             	cmp    %eax,0x8(%ebx)
  80bcb7:	74 1c                	je     80bcd5 <recv_tcp+0x75>
  80bcb9:	c7 44 24 08 b1 3f 81 	movl   $0x813fb1,0x8(%esp)
  80bcc0:	00 
  80bcc1:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80bcc8:	00 
  80bcc9:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bcd0:	e8 c5 33 00 00       	call   80f09a <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80bcd5:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bcd9:	74 49                	je     80bd24 <recv_tcp+0xc4>
    return ERR_VAL;
  }

  conn->err = err;
  80bcdb:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80bcde:	85 f6                	test   %esi,%esi
  80bce0:	74 0a                	je     80bcec <recv_tcp+0x8c>
    len = p->tot_len;
  80bce2:	0f b7 56 08          	movzwl 0x8(%esi),%edx
    SYS_ARCH_INC(conn->recv_avail, len);
  80bce6:	66 01 53 20          	add    %dx,0x20(%ebx)
  80bcea:	eb 05                	jmp    80bcf1 <recv_tcp+0x91>
  } else {
    len = 0;
  80bcec:	ba 00 00 00 00       	mov    $0x0,%edx
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80bcf1:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bcf4:	85 c0                	test   %eax,%eax
  80bcf6:	74 14                	je     80bd0c <recv_tcp+0xac>
  80bcf8:	0f b7 d2             	movzwl %dx,%edx
  80bcfb:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bcff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bd06:	00 
  80bd07:	89 1c 24             	mov    %ebx,(%esp)
  80bd0a:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80bd0c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80bd10:	8b 43 14             	mov    0x14(%ebx),%eax
  80bd13:	89 04 24             	mov    %eax,(%esp)
  80bd16:	e8 a1 ed ff ff       	call   80aabc <sys_mbox_trypost>
  80bd1b:	84 c0                	test   %al,%al
  80bd1d:	0f 95 c0             	setne  %al
    return ERR_MEM;
  80bd20:	f7 d8                	neg    %eax
  80bd22:	eb 05                	jmp    80bd29 <recv_tcp+0xc9>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  80bd24:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
    return ERR_MEM;
  }

  return ERR_OK;
}
  80bd29:	83 c4 10             	add    $0x10,%esp
  80bd2c:	5b                   	pop    %ebx
  80bd2d:	5e                   	pop    %esi
  80bd2e:	5d                   	pop    %ebp
  80bd2f:	c3                   	ret    

0080bd30 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80bd30:	55                   	push   %ebp
  80bd31:	89 e5                	mov    %esp,%ebp
  80bd33:	57                   	push   %edi
  80bd34:	56                   	push   %esi
  80bd35:	53                   	push   %ebx
  80bd36:	83 ec 1c             	sub    $0x1c,%esp
  80bd39:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bd3c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd3f:	8b 7d 10             	mov    0x10(%ebp),%edi
  80bd42:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80bd45:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80bd48:	85 c0                	test   %eax,%eax
  80bd4a:	75 1c                	jne    80bd68 <recv_udp+0x38>
  80bd4c:	c7 44 24 08 94 3e 81 	movl   $0x813e94,0x8(%esp)
  80bd53:	00 
  80bd54:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80bd5b:	00 
  80bd5c:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bd63:	e8 32 33 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80bd68:	85 db                	test   %ebx,%ebx
  80bd6a:	75 1c                	jne    80bd88 <recv_udp+0x58>
  80bd6c:	c7 44 24 08 b8 3e 81 	movl   $0x813eb8,0x8(%esp)
  80bd73:	00 
  80bd74:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80bd7b:	00 
  80bd7c:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bd83:	e8 12 33 00 00       	call   80f09a <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80bd88:	39 43 08             	cmp    %eax,0x8(%ebx)
  80bd8b:	74 1c                	je     80bda9 <recv_udp+0x79>
  80bd8d:	c7 44 24 08 cf 3f 81 	movl   $0x813fcf,0x8(%esp)
  80bd94:	00 
  80bd95:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80bd9c:	00 
  80bd9d:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bda4:	e8 f1 32 00 00       	call   80f09a <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80bda9:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80bdad:	75 0a                	jne    80bdb9 <recv_udp+0x89>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80bdaf:	89 3c 24             	mov    %edi,(%esp)
  80bdb2:	e8 6d 90 ff ff       	call   804e24 <pbuf_free>
    return;
  80bdb7:	eb 6e                	jmp    80be27 <recv_udp+0xf7>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80bdb9:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80bdc0:	e8 4d 8c ff ff       	call   804a12 <memp_malloc>
  80bdc5:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80bdc7:	85 c0                	test   %eax,%eax
  80bdc9:	75 0a                	jne    80bdd5 <recv_udp+0xa5>
    pbuf_free(p);
  80bdcb:	89 3c 24             	mov    %edi,(%esp)
  80bdce:	e8 51 90 ff ff       	call   804e24 <pbuf_free>
    return;
  80bdd3:	eb 52                	jmp    80be27 <recv_udp+0xf7>
  } else {
    buf->p = p;
  80bdd5:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80bdd7:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80bdda:	8b 45 14             	mov    0x14(%ebp),%eax
  80bddd:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80bde0:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80bde4:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80bde8:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80bdec:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80bdf0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bdf3:	85 c0                	test   %eax,%eax
  80bdf5:	74 15                	je     80be0c <recv_udp+0xdc>
  80bdf7:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80bdfb:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bdff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80be06:	00 
  80be07:	89 1c 24             	mov    %ebx,(%esp)
  80be0a:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80be0c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80be10:	8b 43 14             	mov    0x14(%ebx),%eax
  80be13:	89 04 24             	mov    %eax,(%esp)
  80be16:	e8 a1 ec ff ff       	call   80aabc <sys_mbox_trypost>
  80be1b:	84 c0                	test   %al,%al
  80be1d:	74 08                	je     80be27 <recv_udp+0xf7>
    netbuf_delete(buf);
  80be1f:	89 34 24             	mov    %esi,(%esp)
  80be22:	e8 55 6a ff ff       	call   80287c <netbuf_delete>
    return;
  }
}
  80be27:	83 c4 1c             	add    $0x1c,%esp
  80be2a:	5b                   	pop    %ebx
  80be2b:	5e                   	pop    %esi
  80be2c:	5f                   	pop    %edi
  80be2d:	5d                   	pop    %ebp
  80be2e:	c3                   	ret    

0080be2f <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80be2f:	55                   	push   %ebp
  80be30:	89 e5                	mov    %esp,%ebp
  80be32:	57                   	push   %edi
  80be33:	56                   	push   %esi
  80be34:	53                   	push   %ebx
  80be35:	83 ec 1c             	sub    $0x1c,%esp
  80be38:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80be3b:	85 db                	test   %ebx,%ebx
  80be3d:	0f 84 cd 00 00 00    	je     80bf10 <recv_raw+0xe1>
  80be43:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80be47:	0f 84 c3 00 00 00    	je     80bf10 <recv_raw+0xe1>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80be4d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80be54:	00 
  80be55:	8b 45 10             	mov    0x10(%ebp),%eax
  80be58:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80be5c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be60:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80be67:	e8 99 90 ff ff       	call   804f05 <pbuf_alloc>
  80be6c:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80be6e:	85 c0                	test   %eax,%eax
  80be70:	0f 84 9a 00 00 00    	je     80bf10 <recv_raw+0xe1>
      if (pbuf_copy(q, p) != ERR_OK) {
  80be76:	8b 45 10             	mov    0x10(%ebp),%eax
  80be79:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be7d:	89 34 24             	mov    %esi,(%esp)
  80be80:	e8 af 95 ff ff       	call   805434 <pbuf_copy>
  80be85:	84 c0                	test   %al,%al
  80be87:	74 73                	je     80befc <recv_raw+0xcd>
        pbuf_free(q);
  80be89:	89 34 24             	mov    %esi,(%esp)
  80be8c:	e8 93 8f ff ff       	call   804e24 <pbuf_free>
  80be91:	eb 7d                	jmp    80bf10 <recv_raw+0xe1>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80be93:	89 34 24             	mov    %esi,(%esp)
  80be96:	e8 89 8f ff ff       	call   804e24 <pbuf_free>
        return 0;
  80be9b:	90                   	nop
  80be9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80bea0:	eb 6e                	jmp    80bf10 <recv_raw+0xe1>
      }

      buf->p = q;
  80bea2:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80bea4:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80bea7:	8b 46 04             	mov    0x4(%esi),%eax
  80beaa:	83 c0 0c             	add    $0xc,%eax
  80bead:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80beb0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80beb3:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80beb7:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80bebb:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80bebf:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80bec3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80bec6:	85 c0                	test   %eax,%eax
  80bec8:	74 15                	je     80bedf <recv_raw+0xb0>
  80beca:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80bece:	89 54 24 08          	mov    %edx,0x8(%esp)
  80bed2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bed9:	00 
  80beda:	89 1c 24             	mov    %ebx,(%esp)
  80bedd:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80bedf:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bee3:	8b 43 14             	mov    0x14(%ebx),%eax
  80bee6:	89 04 24             	mov    %eax,(%esp)
  80bee9:	e8 ce eb ff ff       	call   80aabc <sys_mbox_trypost>
  80beee:	84 c0                	test   %al,%al
  80bef0:	74 1e                	je     80bf10 <recv_raw+0xe1>
        netbuf_delete(buf);
  80bef2:	89 3c 24             	mov    %edi,(%esp)
  80bef5:	e8 82 69 ff ff       	call   80287c <netbuf_delete>
  80befa:	eb 14                	jmp    80bf10 <recv_raw+0xe1>
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80befc:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80bf03:	e8 0a 8b ff ff       	call   804a12 <memp_malloc>
  80bf08:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80bf0a:	85 c0                	test   %eax,%eax
  80bf0c:	75 94                	jne    80bea2 <recv_raw+0x73>
  80bf0e:	eb 83                	jmp    80be93 <recv_raw+0x64>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80bf10:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf15:	83 c4 1c             	add    $0x1c,%esp
  80bf18:	5b                   	pop    %ebx
  80bf19:	5e                   	pop    %esi
  80bf1a:	5f                   	pop    %edi
  80bf1b:	5d                   	pop    %ebp
  80bf1c:	c3                   	ret    

0080bf1d <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80bf1d:	55                   	push   %ebp
  80bf1e:	89 e5                	mov    %esp,%ebp
  80bf20:	53                   	push   %ebx
  80bf21:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80bf24:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80bf27:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bf2b:	89 1c 24             	mov    %ebx,(%esp)
  80bf2e:	e8 89 9f ff ff       	call   805ebc <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80bf33:	c7 44 24 04 60 bc 80 	movl   $0x80bc60,0x4(%esp)
  80bf3a:	00 
  80bf3b:	89 1c 24             	mov    %ebx,(%esp)
  80bf3e:	e8 87 9f ff ff       	call   805eca <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80bf43:	c7 44 24 04 4c c4 80 	movl   $0x80c44c,0x4(%esp)
  80bf4a:	00 
  80bf4b:	89 1c 24             	mov    %ebx,(%esp)
  80bf4e:	e8 88 9f ff ff       	call   805edb <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80bf53:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80bf5a:	00 
  80bf5b:	c7 44 24 04 fe c3 80 	movl   $0x80c3fe,0x4(%esp)
  80bf62:	00 
  80bf63:	89 1c 24             	mov    %ebx,(%esp)
  80bf66:	e8 a0 9f ff ff       	call   805f0b <tcp_poll>
  tcp_err(pcb, err_tcp);
  80bf6b:	c7 44 24 04 c9 bf 80 	movl   $0x80bfc9,0x4(%esp)
  80bf72:	00 
  80bf73:	89 1c 24             	mov    %ebx,(%esp)
  80bf76:	e8 71 9f ff ff       	call   805eec <tcp_err>
}
  80bf7b:	83 c4 14             	add    $0x14,%esp
  80bf7e:	5b                   	pop    %ebx
  80bf7f:	5d                   	pop    %ebp
  80bf80:	c3                   	ret    

0080bf81 <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80bf81:	55                   	push   %ebp
  80bf82:	89 e5                	mov    %esp,%ebp
  80bf84:	53                   	push   %ebx
  80bf85:	83 ec 14             	sub    $0x14,%esp
  80bf88:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bf8b:	8b 45 10             	mov    0x10(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
  80bf8e:	85 db                	test   %ebx,%ebx
  80bf90:	74 2c                	je     80bfbe <do_connected+0x3d>
    return ERR_VAL;
  }

  conn->err = err;
  80bf92:	88 43 0c             	mov    %al,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80bf95:	83 3b 10             	cmpl   $0x10,(%ebx)
  80bf98:	75 0b                	jne    80bfa5 <do_connected+0x24>
  80bf9a:	84 c0                	test   %al,%al
  80bf9c:	75 07                	jne    80bfa5 <do_connected+0x24>
    setup_tcp(conn);
  80bf9e:	89 d8                	mov    %ebx,%eax
  80bfa0:	e8 78 ff ff ff       	call   80bf1d <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80bfa5:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80bfac:	8b 43 10             	mov    0x10(%ebx),%eax
  80bfaf:	89 04 24             	mov    %eax,(%esp)
  80bfb2:	e8 79 e9 ff ff       	call   80a930 <sys_sem_signal>
  return ERR_OK;
  80bfb7:	b8 00 00 00 00       	mov    $0x0,%eax
  80bfbc:	eb 05                	jmp    80bfc3 <do_connected+0x42>
  LWIP_UNUSED_ARG(pcb);

  conn = arg;

  if (conn == NULL) {
    return ERR_VAL;
  80bfbe:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    setup_tcp(conn);
  }
  conn->state = NETCONN_NONE;
  sys_sem_signal(conn->op_completed);
  return ERR_OK;
}
  80bfc3:	83 c4 14             	add    $0x14,%esp
  80bfc6:	5b                   	pop    %ebx
  80bfc7:	5d                   	pop    %ebp
  80bfc8:	c3                   	ret    

0080bfc9 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80bfc9:	55                   	push   %ebp
  80bfca:	89 e5                	mov    %esp,%ebp
  80bfcc:	53                   	push   %ebx
  80bfcd:	83 ec 14             	sub    $0x14,%esp
  80bfd0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bfd3:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80bfd6:	85 db                	test   %ebx,%ebx
  80bfd8:	75 1c                	jne    80bff6 <err_tcp+0x2d>
  80bfda:	c7 44 24 08 ed 3f 81 	movl   $0x813fed,0x8(%esp)
  80bfe1:	00 
  80bfe2:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80bfe9:	00 
  80bfea:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80bff1:	e8 a4 30 00 00       	call   80f09a <_panic>

  conn->pcb.tcp = NULL;
  80bff6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80bffd:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c000:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c004:	74 2f                	je     80c035 <err_tcp+0x6c>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c006:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c009:	85 c0                	test   %eax,%eax
  80c00b:	74 15                	je     80c022 <err_tcp+0x59>
  80c00d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c014:	00 
  80c015:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c01c:	00 
  80c01d:	89 1c 24             	mov    %ebx,(%esp)
  80c020:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80c022:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c029:	00 
  80c02a:	8b 43 14             	mov    0x14(%ebx),%eax
  80c02d:	89 04 24             	mov    %eax,(%esp)
  80c030:	e8 51 eb ff ff       	call   80ab86 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80c035:	8b 43 10             	mov    0x10(%ebx),%eax
  80c038:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c03b:	74 15                	je     80c052 <err_tcp+0x89>
  80c03d:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80c041:	75 0f                	jne    80c052 <err_tcp+0x89>
    conn->state = NETCONN_NONE;
  80c043:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80c04a:	89 04 24             	mov    %eax,(%esp)
  80c04d:	e8 de e8 ff ff       	call   80a930 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c052:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c056:	74 2f                	je     80c087 <err_tcp+0xbe>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c058:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c05b:	85 c0                	test   %eax,%eax
  80c05d:	74 15                	je     80c074 <err_tcp+0xab>
  80c05f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c066:	00 
  80c067:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c06e:	00 
  80c06f:	89 1c 24             	mov    %ebx,(%esp)
  80c072:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80c074:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c07b:	00 
  80c07c:	8b 43 18             	mov    0x18(%ebx),%eax
  80c07f:	89 04 24             	mov    %eax,(%esp)
  80c082:	e8 ff ea ff ff       	call   80ab86 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80c087:	8b 43 04             	mov    0x4(%ebx),%eax
  80c08a:	83 f8 04             	cmp    $0x4,%eax
  80c08d:	74 05                	je     80c094 <err_tcp+0xcb>
  80c08f:	83 f8 01             	cmp    $0x1,%eax
  80c092:	75 12                	jne    80c0a6 <err_tcp+0xdd>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80c094:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80c09b:	8b 43 10             	mov    0x10(%ebx),%eax
  80c09e:	89 04 24             	mov    %eax,(%esp)
  80c0a1:	e8 8a e8 ff ff       	call   80a930 <sys_sem_signal>
  }
}
  80c0a6:	83 c4 14             	add    $0x14,%esp
  80c0a9:	5b                   	pop    %ebx
  80c0aa:	5d                   	pop    %ebp
  80c0ab:	c3                   	ret    

0080c0ac <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80c0ac:	55                   	push   %ebp
  80c0ad:	89 e5                	mov    %esp,%ebp
  80c0af:	57                   	push   %edi
  80c0b0:	56                   	push   %esi
  80c0b1:	53                   	push   %ebx
  80c0b2:	83 ec 1c             	sub    $0x1c,%esp
  80c0b5:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80c0b7:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80c0bb:	74 1c                	je     80c0d9 <do_writemore+0x2d>
  80c0bd:	c7 44 24 08 fa 3f 81 	movl   $0x813ffa,0x8(%esp)
  80c0c4:	00 
  80c0c5:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80c0cc:	00 
  80c0cd:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c0d4:	e8 c1 2f 00 00       	call   80f09a <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80c0d9:	8b 40 24             	mov    0x24(%eax),%eax
  80c0dc:	8b 53 28             	mov    0x28(%ebx),%edx
  80c0df:	89 d1                	mov    %edx,%ecx
  80c0e1:	03 48 04             	add    0x4(%eax),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80c0e4:	8b 78 08             	mov    0x8(%eax),%edi
  80c0e7:	89 fe                	mov    %edi,%esi
  80c0e9:	29 d6                	sub    %edx,%esi
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  80c0eb:	29 d7                	sub    %edx,%edi
  80c0ed:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  80c0f3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80c0f8:	0f 4f fa             	cmovg  %edx,%edi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80c0fb:	8b 53 08             	mov    0x8(%ebx),%edx
  80c0fe:	0f b7 72 6e          	movzwl 0x6e(%edx),%esi
  80c102:	66 39 f7             	cmp    %si,%di
  80c105:	0f 46 f7             	cmovbe %edi,%esi
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80c108:	0f b7 f6             	movzwl %si,%esi
  80c10b:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  80c10f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c113:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c117:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c11b:	89 14 24             	mov    %edx,(%esp)
  80c11e:	e8 02 c6 ff ff       	call   808725 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80c123:	89 f2                	mov    %esi,%edx
  80c125:	03 53 28             	add    0x28(%ebx),%edx
  80c128:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80c12b:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c12e:	7e 1c                	jle    80c14c <do_writemore+0xa0>
  80c130:	c7 44 24 08 17 40 81 	movl   $0x814017,0x8(%esp)
  80c137:	00 
  80c138:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80c13f:	00 
  80c140:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c147:	e8 4e 2f 00 00       	call   80f09a <_panic>
  if (err == ERR_OK) {
  80c14c:	84 c0                	test   %al,%al
  80c14e:	75 6f                	jne    80c1bf <do_writemore+0x113>
    conn->write_offset += len;
  80c150:	89 53 28             	mov    %edx,0x28(%ebx)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  80c153:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80c158:	3b 51 08             	cmp    0x8(%ecx),%edx
  80c15b:	75 13                	jne    80c170 <do_writemore+0xc4>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80c15d:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80c164:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  80c16b:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80c170:	8b 43 08             	mov    0x8(%ebx),%eax
  80c173:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80c177:	74 12                	je     80c18b <do_writemore+0xdf>
  80c179:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80c17d:	75 0c                	jne    80c18b <do_writemore+0xdf>
  80c17f:	8b 50 74             	mov    0x74(%eax),%edx
  80c182:	85 d2                	test   %edx,%edx
  80c184:	74 69                	je     80c1ef <do_writemore+0x143>
  80c186:	83 3a 00             	cmpl   $0x0,(%edx)
  80c189:	74 64                	je     80c1ef <do_writemore+0x143>
  80c18b:	89 04 24             	mov    %eax,(%esp)
  80c18e:	e8 fe c5 ff ff       	call   808791 <tcp_output>
    conn->err = err;
  80c193:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80c196:	84 c0                	test   %al,%al
  80c198:	75 3b                	jne    80c1d5 <do_writemore+0x129>
  80c19a:	8b 43 08             	mov    0x8(%ebx),%eax
  80c19d:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c1a3:	77 30                	ja     80c1d5 <do_writemore+0x129>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80c1a5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c1a8:	85 c0                	test   %eax,%eax
  80c1aa:	74 29                	je     80c1d5 <do_writemore+0x129>
  80c1ac:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c1b0:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c1b7:	00 
  80c1b8:	89 1c 24             	mov    %ebx,(%esp)
  80c1bb:	ff d0                	call   *%eax
  80c1bd:	eb 16                	jmp    80c1d5 <do_writemore+0x129>
    }
  } else if (err == ERR_MEM) {
  80c1bf:	3c ff                	cmp    $0xff,%al
  80c1c1:	75 0d                	jne    80c1d0 <do_writemore+0x124>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80c1c3:	8b 43 08             	mov    0x8(%ebx),%eax
  80c1c6:	89 04 24             	mov    %eax,(%esp)
  80c1c9:	e8 c3 c5 ff ff       	call   808791 <tcp_output>
  80c1ce:	eb 25                	jmp    80c1f5 <do_writemore+0x149>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80c1d0:	88 43 0c             	mov    %al,0xc(%ebx)
  80c1d3:	eb 06                	jmp    80c1db <do_writemore+0x12f>
    write_finished = 1;
  }

  if (write_finished) {
  80c1d5:	89 f8                	mov    %edi,%eax
  80c1d7:	84 c0                	test   %al,%al
  80c1d9:	74 1a                	je     80c1f5 <do_writemore+0x149>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80c1db:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80c1e2:	8b 43 10             	mov    0x10(%ebx),%eax
  80c1e5:	89 04 24             	mov    %eax,(%esp)
  80c1e8:	e8 43 e7 ff ff       	call   80a930 <sys_sem_signal>
  80c1ed:	eb 06                	jmp    80c1f5 <do_writemore+0x149>
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80c1ef:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80c1f3:	eb a5                	jmp    80c19a <do_writemore+0xee>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80c1f5:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1fa:	83 c4 1c             	add    $0x1c,%esp
  80c1fd:	5b                   	pop    %ebx
  80c1fe:	5e                   	pop    %esi
  80c1ff:	5f                   	pop    %edi
  80c200:	5d                   	pop    %ebp
  80c201:	c3                   	ret    

0080c202 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80c202:	55                   	push   %ebp
  80c203:	89 e5                	mov    %esp,%ebp
  80c205:	53                   	push   %ebx
  80c206:	83 ec 14             	sub    $0x14,%esp
  80c209:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80c20b:	85 c0                	test   %eax,%eax
  80c20d:	75 1c                	jne    80c22b <do_close_internal+0x29>
  80c20f:	c7 44 24 08 08 3e 81 	movl   $0x813e08,0x8(%esp)
  80c216:	00 
  80c217:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80c21e:	00 
  80c21f:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c226:	e8 6f 2e 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80c22b:	83 38 10             	cmpl   $0x10,(%eax)
  80c22e:	74 1c                	je     80c24c <do_close_internal+0x4a>
  80c230:	c7 44 24 08 35 40 81 	movl   $0x814035,0x8(%esp)
  80c237:	00 
  80c238:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80c23f:	00 
  80c240:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c247:	e8 4e 2e 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80c24c:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80c250:	74 1c                	je     80c26e <do_close_internal+0x6c>
  80c252:	c7 44 24 08 d8 3e 81 	movl   $0x813ed8,0x8(%esp)
  80c259:	00 
  80c25a:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80c261:	00 
  80c262:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c269:	e8 2c 2e 00 00       	call   80f09a <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80c26e:	8b 40 08             	mov    0x8(%eax),%eax
  80c271:	85 c0                	test   %eax,%eax
  80c273:	75 1c                	jne    80c291 <do_close_internal+0x8f>
  80c275:	c7 44 24 08 53 40 81 	movl   $0x814053,0x8(%esp)
  80c27c:	00 
  80c27d:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80c284:	00 
  80c285:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c28c:	e8 09 2e 00 00       	call   80f09a <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80c291:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c298:	00 
  80c299:	89 04 24             	mov    %eax,(%esp)
  80c29c:	e8 1b 9c ff ff       	call   805ebc <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80c2a1:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2a4:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80c2a8:	75 12                	jne    80c2bc <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80c2aa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2b1:	00 
  80c2b2:	89 04 24             	mov    %eax,(%esp)
  80c2b5:	e8 43 9c ff ff       	call   805efd <tcp_accept>
  80c2ba:	eb 64                	jmp    80c320 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80c2bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2c3:	00 
  80c2c4:	89 04 24             	mov    %eax,(%esp)
  80c2c7:	e8 fe 9b ff ff       	call   805eca <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80c2cc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2d3:	00 
  80c2d4:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2d7:	89 04 24             	mov    %eax,(%esp)
  80c2da:	e8 1e 9c ff ff       	call   805efd <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80c2df:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c2e6:	00 
  80c2e7:	8b 43 08             	mov    0x8(%ebx),%eax
  80c2ea:	89 04 24             	mov    %eax,(%esp)
  80c2ed:	e8 e9 9b ff ff       	call   805edb <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80c2f2:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c2f9:	00 
  80c2fa:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c301:	00 
  80c302:	8b 43 08             	mov    0x8(%ebx),%eax
  80c305:	89 04 24             	mov    %eax,(%esp)
  80c308:	e8 fe 9b ff ff       	call   805f0b <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80c30d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c314:	00 
  80c315:	8b 43 08             	mov    0x8(%ebx),%eax
  80c318:	89 04 24             	mov    %eax,(%esp)
  80c31b:	e8 cc 9b ff ff       	call   805eec <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80c320:	8b 43 08             	mov    0x8(%ebx),%eax
  80c323:	89 04 24             	mov    %eax,(%esp)
  80c326:	e8 5e 9d ff ff       	call   806089 <tcp_close>
  if (err == ERR_OK) {
  80c32b:	84 c0                	test   %al,%al
  80c32d:	75 57                	jne    80c386 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80c32f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80c336:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80c33d:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c341:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c344:	85 c0                	test   %eax,%eax
  80c346:	74 31                	je     80c379 <do_close_internal+0x177>
  80c348:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c34f:	00 
  80c350:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c357:	00 
  80c358:	89 1c 24             	mov    %ebx,(%esp)
  80c35b:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80c35d:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c360:	85 c0                	test   %eax,%eax
  80c362:	74 15                	je     80c379 <do_close_internal+0x177>
  80c364:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c36b:	00 
  80c36c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c373:	00 
  80c374:	89 1c 24             	mov    %ebx,(%esp)
  80c377:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80c379:	8b 43 10             	mov    0x10(%ebx),%eax
  80c37c:	89 04 24             	mov    %eax,(%esp)
  80c37f:	e8 ac e5 ff ff       	call   80a930 <sys_sem_signal>
  80c384:	eb 72                	jmp    80c3f8 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80c386:	8b 43 08             	mov    0x8(%ebx),%eax
  80c389:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80c38d:	75 1c                	jne    80c3ab <do_close_internal+0x1a9>
  80c38f:	c7 44 24 08 fc 3e 81 	movl   $0x813efc,0x8(%esp)
  80c396:	00 
  80c397:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80c39e:	00 
  80c39f:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c3a6:	e8 ef 2c 00 00       	call   80f09a <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80c3ab:	c7 44 24 04 4c c4 80 	movl   $0x80c44c,0x4(%esp)
  80c3b2:	00 
  80c3b3:	89 04 24             	mov    %eax,(%esp)
  80c3b6:	e8 20 9b ff ff       	call   805edb <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80c3bb:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80c3c2:	00 
  80c3c3:	c7 44 24 04 fe c3 80 	movl   $0x80c3fe,0x4(%esp)
  80c3ca:	00 
  80c3cb:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3ce:	89 04 24             	mov    %eax,(%esp)
  80c3d1:	e8 35 9b ff ff       	call   805f0b <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80c3d6:	c7 44 24 04 c9 bf 80 	movl   $0x80bfc9,0x4(%esp)
  80c3dd:	00 
  80c3de:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3e1:	89 04 24             	mov    %eax,(%esp)
  80c3e4:	e8 03 9b ff ff       	call   805eec <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80c3e9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c3ed:	8b 43 08             	mov    0x8(%ebx),%eax
  80c3f0:	89 04 24             	mov    %eax,(%esp)
  80c3f3:	e8 c4 9a ff ff       	call   805ebc <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80c3f8:	83 c4 14             	add    $0x14,%esp
  80c3fb:	5b                   	pop    %ebx
  80c3fc:	5d                   	pop    %ebp
  80c3fd:	c3                   	ret    

0080c3fe <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80c3fe:	55                   	push   %ebp
  80c3ff:	89 e5                	mov    %esp,%ebp
  80c401:	83 ec 18             	sub    $0x18,%esp
  80c404:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c407:	85 c0                	test   %eax,%eax
  80c409:	75 1c                	jne    80c427 <poll_tcp+0x29>
  80c40b:	c7 44 24 08 ed 3f 81 	movl   $0x813fed,0x8(%esp)
  80c412:	00 
  80c413:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80c41a:	00 
  80c41b:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c422:	e8 73 2c 00 00       	call   80f09a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c427:	8b 50 04             	mov    0x4(%eax),%edx
  80c42a:	83 fa 01             	cmp    $0x1,%edx
  80c42d:	75 07                	jne    80c436 <poll_tcp+0x38>
    do_writemore(conn);
  80c42f:	e8 78 fc ff ff       	call   80c0ac <do_writemore>
  80c434:	eb 0f                	jmp    80c445 <poll_tcp+0x47>
  } else if (conn->state == NETCONN_CLOSE) {
  80c436:	83 fa 04             	cmp    $0x4,%edx
  80c439:	75 0a                	jne    80c445 <poll_tcp+0x47>
    do_close_internal(conn);
  80c43b:	90                   	nop
  80c43c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c440:	e8 bd fd ff ff       	call   80c202 <do_close_internal>
  }

  return ERR_OK;
}
  80c445:	b8 00 00 00 00       	mov    $0x0,%eax
  80c44a:	c9                   	leave  
  80c44b:	c3                   	ret    

0080c44c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80c44c:	55                   	push   %ebp
  80c44d:	89 e5                	mov    %esp,%ebp
  80c44f:	56                   	push   %esi
  80c450:	53                   	push   %ebx
  80c451:	83 ec 10             	sub    $0x10,%esp
  80c454:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c457:	8b 75 10             	mov    0x10(%ebp),%esi
  struct netconn *conn = arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80c45a:	85 db                	test   %ebx,%ebx
  80c45c:	75 1c                	jne    80c47a <sent_tcp+0x2e>
  80c45e:	c7 44 24 08 ed 3f 81 	movl   $0x813fed,0x8(%esp)
  80c465:	00 
  80c466:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80c46d:	00 
  80c46e:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c475:	e8 20 2c 00 00       	call   80f09a <_panic>

  if (conn->state == NETCONN_WRITE) {
  80c47a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c47d:	83 f8 01             	cmp    $0x1,%eax
  80c480:	75 2b                	jne    80c4ad <sent_tcp+0x61>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80c482:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c486:	75 1c                	jne    80c4a4 <sent_tcp+0x58>
  80c488:	c7 44 24 08 66 40 81 	movl   $0x814066,0x8(%esp)
  80c48f:	00 
  80c490:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80c497:	00 
  80c498:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c49f:	e8 f6 2b 00 00       	call   80f09a <_panic>
    do_writemore(conn);
  80c4a4:	89 d8                	mov    %ebx,%eax
  80c4a6:	e8 01 fc ff ff       	call   80c0ac <do_writemore>
  80c4ab:	eb 33                	jmp    80c4e0 <sent_tcp+0x94>
  } else if (conn->state == NETCONN_CLOSE) {
  80c4ad:	83 f8 04             	cmp    $0x4,%eax
  80c4b0:	75 2e                	jne    80c4e0 <sent_tcp+0x94>
    do_close_internal(conn);
  80c4b2:	89 d8                	mov    %ebx,%eax
  80c4b4:	e8 49 fd ff ff       	call   80c202 <do_close_internal>
  80c4b9:	eb 25                	jmp    80c4e0 <sent_tcp+0x94>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c4bb:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80c4c1:	76 24                	jbe    80c4e7 <sent_tcp+0x9b>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80c4c3:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c4c6:	85 c0                	test   %eax,%eax
  80c4c8:	74 1d                	je     80c4e7 <sent_tcp+0x9b>
  80c4ca:	0f b7 f6             	movzwl %si,%esi
  80c4cd:	89 74 24 08          	mov    %esi,0x8(%esp)
  80c4d1:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c4d8:	00 
  80c4d9:	89 1c 24             	mov    %ebx,(%esp)
  80c4dc:	ff d0                	call   *%eax
  80c4de:	eb 07                	jmp    80c4e7 <sent_tcp+0x9b>
  } else if (conn->state == NETCONN_CLOSE) {
    do_close_internal(conn);
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80c4e0:	8b 43 08             	mov    0x8(%ebx),%eax
  80c4e3:	85 c0                	test   %eax,%eax
  80c4e5:	75 d4                	jne    80c4bb <sent_tcp+0x6f>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
    }
  }
  
  return ERR_OK;
}
  80c4e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80c4ec:	83 c4 10             	add    $0x10,%esp
  80c4ef:	5b                   	pop    %ebx
  80c4f0:	5e                   	pop    %esi
  80c4f1:	5d                   	pop    %ebp
  80c4f2:	c3                   	ret    

0080c4f3 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80c4f3:	55                   	push   %ebp
  80c4f4:	89 e5                	mov    %esp,%ebp
  80c4f6:	56                   	push   %esi
  80c4f7:	53                   	push   %ebx
  80c4f8:	83 ec 10             	sub    $0x10,%esp
  80c4fb:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80c4fe:	8b 03                	mov    (%ebx),%eax
  80c500:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c504:	0f 85 dc 00 00 00    	jne    80c5e6 <do_newconn+0xf3>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80c50a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80c50e:	8b 33                	mov    (%ebx),%esi
  80c510:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80c514:	74 1c                	je     80c532 <do_newconn+0x3f>
  80c516:	c7 44 24 08 20 3f 81 	movl   $0x813f20,0x8(%esp)
  80c51d:	00 
  80c51e:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80c525:	00 
  80c526:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c52d:	e8 68 2b 00 00       	call   80f09a <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80c532:	8b 06                	mov    (%esi),%eax
  80c534:	25 f0 00 00 00       	and    $0xf0,%eax
  80c539:	83 f8 20             	cmp    $0x20,%eax
  80c53c:	74 48                	je     80c586 <do_newconn+0x93>
  80c53e:	83 f8 40             	cmp    $0x40,%eax
  80c541:	74 0f                	je     80c552 <do_newconn+0x5f>
  80c543:	83 f8 10             	cmp    $0x10,%eax
  80c546:	0f 85 96 00 00 00    	jne    80c5e2 <do_newconn+0xef>
  80c54c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c550:	eb 6f                	jmp    80c5c1 <do_newconn+0xce>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80c552:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80c556:	89 04 24             	mov    %eax,(%esp)
  80c559:	e8 12 25 00 00       	call   80ea70 <raw_new>
  80c55e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80c561:	8b 03                	mov    (%ebx),%eax
  80c563:	8b 50 08             	mov    0x8(%eax),%edx
  80c566:	85 d2                	test   %edx,%edx
  80c568:	75 06                	jne    80c570 <do_newconn+0x7d>
       msg->conn->err = ERR_MEM;
  80c56a:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c56e:	eb 76                	jmp    80c5e6 <do_newconn+0xf3>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80c570:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c574:	c7 44 24 04 2f be 80 	movl   $0x80be2f,0x4(%esp)
  80c57b:	00 
  80c57c:	89 14 24             	mov    %edx,(%esp)
  80c57f:	e8 47 23 00 00       	call   80e8cb <raw_recv>
  80c584:	eb 60                	jmp    80c5e6 <do_newconn+0xf3>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80c586:	e8 c9 d2 ff ff       	call   809854 <udp_new>
  80c58b:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80c58e:	8b 03                	mov    (%ebx),%eax
  80c590:	8b 50 08             	mov    0x8(%eax),%edx
  80c593:	85 d2                	test   %edx,%edx
  80c595:	75 06                	jne    80c59d <do_newconn+0xaa>
       msg->conn->err = ERR_MEM;
  80c597:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c59b:	eb 49                	jmp    80c5e6 <do_newconn+0xf3>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80c59d:	83 38 22             	cmpl   $0x22,(%eax)
  80c5a0:	75 04                	jne    80c5a6 <do_newconn+0xb3>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80c5a2:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80c5a6:	8b 03                	mov    (%ebx),%eax
  80c5a8:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c5ac:	c7 44 24 04 30 bd 80 	movl   $0x80bd30,0x4(%esp)
  80c5b3:	00 
  80c5b4:	8b 40 08             	mov    0x8(%eax),%eax
  80c5b7:	89 04 24             	mov    %eax,(%esp)
  80c5ba:	e8 3b d2 ff ff       	call   8097fa <udp_recv>
  80c5bf:	eb 25                	jmp    80c5e6 <do_newconn+0xf3>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80c5c1:	e8 3f a3 ff ff       	call   806905 <tcp_new>
  80c5c6:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80c5c9:	8b 03                	mov    (%ebx),%eax
  80c5cb:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80c5cf:	75 06                	jne    80c5d7 <do_newconn+0xe4>
       msg->conn->err = ERR_MEM;
  80c5d1:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80c5d5:	eb 0f                	jmp    80c5e6 <do_newconn+0xf3>
       break;
     }
     setup_tcp(msg->conn);
  80c5d7:	e8 41 f9 ff ff       	call   80bf1d <setup_tcp>
  80c5dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c5e0:	eb 04                	jmp    80c5e6 <do_newconn+0xf3>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80c5e2:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80c5e6:	8b 03                	mov    (%ebx),%eax
  80c5e8:	8b 40 10             	mov    0x10(%eax),%eax
  80c5eb:	89 04 24             	mov    %eax,(%esp)
  80c5ee:	e8 3d e3 ff ff       	call   80a930 <sys_sem_signal>
}
  80c5f3:	83 c4 10             	add    $0x10,%esp
  80c5f6:	5b                   	pop    %ebx
  80c5f7:	5e                   	pop    %esi
  80c5f8:	5d                   	pop    %ebp
  80c5f9:	c3                   	ret    

0080c5fa <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80c5fa:	55                   	push   %ebp
  80c5fb:	89 e5                	mov    %esp,%ebp
  80c5fd:	53                   	push   %ebx
  80c5fe:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80c601:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c608:	e8 05 84 ff ff       	call   804a12 <memp_malloc>
  80c60d:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80c60f:	85 c0                	test   %eax,%eax
  80c611:	0f 84 96 00 00 00    	je     80c6ad <netconn_alloc+0xb3>
    return NULL;
  }

  conn->err = ERR_OK;
  80c617:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80c61b:	8b 45 08             	mov    0x8(%ebp),%eax
  80c61e:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80c620:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80c627:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c62e:	e8 1b e0 ff ff       	call   80a64e <sys_sem_new>
  80c633:	89 43 10             	mov    %eax,0x10(%ebx)
  80c636:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c639:	75 17                	jne    80c652 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80c63b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c63f:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c646:	e8 27 84 ff ff       	call   804a72 <memp_free>
    return NULL;
  80c64b:	b8 00 00 00 00       	mov    $0x0,%eax
  80c650:	eb 60                	jmp    80c6b2 <netconn_alloc+0xb8>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80c652:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c659:	e8 b8 e1 ff ff       	call   80a816 <sys_mbox_new>
  80c65e:	89 43 14             	mov    %eax,0x14(%ebx)
  80c661:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c664:	75 22                	jne    80c688 <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80c666:	8b 43 10             	mov    0x10(%ebx),%eax
  80c669:	89 04 24             	mov    %eax,(%esp)
  80c66c:	e8 66 e0 ff ff       	call   80a6d7 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80c671:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c675:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c67c:	e8 f1 83 ff ff       	call   804a72 <memp_free>
    return NULL;
  80c681:	b8 00 00 00 00       	mov    $0x0,%eax
  80c686:	eb 2a                	jmp    80c6b2 <netconn_alloc+0xb8>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80c688:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80c68f:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80c696:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80c69d:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c6a0:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80c6a3:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
  conn->recv_timeout = 0;
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
  80c6a9:	89 d8                	mov    %ebx,%eax
  80c6ab:	eb 05                	jmp    80c6b2 <netconn_alloc+0xb8>
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  if (conn == NULL) {
    return NULL;
  80c6ad:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80c6b2:	83 c4 14             	add    $0x14,%esp
  80c6b5:	5b                   	pop    %ebx
  80c6b6:	5d                   	pop    %ebp
  80c6b7:	c3                   	ret    

0080c6b8 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80c6b8:	55                   	push   %ebp
  80c6b9:	89 e5                	mov    %esp,%ebp
  80c6bb:	56                   	push   %esi
  80c6bc:	53                   	push   %ebx
  80c6bd:	83 ec 20             	sub    $0x20,%esp
  80c6c0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80c6c3:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80c6c7:	74 1c                	je     80c6e5 <netconn_free+0x2d>
  80c6c9:	c7 44 24 08 40 3f 81 	movl   $0x813f40,0x8(%esp)
  80c6d0:	00 
  80c6d1:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80c6d8:	00 
  80c6d9:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c6e0:	e8 b5 29 00 00       	call   80f09a <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c6e5:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80c6e8:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80c6ec:	75 23                	jne    80c711 <netconn_free+0x59>
  80c6ee:	eb 47                	jmp    80c737 <netconn_free+0x7f>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80c6f0:	83 3b 10             	cmpl   $0x10,(%ebx)
  80c6f3:	75 11                	jne    80c706 <netconn_free+0x4e>
        if(mem != NULL) {
  80c6f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c6f8:	85 c0                	test   %eax,%eax
  80c6fa:	74 15                	je     80c711 <netconn_free+0x59>
          pbuf_free((struct pbuf *)mem);
  80c6fc:	89 04 24             	mov    %eax,(%esp)
  80c6ff:	e8 20 87 ff ff       	call   804e24 <pbuf_free>
  80c704:	eb 0b                	jmp    80c711 <netconn_free+0x59>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80c706:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c709:	89 04 24             	mov    %eax,(%esp)
  80c70c:	e8 6b 61 ff ff       	call   80287c <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80c711:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c715:	8b 43 14             	mov    0x14(%ebx),%eax
  80c718:	89 04 24             	mov    %eax,(%esp)
  80c71b:	e8 a2 e5 ff ff       	call   80acc2 <sys_arch_mbox_tryfetch>
  80c720:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c723:	75 cb                	jne    80c6f0 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80c725:	8b 43 14             	mov    0x14(%ebx),%eax
  80c728:	89 04 24             	mov    %eax,(%esp)
  80c72b:	e8 3b e0 ff ff       	call   80a76b <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80c730:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80c737:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c73b:	74 36                	je     80c773 <netconn_free+0xbb>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c73d:	8d 75 f4             	lea    -0xc(%ebp),%esi
  80c740:	eb 0b                	jmp    80c74d <netconn_free+0x95>
      netconn_delete((struct netconn *)mem);
  80c742:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80c745:	89 04 24             	mov    %eax,(%esp)
  80c748:	e8 52 ef ff ff       	call   80b69f <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80c74d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c751:	8b 43 18             	mov    0x18(%ebx),%eax
  80c754:	89 04 24             	mov    %eax,(%esp)
  80c757:	e8 66 e5 ff ff       	call   80acc2 <sys_arch_mbox_tryfetch>
  80c75c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c75f:	75 e1                	jne    80c742 <netconn_free+0x8a>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80c761:	8b 43 18             	mov    0x18(%ebx),%eax
  80c764:	89 04 24             	mov    %eax,(%esp)
  80c767:	e8 ff df ff ff       	call   80a76b <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80c76c:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80c773:	8b 43 10             	mov    0x10(%ebx),%eax
  80c776:	89 04 24             	mov    %eax,(%esp)
  80c779:	e8 59 df ff ff       	call   80a6d7 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80c77e:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80c785:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c789:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80c790:	e8 dd 82 ff ff       	call   804a72 <memp_free>
}
  80c795:	83 c4 20             	add    $0x20,%esp
  80c798:	5b                   	pop    %ebx
  80c799:	5e                   	pop    %esi
  80c79a:	5d                   	pop    %ebp
  80c79b:	c3                   	ret    

0080c79c <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80c79c:	55                   	push   %ebp
  80c79d:	89 e5                	mov    %esp,%ebp
  80c79f:	57                   	push   %edi
  80c7a0:	56                   	push   %esi
  80c7a1:	53                   	push   %ebx
  80c7a2:	83 ec 1c             	sub    $0x1c,%esp
  80c7a5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c7a8:	8b 7d 10             	mov    0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80c7ab:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80c7af:	75 1c                	jne    80c7cd <accept_function+0x31>
  80c7b1:	c7 44 24 08 70 3f 81 	movl   $0x813f70,0x8(%esp)
  80c7b8:	00 
  80c7b9:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80c7c0:	00 
  80c7c1:	c7 04 24 9a 3f 81 00 	movl   $0x813f9a,(%esp)
  80c7c8:	e8 cd 28 00 00       	call   80f09a <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80c7cd:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c7d0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7d4:	8b 03                	mov    (%ebx),%eax
  80c7d6:	89 04 24             	mov    %eax,(%esp)
  80c7d9:	e8 1c fe ff ff       	call   80c5fa <netconn_alloc>
  80c7de:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80c7e0:	85 c0                	test   %eax,%eax
  80c7e2:	74 57                	je     80c83b <accept_function+0x9f>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80c7e4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c7e7:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80c7ea:	89 f0                	mov    %esi,%eax
  80c7ec:	e8 2c f7 ff ff       	call   80bf1d <setup_tcp>
  newconn->err = err;
  80c7f1:	89 f8                	mov    %edi,%eax
  80c7f3:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80c7f6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80c7f9:	85 c0                	test   %eax,%eax
  80c7fb:	74 15                	je     80c812 <accept_function+0x76>
  80c7fd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c804:	00 
  80c805:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c80c:	00 
  80c80d:	89 1c 24             	mov    %ebx,(%esp)
  80c810:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80c812:	89 74 24 04          	mov    %esi,0x4(%esp)
  80c816:	8b 43 18             	mov    0x18(%ebx),%eax
  80c819:	89 04 24             	mov    %eax,(%esp)
  80c81c:	e8 9b e2 ff ff       	call   80aabc <sys_mbox_trypost>
  80c821:	84 c0                	test   %al,%al
  80c823:	74 1d                	je     80c842 <accept_function+0xa6>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80c825:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80c82c:	89 34 24             	mov    %esi,(%esp)
  80c82f:	e8 84 fe ff ff       	call   80c6b8 <netconn_free>
    return ERR_MEM;
  80c834:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c839:	eb 0c                	jmp    80c847 <accept_function+0xab>

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
    return ERR_MEM;
  80c83b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c840:	eb 05                	jmp    80c847 <accept_function+0xab>
       so do nothing here! */
    newconn->pcb.tcp = NULL;
    netconn_free(newconn);
    return ERR_MEM;
  }
  return ERR_OK;
  80c842:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c847:	83 c4 1c             	add    $0x1c,%esp
  80c84a:	5b                   	pop    %ebx
  80c84b:	5e                   	pop    %esi
  80c84c:	5f                   	pop    %edi
  80c84d:	5d                   	pop    %ebp
  80c84e:	c3                   	ret    

0080c84f <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80c84f:	55                   	push   %ebp
  80c850:	89 e5                	mov    %esp,%ebp
  80c852:	53                   	push   %ebx
  80c853:	83 ec 14             	sub    $0x14,%esp
  80c856:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80c859:	8b 03                	mov    (%ebx),%eax
  80c85b:	8b 48 08             	mov    0x8(%eax),%ecx
  80c85e:	85 c9                	test   %ecx,%ecx
  80c860:	74 4b                	je     80c8ad <do_delconn+0x5e>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c862:	8b 10                	mov    (%eax),%edx
  80c864:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80c86a:	83 fa 20             	cmp    $0x20,%edx
  80c86d:	74 18                	je     80c887 <do_delconn+0x38>
  80c86f:	83 fa 40             	cmp    $0x40,%edx
  80c872:	74 07                	je     80c87b <do_delconn+0x2c>
  80c874:	83 fa 10             	cmp    $0x10,%edx
  80c877:	75 34                	jne    80c8ad <do_delconn+0x5e>
  80c879:	eb 22                	jmp    80c89d <do_delconn+0x4e>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80c87b:	89 0c 24             	mov    %ecx,(%esp)
  80c87e:	66 90                	xchg   %ax,%ax
  80c880:	e8 a5 21 00 00       	call   80ea2a <raw_remove>
      break;
  80c885:	eb 26                	jmp    80c8ad <do_delconn+0x5e>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80c887:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80c88e:	8b 03                	mov    (%ebx),%eax
  80c890:	8b 40 08             	mov    0x8(%eax),%eax
  80c893:	89 04 24             	mov    %eax,(%esp)
  80c896:	e8 73 cf ff ff       	call   80980e <udp_remove>
      break;
  80c89b:	eb 10                	jmp    80c8ad <do_delconn+0x5e>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80c89d:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80c8a4:	8b 03                	mov    (%ebx),%eax
  80c8a6:	e8 57 f9 ff ff       	call   80c202 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80c8ab:	eb 4e                	jmp    80c8fb <do_delconn+0xac>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80c8ad:	8b 13                	mov    (%ebx),%edx
  80c8af:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c8b2:	85 c0                	test   %eax,%eax
  80c8b4:	74 33                	je     80c8e9 <do_delconn+0x9a>
  80c8b6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c8bd:	00 
  80c8be:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c8c5:	00 
  80c8c6:	89 14 24             	mov    %edx,(%esp)
  80c8c9:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80c8cb:	8b 13                	mov    (%ebx),%edx
  80c8cd:	8b 42 2c             	mov    0x2c(%edx),%eax
  80c8d0:	85 c0                	test   %eax,%eax
  80c8d2:	74 15                	je     80c8e9 <do_delconn+0x9a>
  80c8d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c8db:	00 
  80c8dc:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80c8e3:	00 
  80c8e4:	89 14 24             	mov    %edx,(%esp)
  80c8e7:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80c8e9:	8b 03                	mov    (%ebx),%eax
  80c8eb:	8b 40 10             	mov    0x10(%eax),%eax
  80c8ee:	83 f8 ff             	cmp    $0xffffffff,%eax
  80c8f1:	74 08                	je     80c8fb <do_delconn+0xac>
    sys_sem_signal(msg->conn->op_completed);
  80c8f3:	89 04 24             	mov    %eax,(%esp)
  80c8f6:	e8 35 e0 ff ff       	call   80a930 <sys_sem_signal>
  }
}
  80c8fb:	83 c4 14             	add    $0x14,%esp
  80c8fe:	5b                   	pop    %ebx
  80c8ff:	5d                   	pop    %ebp
  80c900:	c3                   	ret    

0080c901 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80c901:	55                   	push   %ebp
  80c902:	89 e5                	mov    %esp,%ebp
  80c904:	56                   	push   %esi
  80c905:	53                   	push   %ebx
  80c906:	83 ec 10             	sub    $0x10,%esp
  80c909:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80c90c:	8b 33                	mov    (%ebx),%esi
  80c90e:	80 7e 0c fc          	cmpb   $0xfc,0xc(%esi)
  80c912:	7c 6f                	jl     80c983 <do_bind+0x82>
    if (msg->conn->pcb.tcp != NULL) {
  80c914:	8b 56 08             	mov    0x8(%esi),%edx
  80c917:	85 d2                	test   %edx,%edx
  80c919:	74 64                	je     80c97f <do_bind+0x7e>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c91b:	8b 06                	mov    (%esi),%eax
  80c91d:	25 f0 00 00 00       	and    $0xf0,%eax
  80c922:	83 f8 20             	cmp    $0x20,%eax
  80c925:	74 20                	je     80c947 <do_bind+0x46>
  80c927:	83 f8 40             	cmp    $0x40,%eax
  80c92a:	74 07                	je     80c933 <do_bind+0x32>
  80c92c:	83 f8 10             	cmp    $0x10,%eax
  80c92f:	75 52                	jne    80c983 <do_bind+0x82>
  80c931:	eb 30                	jmp    80c963 <do_bind+0x62>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c933:	8b 43 04             	mov    0x4(%ebx),%eax
  80c936:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c93a:	89 14 24             	mov    %edx,(%esp)
  80c93d:	e8 4a 1f 00 00       	call   80e88c <raw_bind>
  80c942:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c945:	eb 3c                	jmp    80c983 <do_bind+0x82>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c947:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c94b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c94f:	8b 43 04             	mov    0x4(%ebx),%eax
  80c952:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c956:	89 14 24             	mov    %edx,(%esp)
  80c959:	e8 13 cb ff ff       	call   809471 <udp_bind>
  80c95e:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c961:	eb 20                	jmp    80c983 <do_bind+0x82>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c963:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c967:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c96b:	8b 43 04             	mov    0x4(%ebx),%eax
  80c96e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c972:	89 14 24             	mov    %edx,(%esp)
  80c975:	e8 b9 90 ff ff       	call   805a33 <tcp_bind>
  80c97a:	88 46 0c             	mov    %al,0xc(%esi)
        break;
  80c97d:	eb 04                	jmp    80c983 <do_bind+0x82>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80c97f:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80c983:	8b 03                	mov    (%ebx),%eax
  80c985:	8b 40 10             	mov    0x10(%eax),%eax
  80c988:	89 04 24             	mov    %eax,(%esp)
  80c98b:	e8 a0 df ff ff       	call   80a930 <sys_sem_signal>
}
  80c990:	83 c4 10             	add    $0x10,%esp
  80c993:	5b                   	pop    %ebx
  80c994:	5e                   	pop    %esi
  80c995:	5d                   	pop    %ebp
  80c996:	c3                   	ret    

0080c997 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80c997:	55                   	push   %ebp
  80c998:	89 e5                	mov    %esp,%ebp
  80c99a:	56                   	push   %esi
  80c99b:	53                   	push   %ebx
  80c99c:	83 ec 10             	sub    $0x10,%esp
  80c99f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp == NULL) {
  80c9a2:	8b 33                	mov    (%ebx),%esi
  80c9a4:	8b 56 08             	mov    0x8(%esi),%edx
  80c9a7:	85 d2                	test   %edx,%edx
  80c9a9:	75 10                	jne    80c9bb <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80c9ab:	8b 46 10             	mov    0x10(%esi),%eax
  80c9ae:	89 04 24             	mov    %eax,(%esp)
  80c9b1:	e8 7a df ff ff       	call   80a930 <sys_sem_signal>
    return;
  80c9b6:	e9 9b 00 00 00       	jmp    80ca56 <do_connect+0xbf>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80c9bb:	8b 06                	mov    (%esi),%eax
  80c9bd:	25 f0 00 00 00       	and    $0xf0,%eax
  80c9c2:	83 f8 20             	cmp    $0x20,%eax
  80c9c5:	74 31                	je     80c9f8 <do_connect+0x61>
  80c9c7:	83 f8 40             	cmp    $0x40,%eax
  80c9ca:	74 0b                	je     80c9d7 <do_connect+0x40>
  80c9cc:	83 f8 10             	cmp    $0x10,%eax
  80c9cf:	0f 85 81 00 00 00    	jne    80ca56 <do_connect+0xbf>
  80c9d5:	eb 4a                	jmp    80ca21 <do_connect+0x8a>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80c9d7:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9da:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c9de:	89 14 24             	mov    %edx,(%esp)
  80c9e1:	e8 c5 1e 00 00       	call   80e8ab <raw_connect>
  80c9e6:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80c9e9:	8b 03                	mov    (%ebx),%eax
  80c9eb:	8b 40 10             	mov    0x10(%eax),%eax
  80c9ee:	89 04 24             	mov    %eax,(%esp)
  80c9f1:	e8 3a df ff ff       	call   80a930 <sys_sem_signal>
    break;
  80c9f6:	eb 5e                	jmp    80ca56 <do_connect+0xbf>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80c9f8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80c9fc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ca00:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca03:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ca07:	89 14 24             	mov    %edx,(%esp)
  80ca0a:	e8 56 cd ff ff       	call   809765 <udp_connect>
  80ca0f:	88 46 0c             	mov    %al,0xc(%esi)
    sys_sem_signal(msg->conn->op_completed);
  80ca12:	8b 03                	mov    (%ebx),%eax
  80ca14:	8b 40 10             	mov    0x10(%eax),%eax
  80ca17:	89 04 24             	mov    %eax,(%esp)
  80ca1a:	e8 11 df ff ff       	call   80a930 <sys_sem_signal>
    break;
  80ca1f:	eb 35                	jmp    80ca56 <do_connect+0xbf>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80ca21:	c7 46 04 03 00 00 00 	movl   $0x3,0x4(%esi)
    setup_tcp(msg->conn);
  80ca28:	8b 03                	mov    (%ebx),%eax
  80ca2a:	e8 ee f4 ff ff       	call   80bf1d <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80ca2f:	8b 33                	mov    (%ebx),%esi
  80ca31:	c7 44 24 0c 81 bf 80 	movl   $0x80bf81,0xc(%esp)
  80ca38:	00 
  80ca39:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80ca3d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ca41:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca44:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ca48:	8b 46 08             	mov    0x8(%esi),%eax
  80ca4b:	89 04 24             	mov    %eax,(%esp)
  80ca4e:	e8 fd 9e ff ff       	call   806950 <tcp_connect>
  80ca53:	88 46 0c             	mov    %al,0xc(%esi)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80ca56:	83 c4 10             	add    $0x10,%esp
  80ca59:	5b                   	pop    %ebx
  80ca5a:	5e                   	pop    %esi
  80ca5b:	5d                   	pop    %ebp
  80ca5c:	c3                   	ret    

0080ca5d <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80ca5d:	55                   	push   %ebp
  80ca5e:	89 e5                	mov    %esp,%ebp
  80ca60:	53                   	push   %ebx
  80ca61:	83 ec 14             	sub    $0x14,%esp
  80ca64:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80ca67:	8b 03                	mov    (%ebx),%eax
  80ca69:	8b 10                	mov    (%eax),%edx
  80ca6b:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ca71:	83 fa 20             	cmp    $0x20,%edx
  80ca74:	75 0b                	jne    80ca81 <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80ca76:	8b 40 08             	mov    0x8(%eax),%eax
  80ca79:	89 04 24             	mov    %eax,(%esp)
  80ca7c:	e8 5e cd ff ff       	call   8097df <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80ca81:	8b 03                	mov    (%ebx),%eax
  80ca83:	8b 40 10             	mov    0x10(%eax),%eax
  80ca86:	89 04 24             	mov    %eax,(%esp)
  80ca89:	e8 a2 de ff ff       	call   80a930 <sys_sem_signal>
}
  80ca8e:	83 c4 14             	add    $0x14,%esp
  80ca91:	5b                   	pop    %ebx
  80ca92:	5d                   	pop    %ebp
  80ca93:	c3                   	ret    

0080ca94 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80ca94:	55                   	push   %ebp
  80ca95:	89 e5                	mov    %esp,%ebp
  80ca97:	57                   	push   %edi
  80ca98:	56                   	push   %esi
  80ca99:	53                   	push   %ebx
  80ca9a:	83 ec 1c             	sub    $0x1c,%esp
  80ca9d:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80caa0:	8b 03                	mov    (%ebx),%eax
  80caa2:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80caa6:	0f 8c b9 00 00 00    	jl     80cb65 <do_listen+0xd1>
    if (msg->conn->pcb.tcp != NULL) {
  80caac:	8b 50 08             	mov    0x8(%eax),%edx
  80caaf:	85 d2                	test   %edx,%edx
  80cab1:	0f 84 ae 00 00 00    	je     80cb65 <do_listen+0xd1>
      if (msg->conn->type == NETCONN_TCP) {
  80cab7:	83 38 10             	cmpl   $0x10,(%eax)
  80caba:	0f 85 a5 00 00 00    	jne    80cb65 <do_listen+0xd1>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80cac0:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80cac4:	0f 85 97 00 00 00    	jne    80cb61 <do_listen+0xcd>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80caca:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80cad1:	00 
  80cad2:	89 14 24             	mov    %edx,(%esp)
  80cad5:	e8 1c 91 ff ff       	call   805bf6 <tcp_listen_with_backlog>
  80cada:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80cadc:	85 c0                	test   %eax,%eax
  80cade:	75 08                	jne    80cae8 <do_listen+0x54>
            msg->conn->err = ERR_MEM;
  80cae0:	8b 03                	mov    (%ebx),%eax
  80cae2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80cae6:	eb 7d                	jmp    80cb65 <do_listen+0xd1>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80cae8:	8b 03                	mov    (%ebx),%eax
  80caea:	8b 40 14             	mov    0x14(%eax),%eax
  80caed:	83 f8 ff             	cmp    $0xffffffff,%eax
  80caf0:	74 11                	je     80cb03 <do_listen+0x6f>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80caf2:	89 04 24             	mov    %eax,(%esp)
  80caf5:	e8 71 dc ff ff       	call   80a76b <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80cafa:	8b 03                	mov    (%ebx),%eax
  80cafc:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80cb03:	8b 3b                	mov    (%ebx),%edi
  80cb05:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80cb09:	75 1a                	jne    80cb25 <do_listen+0x91>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80cb0b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80cb12:	e8 ff dc ff ff       	call   80a816 <sys_mbox_new>
  80cb17:	89 47 18             	mov    %eax,0x18(%edi)
  80cb1a:	83 f8 ff             	cmp    $0xffffffff,%eax
  80cb1d:	75 06                	jne    80cb25 <do_listen+0x91>
                msg->conn->err = ERR_MEM;
  80cb1f:	8b 03                	mov    (%ebx),%eax
  80cb21:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80cb25:	8b 03                	mov    (%ebx),%eax
  80cb27:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cb2b:	75 38                	jne    80cb65 <do_listen+0xd1>
              msg->conn->state = NETCONN_LISTEN;
  80cb2d:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80cb34:	8b 03                	mov    (%ebx),%eax
  80cb36:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80cb39:	8b 03                	mov    (%ebx),%eax
  80cb3b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cb3f:	8b 40 08             	mov    0x8(%eax),%eax
  80cb42:	89 04 24             	mov    %eax,(%esp)
  80cb45:	e8 72 93 ff ff       	call   805ebc <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80cb4a:	c7 44 24 04 9c c7 80 	movl   $0x80c79c,0x4(%esp)
  80cb51:	00 
  80cb52:	8b 03                	mov    (%ebx),%eax
  80cb54:	8b 40 08             	mov    0x8(%eax),%eax
  80cb57:	89 04 24             	mov    %eax,(%esp)
  80cb5a:	e8 9e 93 ff ff       	call   805efd <tcp_accept>
  80cb5f:	eb 04                	jmp    80cb65 <do_listen+0xd1>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80cb61:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cb65:	8b 03                	mov    (%ebx),%eax
  80cb67:	8b 40 10             	mov    0x10(%eax),%eax
  80cb6a:	89 04 24             	mov    %eax,(%esp)
  80cb6d:	e8 be dd ff ff       	call   80a930 <sys_sem_signal>
}
  80cb72:	83 c4 1c             	add    $0x1c,%esp
  80cb75:	5b                   	pop    %ebx
  80cb76:	5e                   	pop    %esi
  80cb77:	5f                   	pop    %edi
  80cb78:	5d                   	pop    %ebp
  80cb79:	c3                   	ret    

0080cb7a <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80cb7a:	55                   	push   %ebp
  80cb7b:	89 e5                	mov    %esp,%ebp
  80cb7d:	57                   	push   %edi
  80cb7e:	56                   	push   %esi
  80cb7f:	53                   	push   %ebx
  80cb80:	83 ec 1c             	sub    $0x1c,%esp
  80cb83:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cb86:	8b 1e                	mov    (%esi),%ebx
  80cb88:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80cb8c:	0f 8c 8b 00 00 00    	jl     80cc1d <do_send+0xa3>
    if (msg->conn->pcb.tcp != NULL) {
  80cb92:	8b 43 08             	mov    0x8(%ebx),%eax
  80cb95:	85 c0                	test   %eax,%eax
  80cb97:	0f 84 80 00 00 00    	je     80cc1d <do_send+0xa3>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80cb9d:	8b 13                	mov    (%ebx),%edx
  80cb9f:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80cba5:	83 fa 20             	cmp    $0x20,%edx
  80cba8:	74 39                	je     80cbe3 <do_send+0x69>
  80cbaa:	83 fa 40             	cmp    $0x40,%edx
  80cbad:	75 6e                	jne    80cc1d <do_send+0xa3>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80cbaf:	8b 56 04             	mov    0x4(%esi),%edx
  80cbb2:	8b 4a 08             	mov    0x8(%edx),%ecx
  80cbb5:	85 c9                	test   %ecx,%ecx
  80cbb7:	75 13                	jne    80cbcc <do_send+0x52>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80cbb9:	8b 12                	mov    (%edx),%edx
  80cbbb:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbbf:	89 04 24             	mov    %eax,(%esp)
  80cbc2:	e8 42 1e 00 00       	call   80ea09 <raw_send>
  80cbc7:	88 43 0c             	mov    %al,0xc(%ebx)
  80cbca:	eb 51                	jmp    80cc1d <do_send+0xa3>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80cbcc:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cbd0:	8b 12                	mov    (%edx),%edx
  80cbd2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbd6:	89 04 24             	mov    %eax,(%esp)
  80cbd9:	e8 01 1d 00 00       	call   80e8df <raw_sendto>
  80cbde:	88 43 0c             	mov    %al,0xc(%ebx)
  80cbe1:	eb 3a                	jmp    80cc1d <do_send+0xa3>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80cbe3:	8b 56 04             	mov    0x4(%esi),%edx
  80cbe6:	8b 4a 08             	mov    0x8(%edx),%ecx
  80cbe9:	85 c9                	test   %ecx,%ecx
  80cbeb:	75 13                	jne    80cc00 <do_send+0x86>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80cbed:	8b 12                	mov    (%edx),%edx
  80cbef:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cbf3:	89 04 24             	mov    %eax,(%esp)
  80cbf6:	e8 41 cb ff ff       	call   80973c <udp_send>
  80cbfb:	88 43 0c             	mov    %al,0xc(%ebx)
  80cbfe:	eb 1d                	jmp    80cc1d <do_send+0xa3>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80cc00:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80cc04:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80cc08:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cc0c:	8b 12                	mov    (%edx),%edx
  80cc0e:	89 54 24 04          	mov    %edx,0x4(%esp)
  80cc12:	89 04 24             	mov    %eax,(%esp)
  80cc15:	e8 d9 ca ff ff       	call   8096f3 <udp_sendto>
  80cc1a:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80cc1d:	8b 06                	mov    (%esi),%eax
  80cc1f:	8b 40 10             	mov    0x10(%eax),%eax
  80cc22:	89 04 24             	mov    %eax,(%esp)
  80cc25:	e8 06 dd ff ff       	call   80a930 <sys_sem_signal>
}
  80cc2a:	83 c4 1c             	add    $0x1c,%esp
  80cc2d:	5b                   	pop    %ebx
  80cc2e:	5e                   	pop    %esi
  80cc2f:	5f                   	pop    %edi
  80cc30:	5d                   	pop    %ebp
  80cc31:	c3                   	ret    

0080cc32 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80cc32:	55                   	push   %ebp
  80cc33:	89 e5                	mov    %esp,%ebp
  80cc35:	53                   	push   %ebx
  80cc36:	83 ec 14             	sub    $0x14,%esp
  80cc39:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cc3c:	8b 03                	mov    (%ebx),%eax
  80cc3e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cc42:	7c 1c                	jl     80cc60 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80cc44:	8b 50 08             	mov    0x8(%eax),%edx
  80cc47:	85 d2                	test   %edx,%edx
  80cc49:	74 15                	je     80cc60 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80cc4b:	83 38 10             	cmpl   $0x10,(%eax)
  80cc4e:	75 10                	jne    80cc60 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80cc50:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80cc54:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cc58:	89 14 24             	mov    %edx,(%esp)
  80cc5b:	e8 94 90 ff ff       	call   805cf4 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80cc60:	8b 03                	mov    (%ebx),%eax
  80cc62:	8b 40 10             	mov    0x10(%eax),%eax
  80cc65:	89 04 24             	mov    %eax,(%esp)
  80cc68:	e8 c3 dc ff ff       	call   80a930 <sys_sem_signal>
}
  80cc6d:	83 c4 14             	add    $0x14,%esp
  80cc70:	5b                   	pop    %ebx
  80cc71:	5d                   	pop    %ebp
  80cc72:	c3                   	ret    

0080cc73 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80cc73:	55                   	push   %ebp
  80cc74:	89 e5                	mov    %esp,%ebp
  80cc76:	83 ec 18             	sub    $0x18,%esp
  80cc79:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80cc7c:	8b 02                	mov    (%edx),%eax
  80cc7e:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80cc82:	7c 2d                	jl     80ccb1 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cc84:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cc88:	74 23                	je     80ccad <do_write+0x3a>
  80cc8a:	83 38 10             	cmpl   $0x10,(%eax)
  80cc8d:	75 1e                	jne    80ccad <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80cc8f:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80cc96:	8b 02                	mov    (%edx),%eax
  80cc98:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80cc9b:	8b 02                	mov    (%edx),%eax
  80cc9d:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80cca4:	8b 02                	mov    (%edx),%eax
  80cca6:	e8 01 f4 ff ff       	call   80c0ac <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80ccab:	eb 11                	jmp    80ccbe <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80ccad:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80ccb1:	8b 02                	mov    (%edx),%eax
  80ccb3:	8b 40 10             	mov    0x10(%eax),%eax
  80ccb6:	89 04 24             	mov    %eax,(%esp)
  80ccb9:	e8 72 dc ff ff       	call   80a930 <sys_sem_signal>
}
  80ccbe:	c9                   	leave  
  80ccbf:	c3                   	ret    

0080ccc0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80ccc0:	55                   	push   %ebp
  80ccc1:	89 e5                	mov    %esp,%ebp
  80ccc3:	83 ec 18             	sub    $0x18,%esp
  80ccc6:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80ccc9:	8b 08                	mov    (%eax),%ecx
  80cccb:	8b 51 08             	mov    0x8(%ecx),%edx
  80ccce:	85 d2                	test   %edx,%edx
  80ccd0:	0f 84 98 00 00 00    	je     80cd6e <do_getaddr+0xae>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80ccd6:	8b 48 04             	mov    0x4(%eax),%ecx
  80ccd9:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ccdd:	74 06                	je     80cce5 <do_getaddr+0x25>
  80ccdf:	8b 12                	mov    (%edx),%edx
  80cce1:	89 11                	mov    %edx,(%ecx)
  80cce3:	eb 05                	jmp    80ccea <do_getaddr+0x2a>
  80cce5:	8b 52 04             	mov    0x4(%edx),%edx
  80cce8:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ccea:	8b 08                	mov    (%eax),%ecx
  80ccec:	8b 11                	mov    (%ecx),%edx
  80ccee:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ccf4:	83 fa 20             	cmp    $0x20,%edx
  80ccf7:	74 27                	je     80cd20 <do_getaddr+0x60>
  80ccf9:	83 fa 40             	cmp    $0x40,%edx
  80ccfc:	74 07                	je     80cd05 <do_getaddr+0x45>
  80ccfe:	83 fa 10             	cmp    $0x10,%edx
  80cd01:	75 6f                	jne    80cd72 <do_getaddr+0xb2>
  80cd03:	eb 4b                	jmp    80cd50 <do_getaddr+0x90>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80cd05:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cd09:	74 0f                	je     80cd1a <do_getaddr+0x5a>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80cd0b:	8b 50 08             	mov    0x8(%eax),%edx
  80cd0e:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd11:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80cd15:	66 89 0a             	mov    %cx,(%edx)
  80cd18:	eb 58                	jmp    80cd72 <do_getaddr+0xb2>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80cd1a:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cd1e:	eb 52                	jmp    80cd72 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80cd20:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cd24:	74 0f                	je     80cd35 <do_getaddr+0x75>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80cd26:	8b 50 08             	mov    0x8(%eax),%edx
  80cd29:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd2c:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80cd30:	66 89 0a             	mov    %cx,(%edx)
  80cd33:	eb 3d                	jmp    80cd72 <do_getaddr+0xb2>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80cd35:	8b 51 08             	mov    0x8(%ecx),%edx
  80cd38:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80cd3c:	75 06                	jne    80cd44 <do_getaddr+0x84>
          msg->conn->err = ERR_CONN;
  80cd3e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80cd42:	eb 2e                	jmp    80cd72 <do_getaddr+0xb2>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80cd44:	8b 48 08             	mov    0x8(%eax),%ecx
  80cd47:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80cd4b:	66 89 11             	mov    %dx,(%ecx)
  80cd4e:	eb 22                	jmp    80cd72 <do_getaddr+0xb2>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80cd50:	8b 50 08             	mov    0x8(%eax),%edx
  80cd53:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80cd57:	74 09                	je     80cd62 <do_getaddr+0xa2>
  80cd59:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd5c:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80cd60:	eb 07                	jmp    80cd69 <do_getaddr+0xa9>
  80cd62:	8b 49 08             	mov    0x8(%ecx),%ecx
  80cd65:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80cd69:	66 89 0a             	mov    %cx,(%edx)
      break;
  80cd6c:	eb 04                	jmp    80cd72 <do_getaddr+0xb2>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80cd6e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80cd72:	8b 00                	mov    (%eax),%eax
  80cd74:	8b 40 10             	mov    0x10(%eax),%eax
  80cd77:	89 04 24             	mov    %eax,(%esp)
  80cd7a:	e8 b1 db ff ff       	call   80a930 <sys_sem_signal>
}
  80cd7f:	c9                   	leave  
  80cd80:	c3                   	ret    

0080cd81 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80cd81:	55                   	push   %ebp
  80cd82:	89 e5                	mov    %esp,%ebp
  80cd84:	83 ec 18             	sub    $0x18,%esp
  80cd87:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80cd8a:	8b 02                	mov    (%edx),%eax
  80cd8c:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80cd90:	74 15                	je     80cda7 <do_close+0x26>
  80cd92:	83 38 10             	cmpl   $0x10,(%eax)
  80cd95:	75 10                	jne    80cda7 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80cd97:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80cd9e:	8b 02                	mov    (%edx),%eax
  80cda0:	e8 5d f4 ff ff       	call   80c202 <do_close_internal>
  80cda5:	eb 11                	jmp    80cdb8 <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80cda7:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80cdab:	8b 02                	mov    (%edx),%eax
  80cdad:	8b 40 10             	mov    0x10(%eax),%eax
  80cdb0:	89 04 24             	mov    %eax,(%esp)
  80cdb3:	e8 78 db ff ff       	call   80a930 <sys_sem_signal>
  }
}
  80cdb8:	c9                   	leave  
  80cdb9:	c3                   	ret    
  80cdba:	66 90                	xchg   %ax,%ax
  80cdbc:	66 90                	xchg   %ax,%ax
  80cdbe:	66 90                	xchg   %ax,%ax

0080cdc0 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80cdc0:	55                   	push   %ebp
  80cdc1:	89 e5                	mov    %esp,%ebp
  80cdc3:	57                   	push   %edi
  80cdc4:	56                   	push   %esi
  80cdc5:	53                   	push   %ebx
  80cdc6:	83 ec 1c             	sub    $0x1c,%esp
  80cdc9:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cdcb:	8b 35 d0 c1 b3 00    	mov    0xb3c1d0,%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80cdd1:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80cdd5:	89 04 24             	mov    %eax,(%esp)
  80cdd8:	e8 d6 af ff ff       	call   807db3 <ntohs>
  80cddd:	66 3d ff 5f          	cmp    $0x5fff,%ax
  80cde1:	76 7f                	jbe    80ce62 <tcp_parseopt+0xa2>
{
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80cde3:	83 c6 14             	add    $0x14,%esi
  80cde6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80cdeb:	eb 4f                	jmp    80ce3c <tcp_parseopt+0x7c>

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80cded:	0f b6 d3             	movzbl %bl,%edx
  80cdf0:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80cdf4:	84 c0                	test   %al,%al
  80cdf6:	74 6a                	je     80ce62 <tcp_parseopt+0xa2>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80cdf8:	3c 01                	cmp    $0x1,%al
  80cdfa:	75 05                	jne    80ce01 <tcp_parseopt+0x41>
        ++c;
  80cdfc:	83 c3 01             	add    $0x1,%ebx
  80cdff:	eb 3b                	jmp    80ce3c <tcp_parseopt+0x7c>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80ce01:	3c 02                	cmp    $0x2,%al
  80ce03:	75 2c                	jne    80ce31 <tcp_parseopt+0x71>
  80ce05:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80ce0a:	75 25                	jne    80ce31 <tcp_parseopt+0x71>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80ce0c:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80ce11:	c1 e0 08             	shl    $0x8,%eax
  80ce14:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80ce19:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80ce1b:	8d 50 ff             	lea    -0x1(%eax),%edx
  80ce1e:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  80ce23:	ba b4 05 00 00       	mov    $0x5b4,%edx
  80ce28:	0f 43 c2             	cmovae %edx,%eax
  80ce2b:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80ce2f:	eb 31                	jmp    80ce62 <tcp_parseopt+0xa2>
      } else {
        if (opts[c + 1] == 0) {
  80ce31:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80ce36:	84 c0                	test   %al,%al
  80ce38:	74 28                	je     80ce62 <tcp_parseopt+0xa2>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80ce3a:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80ce3c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80ce41:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ce45:	89 04 24             	mov    %eax,(%esp)
  80ce48:	e8 66 af ff ff       	call   807db3 <ntohs>
  80ce4d:	0f b6 d3             	movzbl %bl,%edx
  80ce50:	66 c1 e8 0c          	shr    $0xc,%ax
  80ce54:	0f b7 c0             	movzwl %ax,%eax
  80ce57:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80ce5e:	39 c2                	cmp    %eax,%edx
  80ce60:	7c 8b                	jl     80cded <tcp_parseopt+0x2d>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80ce62:	83 c4 1c             	add    $0x1c,%esp
  80ce65:	5b                   	pop    %ebx
  80ce66:	5e                   	pop    %esi
  80ce67:	5f                   	pop    %edi
  80ce68:	5d                   	pop    %ebp
  80ce69:	c3                   	ret    

0080ce6a <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80ce6a:	55                   	push   %ebp
  80ce6b:	89 e5                	mov    %esp,%ebp
  80ce6d:	57                   	push   %edi
  80ce6e:	56                   	push   %esi
  80ce6f:	53                   	push   %ebx
  80ce70:	83 ec 2c             	sub    $0x2c,%esp
  80ce73:	89 c7                	mov    %eax,%edi
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80ce75:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80ce7c:	0f 84 45 04 00 00    	je     80d2c7 <tcp_receive+0x45d>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80ce82:	0f b7 58 5c          	movzwl 0x5c(%eax),%ebx
  80ce86:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80ce89:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80ce8e:	39 c2                	cmp    %eax,%edx
  80ce90:	78 26                	js     80ceb8 <tcp_receive+0x4e>
  80ce92:	39 c2                	cmp    %eax,%edx
  80ce94:	75 0b                	jne    80cea1 <tcp_receive+0x37>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80ce96:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80ce9c:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80ce9f:	78 17                	js     80ceb8 <tcp_receive+0x4e>
  80cea1:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80cea7:	39 4f 64             	cmp    %ecx,0x64(%edi)
  80ceaa:	75 3a                	jne    80cee6 <tcp_receive+0x7c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80ceac:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
  80ceb2:	66 3b 59 0e          	cmp    0xe(%ecx),%bx
  80ceb6:	73 2e                	jae    80cee6 <tcp_receive+0x7c>
      pcb->snd_wnd = tcphdr->wnd;
  80ceb8:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
  80cebe:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  80cec2:	66 89 4f 5c          	mov    %cx,0x5c(%edi)
      pcb->snd_wl1 = seqno;
  80cec6:	89 47 60             	mov    %eax,0x60(%edi)
      pcb->snd_wl2 = ackno;
  80cec9:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80cece:	89 47 64             	mov    %eax,0x64(%edi)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80ced1:	66 85 c9             	test   %cx,%cx
  80ced4:	74 10                	je     80cee6 <tcp_receive+0x7c>
  80ced6:	80 bf a4 00 00 00 00 	cmpb   $0x0,0xa4(%edi)
  80cedd:	74 07                	je     80cee6 <tcp_receive+0x7c>
          pcb->persist_backoff = 0;
  80cedf:	c6 87 a4 00 00 00 00 	movb   $0x0,0xa4(%edi)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80cee6:	8b 4f 48             	mov    0x48(%edi),%ecx
  80cee9:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80ceee:	39 c1                	cmp    %eax,%ecx
  80cef0:	0f 85 a9 00 00 00    	jne    80cf9f <tcp_receive+0x135>
      pcb->acked = 0;
  80cef6:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cefc:	0f b7 47 5c          	movzwl 0x5c(%edi),%eax
  80cf00:	03 47 60             	add    0x60(%edi),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80cf03:	0f b7 db             	movzwl %bx,%ebx
  80cf06:	01 da                	add    %ebx,%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  80cf08:	39 d0                	cmp    %edx,%eax
  80cf0a:	0f 85 e9 02 00 00    	jne    80d1f9 <tcp_receive+0x38f>
        ++pcb->dupacks;
  80cf10:	0f b6 47 4c          	movzbl 0x4c(%edi),%eax
  80cf14:	83 c0 01             	add    $0x1,%eax
  80cf17:	88 47 4c             	mov    %al,0x4c(%edi)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  80cf1a:	3c 02                	cmp    $0x2,%al
  80cf1c:	0f 86 d7 02 00 00    	jbe    80d1f9 <tcp_receive+0x38f>
  80cf22:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80cf26:	0f 84 cd 02 00 00    	je     80d1f9 <tcp_receive+0x38f>
          if (!(pcb->flags & TF_INFR)) {
  80cf2c:	f6 47 20 04          	testb  $0x4,0x20(%edi)
  80cf30:	75 51                	jne    80cf83 <tcp_receive+0x119>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  80cf32:	89 3c 24             	mov    %edi,(%esp)
  80cf35:	e8 9c be ff ff       	call   808dd6 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  80cf3a:	0f b7 47 4e          	movzwl 0x4e(%edi),%eax
  80cf3e:	0f b7 57 5c          	movzwl 0x5c(%edi),%edx
  80cf42:	66 39 d0             	cmp    %dx,%ax
  80cf45:	76 09                	jbe    80cf50 <tcp_receive+0xe6>
              pcb->ssthresh = pcb->snd_wnd / 2;
  80cf47:	66 d1 ea             	shr    %dx
  80cf4a:	66 89 57 50          	mov    %dx,0x50(%edi)
  80cf4e:	eb 07                	jmp    80cf57 <tcp_receive+0xed>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  80cf50:	66 d1 e8             	shr    %ax
  80cf53:	66 89 47 50          	mov    %ax,0x50(%edi)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  80cf57:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80cf5b:	0f b7 4f 50          	movzwl 0x50(%edi),%ecx
  80cf5f:	0f b7 d0             	movzwl %ax,%edx
  80cf62:	01 d2                	add    %edx,%edx
  80cf64:	39 d1                	cmp    %edx,%ecx
  80cf66:	7d 07                	jge    80cf6f <tcp_receive+0x105>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  80cf68:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80cf6b:	66 89 57 50          	mov    %dx,0x50(%edi)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  80cf6f:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80cf72:	66 03 47 50          	add    0x50(%edi),%ax
  80cf76:	66 89 47 4e          	mov    %ax,0x4e(%edi)
            pcb->flags |= TF_INFR;
  80cf7a:	80 4f 20 04          	orb    $0x4,0x20(%edi)
  80cf7e:	e9 76 02 00 00       	jmp    80d1f9 <tcp_receive+0x38f>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80cf83:	0f b7 57 4e          	movzwl 0x4e(%edi),%edx
  80cf87:	89 d0                	mov    %edx,%eax
  80cf89:	66 03 47 34          	add    0x34(%edi),%ax
  80cf8d:	66 39 c2             	cmp    %ax,%dx
  80cf90:	0f 83 63 02 00 00    	jae    80d1f9 <tcp_receive+0x38f>
              pcb->cwnd += pcb->mss;
  80cf96:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80cf9a:	e9 5a 02 00 00       	jmp    80d1f9 <tcp_receive+0x38f>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  80cf9f:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cfa2:	39 ca                	cmp    %ecx,%edx
  80cfa4:	0f 88 a1 01 00 00    	js     80d14b <tcp_receive+0x2e1>
  80cfaa:	89 c2                	mov    %eax,%edx
  80cfac:	2b 57 58             	sub    0x58(%edi),%edx
  80cfaf:	85 d2                	test   %edx,%edx
  80cfb1:	0f 8f 94 01 00 00    	jg     80d14b <tcp_receive+0x2e1>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  80cfb7:	0f b6 57 20          	movzbl 0x20(%edi),%edx
  80cfbb:	f6 c2 04             	test   $0x4,%dl
  80cfbe:	74 0e                	je     80cfce <tcp_receive+0x164>
        pcb->flags &= ~TF_INFR;
  80cfc0:	83 e2 fb             	and    $0xfffffffb,%edx
  80cfc3:	88 57 20             	mov    %dl,0x20(%edi)
        pcb->cwnd = pcb->ssthresh;
  80cfc6:	0f b7 57 50          	movzwl 0x50(%edi),%edx
  80cfca:	66 89 57 4e          	mov    %dx,0x4e(%edi)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  80cfce:	c6 47 46 00          	movb   $0x0,0x46(%edi)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80cfd2:	0f b7 57 40          	movzwl 0x40(%edi),%edx
  80cfd6:	66 c1 fa 03          	sar    $0x3,%dx
  80cfda:	66 03 57 42          	add    0x42(%edi),%dx
  80cfde:	66 89 57 44          	mov    %dx,0x44(%edi)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  80cfe2:	89 c2                	mov    %eax,%edx
  80cfe4:	29 ca                	sub    %ecx,%edx
  80cfe6:	66 89 57 6c          	mov    %dx,0x6c(%edi)

      pcb->snd_buf += pcb->acked;
  80cfea:	66 01 57 6e          	add    %dx,0x6e(%edi)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  80cfee:	c6 47 4c 00          	movb   $0x0,0x4c(%edi)
      pcb->lastack = ackno;
  80cff2:	89 47 48             	mov    %eax,0x48(%edi)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  80cff5:	83 7f 10 03          	cmpl   $0x3,0x10(%edi)
  80cff9:	0f 86 cd 00 00 00    	jbe    80d0cc <tcp_receive+0x262>
        if (pcb->cwnd < pcb->ssthresh) {
  80cfff:	0f b7 4f 4e          	movzwl 0x4e(%edi),%ecx
  80d003:	66 3b 4f 50          	cmp    0x50(%edi),%cx
  80d007:	73 18                	jae    80d021 <tcp_receive+0x1b7>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  80d009:	89 c8                	mov    %ecx,%eax
  80d00b:	66 03 47 34          	add    0x34(%edi),%ax
  80d00f:	66 39 c1             	cmp    %ax,%cx
  80d012:	0f 83 b4 00 00 00    	jae    80d0cc <tcp_receive+0x262>
            pcb->cwnd += pcb->mss;
  80d018:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80d01c:	e9 ab 00 00 00       	jmp    80d0cc <tcp_receive+0x262>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  80d021:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80d025:	0f af c0             	imul   %eax,%eax
  80d028:	0f b7 d9             	movzwl %cx,%ebx
  80d02b:	99                   	cltd   
  80d02c:	f7 fb                	idiv   %ebx
  80d02e:	01 c8                	add    %ecx,%eax
          if (new_cwnd > pcb->cwnd) {
  80d030:	66 39 c1             	cmp    %ax,%cx
  80d033:	0f 83 93 00 00 00    	jae    80d0cc <tcp_receive+0x262>
            pcb->cwnd = new_cwnd;
  80d039:	66 89 47 4e          	mov    %ax,0x4e(%edi)
  80d03d:	e9 8a 00 00 00       	jmp    80d0cc <tcp_receive+0x262>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  80d042:	8b 5f 78             	mov    0x78(%edi),%ebx
        pcb->unacked = pcb->unacked->next;
  80d045:	8b 03                	mov    (%ebx),%eax
  80d047:	89 47 78             	mov    %eax,0x78(%edi)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d04a:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d04e:	8b 43 04             	mov    0x4(%ebx),%eax
  80d051:	89 04 24             	mov    %eax,(%esp)
  80d054:	e8 61 82 ff ff       	call   8052ba <pbuf_clen>
  80d059:	0f b6 c0             	movzbl %al,%eax
  80d05c:	66 39 c6             	cmp    %ax,%si
  80d05f:	73 1c                	jae    80d07d <tcp_receive+0x213>
  80d061:	c7 44 24 08 7c 40 81 	movl   $0x81407c,0x8(%esp)
  80d068:	00 
  80d069:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  80d070:	00 
  80d071:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d078:	e8 1d 20 00 00       	call   80f09a <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  80d07d:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d081:	8b 43 04             	mov    0x4(%ebx),%eax
  80d084:	89 04 24             	mov    %eax,(%esp)
  80d087:	e8 2e 82 ff ff       	call   8052ba <pbuf_clen>
  80d08c:	0f b6 c0             	movzbl %al,%eax
  80d08f:	29 c6                	sub    %eax,%esi
  80d091:	66 89 77 70          	mov    %si,0x70(%edi)
        tcp_seg_free(next);
  80d095:	89 1c 24             	mov    %ebx,(%esp)
  80d098:	e8 5c 8d ff ff       	call   805df9 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  80d09d:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80d0a2:	74 28                	je     80d0cc <tcp_receive+0x262>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  80d0a4:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d0a8:	75 22                	jne    80d0cc <tcp_receive+0x262>
  80d0aa:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80d0ae:	75 1c                	jne    80d0cc <tcp_receive+0x262>
  80d0b0:	c7 44 24 08 a4 40 81 	movl   $0x8140a4,0x8(%esp)
  80d0b7:	00 
  80d0b8:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  80d0bf:	00 
  80d0c0:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d0c7:	e8 ce 1f 00 00       	call   80f09a <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d0cc:	8b 47 78             	mov    0x78(%edi),%eax
  80d0cf:	85 c0                	test   %eax,%eax
  80d0d1:	74 61                	je     80d134 <tcp_receive+0x2ca>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  80d0d3:	8b 40 10             	mov    0x10(%eax),%eax
  80d0d6:	8b 40 04             	mov    0x4(%eax),%eax
  80d0d9:	89 04 24             	mov    %eax,(%esp)
  80d0dc:	e8 19 af ff ff       	call   807ffa <ntohl>
  80d0e1:	89 c6                	mov    %eax,%esi
  80d0e3:	8b 47 78             	mov    0x78(%edi),%eax
  80d0e6:	0f b7 58 0c          	movzwl 0xc(%eax),%ebx
  80d0ea:	8b 40 10             	mov    0x10(%eax),%eax
  80d0ed:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d0f1:	89 04 24             	mov    %eax,(%esp)
  80d0f4:	e8 ba ac ff ff       	call   807db3 <ntohs>
  80d0f9:	ba 01 00 00 00       	mov    $0x1,%edx
  80d0fe:	a8 01                	test   $0x1,%al
  80d100:	75 1a                	jne    80d11c <tcp_receive+0x2b2>
  80d102:	8b 47 78             	mov    0x78(%edi),%eax
  80d105:	8b 40 10             	mov    0x10(%eax),%eax
  80d108:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d10c:	89 04 24             	mov    %eax,(%esp)
  80d10f:	e8 9f ac ff ff       	call   807db3 <ntohs>
  80d114:	66 d1 e8             	shr    %ax
  80d117:	89 c2                	mov    %eax,%edx
  80d119:	83 e2 01             	and    $0x1,%edx
  80d11c:	2b 35 c4 c1 b3 00    	sub    0xb3c1c4,%esi
  80d122:	01 d3                	add    %edx,%ebx
  80d124:	01 de                	add    %ebx,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  80d126:	85 f6                	test   %esi,%esi
  80d128:	0f 8e 14 ff ff ff    	jle    80d042 <tcp_receive+0x1d8>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80d12e:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d132:	75 08                	jne    80d13c <tcp_receive+0x2d2>
        pcb->rtime = -1;
  80d134:	66 c7 47 32 ff ff    	movw   $0xffff,0x32(%edi)
  80d13a:	eb 06                	jmp    80d142 <tcp_receive+0x2d8>
      else
        pcb->rtime = 0;
  80d13c:	66 c7 47 32 00 00    	movw   $0x0,0x32(%edi)

      pcb->polltmr = 0;
  80d142:	c6 47 30 00          	movb   $0x0,0x30(%edi)
  80d146:	e9 ae 00 00 00       	jmp    80d1f9 <tcp_receive+0x38f>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  80d14b:	66 c7 47 6c 00 00    	movw   $0x0,0x6c(%edi)
  80d151:	e9 a3 00 00 00       	jmp    80d1f9 <tcp_receive+0x38f>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  80d156:	8b 5f 74             	mov    0x74(%edi),%ebx
      pcb->unsent = pcb->unsent->next;
  80d159:	8b 03                	mov    (%ebx),%eax
  80d15b:	89 47 74             	mov    %eax,0x74(%edi)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  80d15e:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d162:	8b 43 04             	mov    0x4(%ebx),%eax
  80d165:	89 04 24             	mov    %eax,(%esp)
  80d168:	e8 4d 81 ff ff       	call   8052ba <pbuf_clen>
  80d16d:	0f b6 c0             	movzbl %al,%eax
  80d170:	66 39 c6             	cmp    %ax,%si
  80d173:	73 1c                	jae    80d191 <tcp_receive+0x327>
  80d175:	c7 44 24 08 7c 40 81 	movl   $0x81407c,0x8(%esp)
  80d17c:	00 
  80d17d:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  80d184:	00 
  80d185:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d18c:	e8 09 1f 00 00       	call   80f09a <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  80d191:	0f b7 77 70          	movzwl 0x70(%edi),%esi
  80d195:	8b 43 04             	mov    0x4(%ebx),%eax
  80d198:	89 04 24             	mov    %eax,(%esp)
  80d19b:	e8 1a 81 ff ff       	call   8052ba <pbuf_clen>
  80d1a0:	0f b6 c0             	movzbl %al,%eax
  80d1a3:	29 c6                	sub    %eax,%esi
  80d1a5:	66 89 77 70          	mov    %si,0x70(%edi)
      tcp_seg_free(next);
  80d1a9:	89 1c 24             	mov    %ebx,(%esp)
  80d1ac:	e8 48 8c ff ff       	call   805df9 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  80d1b1:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80d1b6:	74 29                	je     80d1e1 <tcp_receive+0x377>
        LWIP_ASSERT("tcp_receive: valid queue length",
  80d1b8:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80d1bc:	75 23                	jne    80d1e1 <tcp_receive+0x377>
  80d1be:	8b 47 74             	mov    0x74(%edi),%eax
  80d1c1:	85 c0                	test   %eax,%eax
  80d1c3:	75 23                	jne    80d1e8 <tcp_receive+0x37e>
  80d1c5:	c7 44 24 08 a4 40 81 	movl   $0x8140a4,0x8(%esp)
  80d1cc:	00 
  80d1cd:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  80d1d4:	00 
  80d1d5:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d1dc:	e8 b9 1e 00 00       	call   80f09a <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  80d1e1:	8b 47 74             	mov    0x74(%edi),%eax
  80d1e4:	85 c0                	test   %eax,%eax
  80d1e6:	74 11                	je     80d1f9 <tcp_receive+0x38f>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  80d1e8:	8b 40 10             	mov    0x10(%eax),%eax
  80d1eb:	8b 40 04             	mov    0x4(%eax),%eax
  80d1ee:	89 04 24             	mov    %eax,(%esp)
  80d1f1:	e8 ca ab ff ff       	call   807dc0 <htonl>
  80d1f6:	89 47 54             	mov    %eax,0x54(%edi)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d1f9:	8b 47 74             	mov    0x74(%edi),%eax
  80d1fc:	85 c0                	test   %eax,%eax
  80d1fe:	74 6b                	je     80d26b <tcp_receive+0x401>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d200:	8b 35 c4 c1 b3 00    	mov    0xb3c1c4,%esi
  80d206:	8b 40 10             	mov    0x10(%eax),%eax
  80d209:	8b 40 04             	mov    0x4(%eax),%eax
  80d20c:	89 04 24             	mov    %eax,(%esp)
  80d20f:	e8 e6 ad ff ff       	call   807ffa <ntohl>
  80d214:	89 c3                	mov    %eax,%ebx
  80d216:	8b 47 74             	mov    0x74(%edi),%eax
  80d219:	0f b7 48 0c          	movzwl 0xc(%eax),%ecx
  80d21d:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80d220:	8b 40 10             	mov    0x10(%eax),%eax
  80d223:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d227:	89 04 24             	mov    %eax,(%esp)
  80d22a:	e8 84 ab ff ff       	call   807db3 <ntohs>
  80d22f:	ba 01 00 00 00       	mov    $0x1,%edx
  80d234:	a8 01                	test   $0x1,%al
  80d236:	75 1a                	jne    80d252 <tcp_receive+0x3e8>
  80d238:	8b 47 74             	mov    0x74(%edi),%eax
  80d23b:	8b 40 10             	mov    0x10(%eax),%eax
  80d23e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d242:	89 04 24             	mov    %eax,(%esp)
  80d245:	e8 69 ab ff ff       	call   807db3 <ntohs>
  80d24a:	66 d1 e8             	shr    %ax
  80d24d:	89 c2                	mov    %eax,%edx
  80d24f:	83 e2 01             	and    $0x1,%edx
  80d252:	29 de                	sub    %ebx,%esi
  80d254:	03 55 e4             	add    -0x1c(%ebp),%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  80d257:	39 d6                	cmp    %edx,%esi
  80d259:	78 10                	js     80d26b <tcp_receive+0x401>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  80d25b:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80d260:	2b 47 58             	sub    0x58(%edi),%eax
  80d263:	85 c0                	test   %eax,%eax
  80d265:	0f 8e eb fe ff ff    	jle    80d156 <tcp_receive+0x2ec>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  80d26b:	8b 47 38             	mov    0x38(%edi),%eax
  80d26e:	85 c0                	test   %eax,%eax
  80d270:	74 55                	je     80d2c7 <tcp_receive+0x45d>
  80d272:	8b 0d c4 c1 b3 00    	mov    0xb3c1c4,%ecx
  80d278:	39 4f 3c             	cmp    %ecx,0x3c(%edi)
  80d27b:	79 4a                	jns    80d2c7 <tcp_receive+0x45d>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d27d:	0f b7 57 40          	movzwl 0x40(%edi),%edx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  80d281:	0f b7 0d 60 c2 b3 00 	movzwl 0xb3c260,%ecx
  80d288:	29 c1                	sub    %eax,%ecx
  80d28a:	89 c8                	mov    %ecx,%eax

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  80d28c:	89 d1                	mov    %edx,%ecx
  80d28e:	66 c1 f9 03          	sar    $0x3,%cx
  80d292:	29 c8                	sub    %ecx,%eax
      pcb->sa += m;
  80d294:	01 c2                	add    %eax,%edx
  80d296:	66 89 57 40          	mov    %dx,0x40(%edi)
      if (m < 0) {
        m = -m;
  80d29a:	89 c1                	mov    %eax,%ecx
  80d29c:	f7 d9                	neg    %ecx
  80d29e:	66 85 c0             	test   %ax,%ax
  80d2a1:	0f 48 c1             	cmovs  %ecx,%eax
      }
      m = m - (pcb->sv >> 2);
  80d2a4:	0f b7 4f 42          	movzwl 0x42(%edi),%ecx
  80d2a8:	89 cb                	mov    %ecx,%ebx
  80d2aa:	66 c1 fb 02          	sar    $0x2,%bx
  80d2ae:	29 d9                	sub    %ebx,%ecx
      pcb->sv += m;
  80d2b0:	01 c8                	add    %ecx,%eax
  80d2b2:	66 89 47 42          	mov    %ax,0x42(%edi)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  80d2b6:	66 c1 fa 03          	sar    $0x3,%dx
  80d2ba:	01 d0                	add    %edx,%eax
  80d2bc:	66 89 47 44          	mov    %ax,0x44(%edi)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  80d2c0:	c7 47 38 00 00 00 00 	movl   $0x0,0x38(%edi)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  80d2c7:	0f b7 1d be c1 b3 00 	movzwl 0xb3c1be,%ebx
  80d2ce:	66 85 db             	test   %bx,%bx
  80d2d1:	0f 84 5b 07 00 00    	je     80da32 <tcp_receive+0xbc8>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  80d2d7:	8b 57 24             	mov    0x24(%edi),%edx
  80d2da:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d2df:	89 d1                	mov    %edx,%ecx
  80d2e1:	29 c1                	sub    %eax,%ecx
  80d2e3:	89 ce                	mov    %ecx,%esi
  80d2e5:	83 ee 01             	sub    $0x1,%esi
  80d2e8:	0f 88 41 01 00 00    	js     80d42f <tcp_receive+0x5c5>
  80d2ee:	8d 72 01             	lea    0x1(%edx),%esi
  80d2f1:	29 c6                	sub    %eax,%esi
  80d2f3:	0f b7 db             	movzwl %bx,%ebx
  80d2f6:	29 de                	sub    %ebx,%esi
  80d2f8:	85 f6                	test   %esi,%esi
  80d2fa:	0f 8f 2f 01 00 00    	jg     80d42f <tcp_receive+0x5c5>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  80d300:	89 ca                	mov    %ecx,%edx
      p = inseg.p;
  80d302:	8b 1d d8 c1 b3 00    	mov    0xb3c1d8,%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  80d308:	85 db                	test   %ebx,%ebx
  80d30a:	75 1c                	jne    80d328 <tcp_receive+0x4be>
  80d30c:	c7 44 24 08 ff 41 81 	movl   $0x8141ff,0x8(%esp)
  80d313:	00 
  80d314:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  80d31b:	00 
  80d31c:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d323:	e8 72 1d 00 00       	call   80f09a <_panic>
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  80d328:	81 f9 fe 7f 00 00    	cmp    $0x7ffe,%ecx
  80d32e:	7e 1c                	jle    80d34c <tcp_receive+0x4e2>
  80d330:	c7 44 24 08 0f 42 81 	movl   $0x81420f,0x8(%esp)
  80d337:	00 
  80d338:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  80d33f:	00 
  80d340:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d347:	e8 4e 1d 00 00       	call   80f09a <_panic>
      if (inseg.p->len < off) {
  80d34c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d350:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d353:	39 c1                	cmp    %eax,%ecx
  80d355:	7e 75                	jle    80d3cc <tcp_receive+0x562>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  80d357:	0f b7 73 08          	movzwl 0x8(%ebx),%esi
  80d35b:	0f b7 c6             	movzwl %si,%eax
  80d35e:	39 c1                	cmp    %eax,%ecx
  80d360:	7e 1c                	jle    80d37e <tcp_receive+0x514>
  80d362:	c7 44 24 08 1e 42 81 	movl   $0x81421e,0x8(%esp)
  80d369:	00 
  80d36a:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  80d371:	00 
  80d372:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d379:	e8 1c 1d 00 00       	call   80f09a <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  80d37e:	29 ce                	sub    %ecx,%esi
  80d380:	89 f1                	mov    %esi,%ecx
  80d382:	8b 45 e4             	mov    -0x1c(%ebp),%eax
        while (p->len < off) {
          off -= p->len;
  80d385:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  80d387:	66 89 4b 08          	mov    %cx,0x8(%ebx)
          p->len = 0;
  80d38b:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
          p = p->next;
  80d391:	8b 1b                	mov    (%ebx),%ebx
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  80d393:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80d397:	39 d0                	cmp    %edx,%eax
  80d399:	7c ea                	jl     80d385 <tcp_receive+0x51b>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  80d39b:	f7 da                	neg    %edx
  80d39d:	0f bf c2             	movswl %dx,%eax
  80d3a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d3a4:	89 1c 24             	mov    %ebx,(%esp)
  80d3a7:	e8 94 79 ff ff       	call   804d40 <pbuf_header>
  80d3ac:	84 c0                	test   %al,%al
  80d3ae:	74 4d                	je     80d3fd <tcp_receive+0x593>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d3b0:	c7 44 24 08 2e 42 81 	movl   $0x81422e,0x8(%esp)
  80d3b7:	00 
  80d3b8:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  80d3bf:	00 
  80d3c0:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d3c7:	e8 ce 1c 00 00       	call   80f09a <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  80d3cc:	f7 d9                	neg    %ecx
  80d3ce:	0f bf c1             	movswl %cx,%eax
  80d3d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d3d5:	89 1c 24             	mov    %ebx,(%esp)
  80d3d8:	e8 63 79 ff ff       	call   804d40 <pbuf_header>
  80d3dd:	84 c0                	test   %al,%al
  80d3df:	74 1c                	je     80d3fd <tcp_receive+0x593>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  80d3e1:	c7 44 24 08 2e 42 81 	movl   $0x81422e,0x8(%esp)
  80d3e8:	00 
  80d3e9:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  80d3f0:	00 
  80d3f1:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80d3f8:	e8 9d 1c 00 00       	call   80f09a <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  80d3fd:	8b 43 04             	mov    0x4(%ebx),%eax
  80d400:	a3 dc c1 b3 00       	mov    %eax,0xb3c1dc
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  80d405:	8b 47 24             	mov    0x24(%edi),%eax
  80d408:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d40f:	66 03 15 c8 c1 b3 00 	add    0xb3c1c8,%dx
  80d416:	29 c2                	sub    %eax,%edx
  80d418:	66 89 15 e0 c1 b3 00 	mov    %dx,0xb3c1e0
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  80d41f:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  80d424:	8b 15 e4 c1 b3 00    	mov    0xb3c1e4,%edx
  80d42a:	89 42 04             	mov    %eax,0x4(%edx)
  80d42d:	eb 10                	jmp    80d43f <tcp_receive+0x5d5>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  80d42f:	39 d0                	cmp    %edx,%eax
  80d431:	79 1c                	jns    80d44f <tcp_receive+0x5e5>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  80d433:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d437:	89 3c 24             	mov    %edi,(%esp)
  80d43a:	e8 52 b3 ff ff       	call   808791 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80d43f:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80d444:	8b 57 24             	mov    0x24(%edi),%edx
  80d447:	39 d0                	cmp    %edx,%eax
  80d449:	0f 88 d0 05 00 00    	js     80da1f <tcp_receive+0xbb5>
  80d44f:	0f b7 4f 28          	movzwl 0x28(%edi),%ecx
  80d453:	89 c3                	mov    %eax,%ebx
  80d455:	29 cb                	sub    %ecx,%ebx
  80d457:	8d 4b 01             	lea    0x1(%ebx),%ecx
  80d45a:	29 d1                	sub    %edx,%ecx
  80d45c:	85 c9                	test   %ecx,%ecx
  80d45e:	0f 8f bb 05 00 00    	jg     80da1f <tcp_receive+0xbb5>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  80d464:	39 d0                	cmp    %edx,%eax
  80d466:	0f 85 53 03 00 00    	jne    80d7bf <tcp_receive+0x955>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d46c:	8b 57 7c             	mov    0x7c(%edi),%edx
  80d46f:	85 d2                	test   %edx,%edx
  80d471:	0f 84 83 00 00 00    	je     80d4fa <tcp_receive+0x690>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  80d477:	8b 4a 10             	mov    0x10(%edx),%ecx
  80d47a:	8b 49 04             	mov    0x4(%ecx),%ecx
  80d47d:	0f b7 1d e0 c1 b3 00 	movzwl 0xb3c1e0,%ebx
  80d484:	89 ce                	mov    %ecx,%esi
  80d486:	29 de                	sub    %ebx,%esi
  80d488:	89 f3                	mov    %esi,%ebx
  80d48a:	29 c3                	sub    %eax,%ebx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  80d48c:	85 db                	test   %ebx,%ebx
  80d48e:	7f 6a                	jg     80d4fa <tcp_receive+0x690>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  80d490:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  80d495:	74 1f                	je     80d4b6 <tcp_receive+0x64c>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  80d497:	29 c1                	sub    %eax,%ecx
  80d499:	66 89 0d e0 c1 b3 00 	mov    %cx,0xb3c1e0
            pbuf_realloc(inseg.p, inseg.len);
  80d4a0:	0f b7 c9             	movzwl %cx,%ecx
  80d4a3:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80d4a7:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d4ac:	89 04 24             	mov    %eax,(%esp)
  80d4af:	e8 e2 7c ff ff       	call   805196 <pbuf_realloc>
  80d4b4:	eb 44                	jmp    80d4fa <tcp_receive+0x690>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d4b6:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d4bb:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4bf:	89 04 24             	mov    %eax,(%esp)
  80d4c2:	e8 ec a8 ff ff       	call   807db3 <ntohs>
  80d4c7:	89 c3                	mov    %eax,%ebx
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  80d4c9:	8b 47 7c             	mov    0x7c(%edi),%eax
  80d4cc:	8b 40 10             	mov    0x10(%eax),%eax
  80d4cf:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4d3:	89 04 24             	mov    %eax,(%esp)
  80d4d6:	e8 d8 a8 ff ff       	call   807db3 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  80d4db:	31 c3                	xor    %eax,%ebx
  80d4dd:	f6 c3 03             	test   $0x3,%bl
  80d4e0:	75 18                	jne    80d4fa <tcp_receive+0x690>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  80d4e2:	8b 47 7c             	mov    0x7c(%edi),%eax
              pcb->ooseq = pcb->ooseq->next;
  80d4e5:	8b 10                	mov    (%eax),%edx
  80d4e7:	89 57 7c             	mov    %edx,0x7c(%edi)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  80d4ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d4ee:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80d4f5:	e8 78 75 ff ff       	call   804a72 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  80d4fa:	0f b7 1d e0 c1 b3 00 	movzwl 0xb3c1e0,%ebx
  80d501:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d506:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d50a:	89 04 24             	mov    %eax,(%esp)
  80d50d:	e8 a1 a8 ff ff       	call   807db3 <ntohs>
  80d512:	ba 01 00 00 00       	mov    $0x1,%edx
  80d517:	a8 01                	test   $0x1,%al
  80d519:	75 19                	jne    80d534 <tcp_receive+0x6ca>
  80d51b:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d520:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d524:	89 04 24             	mov    %eax,(%esp)
  80d527:	e8 87 a8 ff ff       	call   807db3 <ntohs>
  80d52c:	66 d1 e8             	shr    %ax
  80d52f:	89 c2                	mov    %eax,%edx
  80d531:	83 e2 01             	and    $0x1,%edx
  80d534:	8d 04 13             	lea    (%ebx,%edx,1),%eax
  80d537:	66 a3 be c1 b3 00    	mov    %ax,0xb3c1be

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  80d53d:	83 7f 10 07          	cmpl   $0x7,0x10(%edi)
  80d541:	74 06                	je     80d549 <tcp_receive+0x6df>
          pcb->rcv_nxt += tcplen;
  80d543:	0f b7 d0             	movzwl %ax,%edx
  80d546:	01 57 24             	add    %edx,0x24(%edi)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  80d549:	0f b7 57 28          	movzwl 0x28(%edi),%edx
  80d54d:	66 39 d0             	cmp    %dx,%ax
  80d550:	76 08                	jbe    80d55a <tcp_receive+0x6f0>
          pcb->rcv_wnd = 0;
  80d552:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80d558:	eb 06                	jmp    80d560 <tcp_receive+0x6f6>
        } else {
          pcb->rcv_wnd -= tcplen;
  80d55a:	29 c2                	sub    %eax,%edx
  80d55c:	66 89 57 28          	mov    %dx,0x28(%edi)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  80d560:	0f b7 57 2a          	movzwl 0x2a(%edi),%edx
  80d564:	66 39 d0             	cmp    %dx,%ax
  80d567:	76 08                	jbe    80d571 <tcp_receive+0x707>
          pcb->rcv_ann_wnd = 0;
  80d569:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80d56f:	eb 06                	jmp    80d577 <tcp_receive+0x70d>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  80d571:	29 c2                	sub    %eax,%edx
  80d573:	66 89 57 2a          	mov    %dx,0x2a(%edi)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  80d577:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d57c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d581:	74 0f                	je     80d592 <tcp_receive+0x728>
          recv_data = inseg.p;
  80d583:	a3 b8 c1 b3 00       	mov    %eax,0xb3c1b8
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  80d588:	c7 05 d8 c1 b3 00 00 	movl   $0x0,0xb3c1d8
  80d58f:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  80d592:	a1 e4 c1 b3 00       	mov    0xb3c1e4,%eax
  80d597:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d59b:	89 04 24             	mov    %eax,(%esp)
  80d59e:	e8 10 a8 ff ff       	call   807db3 <ntohs>
  80d5a3:	a8 01                	test   $0x1,%al
  80d5a5:	0f 84 cb 01 00 00    	je     80d776 <tcp_receive+0x90c>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  80d5ab:	c6 05 bc c1 b3 00 20 	movb   $0x20,0xb3c1bc
  80d5b2:	e9 bf 01 00 00       	jmp    80d776 <tcp_receive+0x90c>
           is now in sequence. */
        while (pcb->ooseq != NULL &&
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  80d5b7:	89 35 c8 c1 b3 00    	mov    %esi,0xb3c1c8

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  80d5bd:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d5c1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80d5c4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5c8:	89 04 24             	mov    %eax,(%esp)
  80d5cb:	e8 e3 a7 ff ff       	call   807db3 <ntohs>
  80d5d0:	ba 01 00 00 00       	mov    $0x1,%edx
  80d5d5:	a8 01                	test   $0x1,%al
  80d5d7:	75 17                	jne    80d5f0 <tcp_receive+0x786>
  80d5d9:	8b 43 10             	mov    0x10(%ebx),%eax
  80d5dc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d5e0:	89 04 24             	mov    %eax,(%esp)
  80d5e3:	e8 cb a7 ff ff       	call   807db3 <ntohs>
  80d5e8:	66 d1 e8             	shr    %ax
  80d5eb:	89 c2                	mov    %eax,%edx
  80d5ed:	83 e2 01             	and    $0x1,%edx
  80d5f0:	03 55 e4             	add    -0x1c(%ebp),%edx
  80d5f3:	01 d6                	add    %edx,%esi
  80d5f5:	89 77 24             	mov    %esi,0x24(%edi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  80d5f8:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80d5fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d5ff:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d603:	8b 43 10             	mov    0x10(%ebx),%eax
  80d606:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d60a:	89 04 24             	mov    %eax,(%esp)
  80d60d:	e8 a1 a7 ff ff       	call   807db3 <ntohs>
  80d612:	ba 01 00 00 00       	mov    $0x1,%edx
  80d617:	a8 01                	test   $0x1,%al
  80d619:	75 17                	jne    80d632 <tcp_receive+0x7c8>
  80d61b:	8b 43 10             	mov    0x10(%ebx),%eax
  80d61e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d622:	89 04 24             	mov    %eax,(%esp)
  80d625:	e8 89 a7 ff ff       	call   807db3 <ntohs>
  80d62a:	66 d1 e8             	shr    %ax
  80d62d:	89 c2                	mov    %eax,%edx
  80d62f:	83 e2 01             	and    $0x1,%edx
  80d632:	01 d6                	add    %edx,%esi
  80d634:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d637:	7d 08                	jge    80d641 <tcp_receive+0x7d7>
            pcb->rcv_wnd = 0;
  80d639:	66 c7 47 28 00 00    	movw   $0x0,0x28(%edi)
  80d63f:	eb 45                	jmp    80d686 <tcp_receive+0x81c>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  80d641:	0f b7 77 28          	movzwl 0x28(%edi),%esi
  80d645:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d649:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d64d:	8b 43 10             	mov    0x10(%ebx),%eax
  80d650:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d654:	89 04 24             	mov    %eax,(%esp)
  80d657:	e8 57 a7 ff ff       	call   807db3 <ntohs>
  80d65c:	ba 01 00 00 00       	mov    $0x1,%edx
  80d661:	a8 01                	test   $0x1,%al
  80d663:	75 17                	jne    80d67c <tcp_receive+0x812>
  80d665:	8b 43 10             	mov    0x10(%ebx),%eax
  80d668:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d66c:	89 04 24             	mov    %eax,(%esp)
  80d66f:	e8 3f a7 ff ff       	call   807db3 <ntohs>
  80d674:	66 d1 e8             	shr    %ax
  80d677:	89 c2                	mov    %eax,%edx
  80d679:	83 e2 01             	and    $0x1,%edx
  80d67c:	66 2b 75 e4          	sub    -0x1c(%ebp),%si
  80d680:	29 d6                	sub    %edx,%esi
  80d682:	66 89 77 28          	mov    %si,0x28(%edi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  80d686:	0f b7 47 2a          	movzwl 0x2a(%edi),%eax
  80d68a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d68d:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d691:	8b 43 10             	mov    0x10(%ebx),%eax
  80d694:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d698:	89 04 24             	mov    %eax,(%esp)
  80d69b:	e8 13 a7 ff ff       	call   807db3 <ntohs>
  80d6a0:	ba 01 00 00 00       	mov    $0x1,%edx
  80d6a5:	a8 01                	test   $0x1,%al
  80d6a7:	75 17                	jne    80d6c0 <tcp_receive+0x856>
  80d6a9:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6ac:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6b0:	89 04 24             	mov    %eax,(%esp)
  80d6b3:	e8 fb a6 ff ff       	call   807db3 <ntohs>
  80d6b8:	66 d1 e8             	shr    %ax
  80d6bb:	89 c2                	mov    %eax,%edx
  80d6bd:	83 e2 01             	and    $0x1,%edx
  80d6c0:	01 d6                	add    %edx,%esi
  80d6c2:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
  80d6c5:	7d 08                	jge    80d6cf <tcp_receive+0x865>
            pcb->rcv_ann_wnd = 0;
  80d6c7:	66 c7 47 2a 00 00    	movw   $0x0,0x2a(%edi)
  80d6cd:	eb 45                	jmp    80d714 <tcp_receive+0x8aa>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  80d6cf:	0f b7 77 2a          	movzwl 0x2a(%edi),%esi
  80d6d3:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d6d7:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  80d6db:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6de:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6e2:	89 04 24             	mov    %eax,(%esp)
  80d6e5:	e8 c9 a6 ff ff       	call   807db3 <ntohs>
  80d6ea:	ba 01 00 00 00       	mov    $0x1,%edx
  80d6ef:	a8 01                	test   $0x1,%al
  80d6f1:	75 17                	jne    80d70a <tcp_receive+0x8a0>
  80d6f3:	8b 43 10             	mov    0x10(%ebx),%eax
  80d6f6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d6fa:	89 04 24             	mov    %eax,(%esp)
  80d6fd:	e8 b1 a6 ff ff       	call   807db3 <ntohs>
  80d702:	66 d1 e8             	shr    %ax
  80d705:	89 c2                	mov    %eax,%edx
  80d707:	83 e2 01             	and    $0x1,%edx
  80d70a:	66 2b 75 e4          	sub    -0x1c(%ebp),%si
  80d70e:	29 d6                	sub    %edx,%esi
  80d710:	66 89 77 2a          	mov    %si,0x2a(%edi)
          }

          if (cseg->p->tot_len > 0) {
  80d714:	8b 43 04             	mov    0x4(%ebx),%eax
  80d717:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  80d71c:	74 24                	je     80d742 <tcp_receive+0x8d8>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  80d71e:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80d724:	85 d2                	test   %edx,%edx
  80d726:	74 0e                	je     80d736 <tcp_receive+0x8cc>
              pbuf_cat(recv_data, cseg->p);
  80d728:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d72c:	89 14 24             	mov    %edx,(%esp)
  80d72f:	e8 af 7b ff ff       	call   8052e3 <pbuf_cat>
  80d734:	eb 05                	jmp    80d73b <tcp_receive+0x8d1>
            } else {
              recv_data = cseg->p;
  80d736:	a3 b8 c1 b3 00       	mov    %eax,0xb3c1b8
            }
            cseg->p = NULL;
  80d73b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  80d742:	8b 43 10             	mov    0x10(%ebx),%eax
  80d745:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d749:	89 04 24             	mov    %eax,(%esp)
  80d74c:	e8 62 a6 ff ff       	call   807db3 <ntohs>
  80d751:	a8 01                	test   $0x1,%al
  80d753:	74 14                	je     80d769 <tcp_receive+0x8ff>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  80d755:	c6 05 bc c1 b3 00 20 	movb   $0x20,0xb3c1bc
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  80d75c:	83 7f 10 04          	cmpl   $0x4,0x10(%edi)
  80d760:	75 07                	jne    80d769 <tcp_receive+0x8ff>
              pcb->state = CLOSE_WAIT;
  80d762:	c7 47 10 07 00 00 00 	movl   $0x7,0x10(%edi)
            } 
          }


          pcb->ooseq = cseg->next;
  80d769:	8b 03                	mov    (%ebx),%eax
  80d76b:	89 47 7c             	mov    %eax,0x7c(%edi)
          tcp_seg_free(cseg);
  80d76e:	89 1c 24             	mov    %ebx,(%esp)
  80d771:	e8 83 86 ff ff       	call   805df9 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d776:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d779:	85 db                	test   %ebx,%ebx
  80d77b:	74 0f                	je     80d78c <tcp_receive+0x922>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  80d77d:	8b 43 10             	mov    0x10(%ebx),%eax
  80d780:	8b 70 04             	mov    0x4(%eax),%esi
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  80d783:	3b 77 24             	cmp    0x24(%edi),%esi
  80d786:	0f 84 2b fe ff ff    	je     80d5b7 <tcp_receive+0x74d>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d78c:	0f b6 47 20          	movzbl 0x20(%edi),%eax
  80d790:	a8 01                	test   $0x1,%al
  80d792:	74 1b                	je     80d7af <tcp_receive+0x945>
  80d794:	83 e0 fe             	and    $0xfffffffe,%eax
  80d797:	83 c8 02             	or     $0x2,%eax
  80d79a:	88 47 20             	mov    %al,0x20(%edi)
  80d79d:	89 3c 24             	mov    %edi,(%esp)
  80d7a0:	e8 ec af ff ff       	call   808791 <tcp_output>
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d7a5:	b8 01 00 00 00       	mov    $0x1,%eax
  80d7aa:	e9 e1 02 00 00       	jmp    80da90 <tcp_receive+0xc26>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  80d7af:	83 c8 01             	or     $0x1,%eax
  80d7b2:	88 47 20             	mov    %al,0x20(%edi)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  80d7b5:	b8 01 00 00 00       	mov    $0x1,%eax
  80d7ba:	e9 d1 02 00 00       	jmp    80da90 <tcp_receive+0xc26>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  80d7bf:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80d7c3:	89 3c 24             	mov    %edi,(%esp)
  80d7c6:	e8 c6 af ff ff       	call   808791 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  80d7cb:	8b 5f 7c             	mov    0x7c(%edi),%ebx
  80d7ce:	85 db                	test   %ebx,%ebx
  80d7d0:	75 19                	jne    80d7eb <tcp_receive+0x981>
          pcb->ooseq = tcp_seg_copy(&inseg);
  80d7d2:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d7d9:	e8 9b 86 ff ff       	call   805e79 <tcp_seg_copy>
  80d7de:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d7e1:	b8 00 00 00 00       	mov    $0x0,%eax
  80d7e6:	e9 a5 02 00 00       	jmp    80da90 <tcp_receive+0xc26>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d7eb:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d7f1:	8d 41 ff             	lea    -0x1(%ecx),%eax
  80d7f4:	8d 51 01             	lea    0x1(%ecx),%edx
  80d7f7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80d7fa:	be 00 00 00 00       	mov    $0x0,%esi
  80d7ff:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80d802:	89 c7                	mov    %eax,%edi
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  80d804:	8b 43 10             	mov    0x10(%ebx),%eax
  80d807:	8b 40 04             	mov    0x4(%eax),%eax
  80d80a:	39 c8                	cmp    %ecx,%eax
  80d80c:	0f 85 9e 00 00 00    	jne    80d8b0 <tcp_receive+0xa46>
  80d812:	8b 7d e0             	mov    -0x20(%ebp),%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d815:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  80d81a:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  80d81e:	66 39 0d e0 c1 b3 00 	cmp    %cx,0xb3c1e0
  80d825:	0f 86 65 02 00 00    	jbe    80da90 <tcp_receive+0xc26>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  80d82b:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d832:	e8 42 86 ff ff       	call   805e79 <tcp_seg_copy>
  80d837:	89 c1                	mov    %eax,%ecx
  80d839:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                if (cseg != NULL) {
  80d83c:	85 c0                	test   %eax,%eax
  80d83e:	0f 84 1d 02 00 00    	je     80da61 <tcp_receive+0xbf7>
                  cseg->next = next->next;
  80d844:	8b 03                	mov    (%ebx),%eax
  80d846:	89 01                	mov    %eax,(%ecx)
                  if (prev != NULL) {
  80d848:	85 f6                	test   %esi,%esi
  80d84a:	74 04                	je     80d850 <tcp_receive+0x9e6>
                    prev->next = cseg;
  80d84c:	89 0e                	mov    %ecx,(%esi)
  80d84e:	eb 06                	jmp    80d856 <tcp_receive+0x9ec>
                  } else {
                    pcb->ooseq = cseg;
  80d850:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d853:	89 47 7c             	mov    %eax,0x7c(%edi)
                  }
                  tcp_seg_free(next);
  80d856:	89 1c 24             	mov    %ebx,(%esp)
  80d859:	e8 9b 85 ff ff       	call   805df9 <tcp_seg_free>
                  if (cseg->next != NULL) {
  80d85e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80d861:	8b 06                	mov    (%esi),%eax
  80d863:	85 c0                	test   %eax,%eax
  80d865:	0f 84 fd 01 00 00    	je     80da68 <tcp_receive+0xbfe>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d86b:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80d871:	8b 40 10             	mov    0x10(%eax),%eax
  80d874:	8b 48 04             	mov    0x4(%eax),%ecx
  80d877:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80d87b:	29 cb                	sub    %ecx,%ebx
  80d87d:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d87f:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  80d884:	85 db                	test   %ebx,%ebx
  80d886:	0f 8e 04 02 00 00    	jle    80da90 <tcp_receive+0xc26>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  80d88c:	89 c8                	mov    %ecx,%eax
  80d88e:	29 d0                	sub    %edx,%eax
  80d890:	66 89 46 0c          	mov    %ax,0xc(%esi)
                      pbuf_realloc(cseg->p, cseg->len);
  80d894:	0f b7 c0             	movzwl %ax,%eax
  80d897:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d89b:	8b 46 04             	mov    0x4(%esi),%eax
  80d89e:	89 04 24             	mov    %eax,(%esp)
  80d8a1:	e8 f0 78 ff ff       	call   805196 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d8a6:	b8 00 00 00 00       	mov    $0x0,%eax
  80d8ab:	e9 e0 01 00 00       	jmp    80da90 <tcp_receive+0xc26>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  80d8b0:	85 f6                	test   %esi,%esi
  80d8b2:	75 59                	jne    80d90d <tcp_receive+0xaa3>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  80d8b4:	39 c1                	cmp    %eax,%ecx
  80d8b6:	0f 89 f2 00 00 00    	jns    80d9ae <tcp_receive+0xb44>
  80d8bc:	8b 7d e0             	mov    -0x20(%ebp),%edi
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d8bf:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d8c6:	01 ca                	add    %ecx,%edx
  80d8c8:	29 c2                	sub    %eax,%edx
  80d8ca:	85 d2                	test   %edx,%edx
  80d8cc:	7e 1c                	jle    80d8ea <tcp_receive+0xa80>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d8ce:	29 c8                	sub    %ecx,%eax
  80d8d0:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
                    pbuf_realloc(inseg.p, inseg.len);
  80d8d6:	0f b7 c0             	movzwl %ax,%eax
  80d8d9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d8dd:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d8e2:	89 04 24             	mov    %eax,(%esp)
  80d8e5:	e8 ac 78 ff ff       	call   805196 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  80d8ea:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d8f1:	e8 83 85 ff ff       	call   805e79 <tcp_seg_copy>
                  if (cseg != NULL) {
  80d8f6:	85 c0                	test   %eax,%eax
  80d8f8:	0f 84 71 01 00 00    	je     80da6f <tcp_receive+0xc05>
                    cseg->next = next;
  80d8fe:	89 18                	mov    %ebx,(%eax)
                    pcb->ooseq = cseg;
  80d900:	89 47 7c             	mov    %eax,0x7c(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d903:	b8 00 00 00 00       	mov    $0x0,%eax
  80d908:	e9 83 01 00 00       	jmp    80da90 <tcp_receive+0xc26>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  80d90d:	8b 56 10             	mov    0x10(%esi),%edx
  80d910:	3b 7a 04             	cmp    0x4(%edx),%edi
  80d913:	0f 88 95 00 00 00    	js     80d9ae <tcp_receive+0xb44>
  80d919:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d91c:	29 c2                	sub    %eax,%edx
  80d91e:	85 d2                	test   %edx,%edx
  80d920:	0f 8f 88 00 00 00    	jg     80d9ae <tcp_receive+0xb44>
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  80d926:	0f b7 15 e0 c1 b3 00 	movzwl 0xb3c1e0,%edx
  80d92d:	01 ca                	add    %ecx,%edx
  80d92f:	29 c2                	sub    %eax,%edx
  80d931:	85 d2                	test   %edx,%edx
  80d933:	7e 1c                	jle    80d951 <tcp_receive+0xae7>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  80d935:	29 c8                	sub    %ecx,%eax
  80d937:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
                  pbuf_realloc(inseg.p, inseg.len);
  80d93d:	0f b7 c0             	movzwl %ax,%eax
  80d940:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d944:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80d949:	89 04 24             	mov    %eax,(%esp)
  80d94c:	e8 45 78 ff ff       	call   805196 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  80d951:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d958:	e8 1c 85 ff ff       	call   805e79 <tcp_seg_copy>
                if (cseg != NULL) {
  80d95d:	85 c0                	test   %eax,%eax
  80d95f:	0f 84 11 01 00 00    	je     80da76 <tcp_receive+0xc0c>
                  cseg->next = next;
  80d965:	89 18                	mov    %ebx,(%eax)
                  prev->next = cseg;
  80d967:	89 06                	mov    %eax,(%esi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d969:	8b 46 10             	mov    0x10(%esi),%eax
  80d96c:	8b 50 04             	mov    0x4(%eax),%edx
  80d96f:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
  80d975:	0f b7 5e 0c          	movzwl 0xc(%esi),%ebx
  80d979:	29 cb                	sub    %ecx,%ebx
  80d97b:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d97d:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  80d982:	85 db                	test   %ebx,%ebx
  80d984:	0f 8e 06 01 00 00    	jle    80da90 <tcp_receive+0xc26>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  80d98a:	89 c8                	mov    %ecx,%eax
  80d98c:	29 d0                	sub    %edx,%eax
  80d98e:	66 89 46 0c          	mov    %ax,0xc(%esi)
                    pbuf_realloc(prev->p, prev->len);
  80d992:	0f b7 c0             	movzwl %ax,%eax
  80d995:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d999:	8b 46 04             	mov    0x4(%esi),%eax
  80d99c:	89 04 24             	mov    %eax,(%esp)
  80d99f:	e8 f2 77 ff ff       	call   805196 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80d9a9:	e9 e2 00 00 00       	jmp    80da90 <tcp_receive+0xc26>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d9ae:	8b 13                	mov    (%ebx),%edx
  80d9b0:	85 d2                	test   %edx,%edx
  80d9b2:	75 62                	jne    80da16 <tcp_receive+0xbac>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
  80d9b4:	29 c1                	sub    %eax,%ecx
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80d9b6:	85 c9                	test   %ecx,%ecx
  80d9b8:	0f 8e bf 00 00 00    	jle    80da7d <tcp_receive+0xc13>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  80d9be:	c7 04 24 d4 c1 b3 00 	movl   $0xb3c1d4,(%esp)
  80d9c5:	e8 af 84 ff ff       	call   805e79 <tcp_seg_copy>
  80d9ca:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  80d9cc:	85 c0                	test   %eax,%eax
  80d9ce:	0f 84 b0 00 00 00    	je     80da84 <tcp_receive+0xc1a>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d9d4:	8b 43 10             	mov    0x10(%ebx),%eax
  80d9d7:	8b 50 04             	mov    0x4(%eax),%edx
  80d9da:	8b 0d c8 c1 b3 00    	mov    0xb3c1c8,%ecx
  80d9e0:	0f b7 73 0c          	movzwl 0xc(%ebx),%esi
  80d9e4:	29 ce                	sub    %ecx,%esi
  80d9e6:	01 d6                	add    %edx,%esi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80d9e8:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  80d9ed:	85 f6                	test   %esi,%esi
  80d9ef:	0f 8e 9b 00 00 00    	jle    80da90 <tcp_receive+0xc26>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  80d9f5:	89 c8                	mov    %ecx,%eax
  80d9f7:	29 d0                	sub    %edx,%eax
  80d9f9:	66 89 43 0c          	mov    %ax,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  80d9fd:	0f b7 c0             	movzwl %ax,%eax
  80da00:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da04:	8b 43 04             	mov    0x4(%ebx),%eax
  80da07:	89 04 24             	mov    %eax,(%esp)
  80da0a:	e8 87 77 ff ff       	call   805196 <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80da0f:	b8 00 00 00 00       	mov    $0x0,%eax
  80da14:	eb 7a                	jmp    80da90 <tcp_receive+0xc26>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  80da16:	89 de                	mov    %ebx,%esi
  80da18:	89 d3                	mov    %edx,%ebx
  80da1a:	e9 e5 fd ff ff       	jmp    80d804 <tcp_receive+0x99a>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  80da1f:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80da23:	89 3c 24             	mov    %edi,(%esp)
  80da26:	e8 66 ad ff ff       	call   808791 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80da2b:	b8 00 00 00 00       	mov    $0x0,%eax
  80da30:	eb 5e                	jmp    80da90 <tcp_receive+0xc26>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  80da32:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80da38:	8b 47 24             	mov    0x24(%edi),%eax
  80da3b:	39 c2                	cmp    %eax,%edx
  80da3d:	78 0f                	js     80da4e <tcp_receive+0xbe4>
  80da3f:	83 c2 01             	add    $0x1,%edx
  80da42:	29 c2                	sub    %eax,%edx
  80da44:	0f b7 47 28          	movzwl 0x28(%edi),%eax
  80da48:	29 c2                	sub    %eax,%edx
  80da4a:	85 d2                	test   %edx,%edx
  80da4c:	7e 3d                	jle    80da8b <tcp_receive+0xc21>
      tcp_ack_now(pcb);
  80da4e:	80 4f 20 02          	orb    $0x2,0x20(%edi)
  80da52:	89 3c 24             	mov    %edi,(%esp)
  80da55:	e8 37 ad ff ff       	call   808791 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  80da5a:	b8 00 00 00 00       	mov    $0x0,%eax
  80da5f:	eb 2f                	jmp    80da90 <tcp_receive+0xc26>
  80da61:	b8 00 00 00 00       	mov    $0x0,%eax
  80da66:	eb 28                	jmp    80da90 <tcp_receive+0xc26>
  80da68:	b8 00 00 00 00       	mov    $0x0,%eax
  80da6d:	eb 21                	jmp    80da90 <tcp_receive+0xc26>
  80da6f:	b8 00 00 00 00       	mov    $0x0,%eax
  80da74:	eb 1a                	jmp    80da90 <tcp_receive+0xc26>
  80da76:	b8 00 00 00 00       	mov    $0x0,%eax
  80da7b:	eb 13                	jmp    80da90 <tcp_receive+0xc26>
  80da7d:	b8 00 00 00 00       	mov    $0x0,%eax
  80da82:	eb 0c                	jmp    80da90 <tcp_receive+0xc26>
  80da84:	b8 00 00 00 00       	mov    $0x0,%eax
  80da89:	eb 05                	jmp    80da90 <tcp_receive+0xc26>
  80da8b:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  80da90:	83 c4 2c             	add    $0x2c,%esp
  80da93:	5b                   	pop    %ebx
  80da94:	5e                   	pop    %esi
  80da95:	5f                   	pop    %edi
  80da96:	5d                   	pop    %ebp
  80da97:	c3                   	ret    

0080da98 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  80da98:	55                   	push   %ebp
  80da99:	89 e5                	mov    %esp,%ebp
  80da9b:	57                   	push   %edi
  80da9c:	56                   	push   %esi
  80da9d:	53                   	push   %ebx
  80da9e:	83 ec 4c             	sub    $0x4c,%esp
  80daa1:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  80daa4:	8b 5e 04             	mov    0x4(%esi),%ebx
  80daa7:	89 1d cc c1 b3 00    	mov    %ebx,0xb3c1cc
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  80daad:	0f b7 03             	movzwl (%ebx),%eax
  80dab0:	89 04 24             	mov    %eax,(%esp)
  80dab3:	e8 fb a2 ff ff       	call   807db3 <ntohs>
  80dab8:	66 c1 e8 08          	shr    $0x8,%ax
  80dabc:	83 e0 0f             	and    $0xf,%eax
  80dabf:	8d 04 83             	lea    (%ebx,%eax,4),%eax
  80dac2:	a3 d0 c1 b3 00       	mov    %eax,0xb3c1d0
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  80dac7:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80dacc:	0f b7 00             	movzwl (%eax),%eax
  80dacf:	89 04 24             	mov    %eax,(%esp)
  80dad2:	e8 dc a2 ff ff       	call   807db3 <ntohs>
  80dad7:	66 c1 e8 06          	shr    $0x6,%ax
  80dadb:	83 e0 3c             	and    $0x3c,%eax
  80dade:	f7 d8                	neg    %eax
  80dae0:	98                   	cwtl   
  80dae1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dae5:	89 34 24             	mov    %esi,(%esp)
  80dae8:	e8 53 72 ff ff       	call   804d40 <pbuf_header>
  80daed:	84 c0                	test   %al,%al
  80daef:	75 07                	jne    80daf8 <tcp_input+0x60>
  80daf1:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  80daf6:	77 0d                	ja     80db05 <tcp_input+0x6d>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80daf8:	89 34 24             	mov    %esi,(%esp)
  80dafb:	e8 24 73 ff ff       	call   804e24 <pbuf_free>
    return;
  80db00:	e9 cc 0c 00 00       	jmp    80e7d1 <tcp_input+0xd39>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80db05:	8b 45 0c             	mov    0xc(%ebp),%eax
  80db08:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db0c:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80db11:	83 c0 10             	add    $0x10,%eax
  80db14:	89 04 24             	mov    %eax,(%esp)
  80db17:	e8 a5 8f ff ff       	call   806ac1 <ip_addr_isbroadcast>
  80db1c:	84 c0                	test   %al,%al
  80db1e:	75 26                	jne    80db46 <tcp_input+0xae>
      ip_addr_ismulticast(&(iphdr->dest))) {
  80db20:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80db25:	8b 58 10             	mov    0x10(%eax),%ebx
  80db28:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80db2f:	e8 c6 a4 ff ff       	call   807ffa <ntohl>
  80db34:	21 c3                	and    %eax,%ebx
  80db36:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80db3d:	e8 b8 a4 ff ff       	call   807ffa <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  80db42:	39 c3                	cmp    %eax,%ebx
  80db44:	75 0f                	jne    80db55 <tcp_input+0xbd>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db46:	89 34 24             	mov    %esi,(%esp)
  80db49:	e8 d6 72 ff ff       	call   804e24 <pbuf_free>
    return;
  80db4e:	66 90                	xchg   %ax,%ax
  80db50:	e9 7c 0c 00 00       	jmp    80e7d1 <tcp_input+0xd39>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  80db55:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80db5a:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80db5e:	89 54 24 10          	mov    %edx,0x10(%esp)
  80db62:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80db69:	00 
  80db6a:	8d 50 10             	lea    0x10(%eax),%edx
  80db6d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80db71:	83 c0 0c             	add    $0xc,%eax
  80db74:	89 44 24 04          	mov    %eax,0x4(%esp)
  80db78:	89 34 24             	mov    %esi,(%esp)
  80db7b:	e8 de 9e ff ff       	call   807a5e <inet_chksum_pseudo>
  80db80:	66 85 c0             	test   %ax,%ax
  80db83:	74 0d                	je     80db92 <tcp_input+0xfa>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80db85:	89 34 24             	mov    %esi,(%esp)
  80db88:	e8 97 72 ff ff       	call   804e24 <pbuf_free>
    return;
  80db8d:	e9 3f 0c 00 00       	jmp    80e7d1 <tcp_input+0xd39>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  80db92:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80db97:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80db9b:	89 04 24             	mov    %eax,(%esp)
  80db9e:	e8 10 a2 ff ff       	call   807db3 <ntohs>
  80dba3:	66 c1 e8 0c          	shr    $0xc,%ax
  if(pbuf_header(p, -(hdrlen * 4))){
  80dba7:	f7 d8                	neg    %eax
  80dba9:	c1 e0 02             	shl    $0x2,%eax
  80dbac:	98                   	cwtl   
  80dbad:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dbb1:	89 34 24             	mov    %esi,(%esp)
  80dbb4:	e8 87 71 ff ff       	call   804d40 <pbuf_header>
  80dbb9:	84 c0                	test   %al,%al
  80dbbb:	74 0d                	je     80dbca <tcp_input+0x132>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  80dbbd:	89 34 24             	mov    %esi,(%esp)
  80dbc0:	e8 5f 72 ff ff       	call   804e24 <pbuf_free>
    return;
  80dbc5:	e9 07 0c 00 00       	jmp    80e7d1 <tcp_input+0xd39>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  80dbca:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbd0:	0f b7 03             	movzwl (%ebx),%eax
  80dbd3:	89 04 24             	mov    %eax,(%esp)
  80dbd6:	e8 d8 a1 ff ff       	call   807db3 <ntohs>
  80dbdb:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  80dbde:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbe4:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80dbe8:	89 04 24             	mov    %eax,(%esp)
  80dbeb:	e8 c3 a1 ff ff       	call   807db3 <ntohs>
  80dbf0:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  80dbf4:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dbfa:	8b 43 04             	mov    0x4(%ebx),%eax
  80dbfd:	89 04 24             	mov    %eax,(%esp)
  80dc00:	e8 f5 a3 ff ff       	call   807ffa <ntohl>
  80dc05:	89 43 04             	mov    %eax,0x4(%ebx)
  80dc08:	a3 c8 c1 b3 00       	mov    %eax,0xb3c1c8
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  80dc0d:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dc13:	8b 43 08             	mov    0x8(%ebx),%eax
  80dc16:	89 04 24             	mov    %eax,(%esp)
  80dc19:	e8 dc a3 ff ff       	call   807ffa <ntohl>
  80dc1e:	89 43 08             	mov    %eax,0x8(%ebx)
  80dc21:	a3 c4 c1 b3 00       	mov    %eax,0xb3c1c4
  tcphdr->wnd = ntohs(tcphdr->wnd);
  80dc26:	8b 1d d0 c1 b3 00    	mov    0xb3c1d0,%ebx
  80dc2c:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80dc30:	89 04 24             	mov    %eax,(%esp)
  80dc33:	e8 7b a1 ff ff       	call   807db3 <ntohs>
  80dc38:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  80dc3c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80dc41:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80dc45:	89 04 24             	mov    %eax,(%esp)
  80dc48:	e8 66 a1 ff ff       	call   807db3 <ntohs>
  80dc4d:	89 c1                	mov    %eax,%ecx
  80dc4f:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80dc53:	83 e0 3f             	and    $0x3f,%eax
  80dc56:	a2 c0 c1 b3 00       	mov    %al,0xb3c1c0
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  80dc5b:	f6 c1 03             	test   $0x3,%cl
  80dc5e:	0f 95 c0             	setne  %al
  80dc61:	0f b6 c0             	movzbl %al,%eax
  80dc64:	66 03 46 08          	add    0x8(%esi),%ax
  80dc68:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  80dc6c:	66 a3 be c1 b3 00    	mov    %ax,0xb3c1be
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc72:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80dc77:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  80dc7a:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dc80:	8b 0d cc c1 b3 00    	mov    0xb3c1cc,%ecx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc86:	89 c3                	mov    %eax,%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  80dc88:	bf 00 00 00 00       	mov    $0x0,%edi

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dc8d:	e9 ea 00 00 00       	jmp    80dd7c <tcp_input+0x2e4>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  80dc92:	8b 43 10             	mov    0x10(%ebx),%eax
  80dc95:	85 c0                	test   %eax,%eax
  80dc97:	75 1c                	jne    80dcb5 <tcp_input+0x21d>
  80dc99:	c7 44 24 08 c4 40 81 	movl   $0x8140c4,0x8(%esp)
  80dca0:	00 
  80dca1:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80dca8:	00 
  80dca9:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80dcb0:	e8 e5 13 00 00       	call   80f09a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  80dcb5:	83 f8 0a             	cmp    $0xa,%eax
  80dcb8:	75 1c                	jne    80dcd6 <tcp_input+0x23e>
  80dcba:	c7 44 24 08 ec 40 81 	movl   $0x8140ec,0x8(%esp)
  80dcc1:	00 
  80dcc2:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  80dcc9:	00 
  80dcca:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80dcd1:	e8 c4 13 00 00       	call   80f09a <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  80dcd6:	83 f8 01             	cmp    $0x1,%eax
  80dcd9:	75 1c                	jne    80dcf7 <tcp_input+0x25f>
  80dcdb:	c7 44 24 08 18 41 81 	movl   $0x814118,0x8(%esp)
  80dce2:	00 
  80dce3:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  80dcea:	00 
  80dceb:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80dcf2:	e8 a3 13 00 00       	call   80f09a <_panic>
    if (pcb->remote_port == tcphdr->src &&
  80dcf7:	0f b7 02             	movzwl (%edx),%eax
  80dcfa:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80dcfe:	75 77                	jne    80dd77 <tcp_input+0x2df>
  80dd00:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dd04:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80dd08:	75 6d                	jne    80dd77 <tcp_input+0x2df>
       pcb->local_port == tcphdr->dest &&
  80dd0a:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dd0d:	39 43 04             	cmp    %eax,0x4(%ebx)
  80dd10:	75 65                	jne    80dd77 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80dd12:	8b 41 10             	mov    0x10(%ecx),%eax
  80dd15:	39 03                	cmp    %eax,(%ebx)
  80dd17:	75 5e                	jne    80dd77 <tcp_input+0x2df>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  80dd19:	8b 43 0c             	mov    0xc(%ebx),%eax
  80dd1c:	39 d8                	cmp    %ebx,%eax
  80dd1e:	75 1c                	jne    80dd3c <tcp_input+0x2a4>
  80dd20:	c7 44 24 08 40 41 81 	movl   $0x814140,0x8(%esp)
  80dd27:	00 
  80dd28:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  80dd2f:	00 
  80dd30:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80dd37:	e8 5e 13 00 00       	call   80f09a <_panic>
      if (prev != NULL) {
  80dd3c:	85 ff                	test   %edi,%edi
  80dd3e:	0f 84 06 0a 00 00    	je     80e74a <tcp_input+0xcb2>
        prev->next = pcb->next;
  80dd44:	89 47 0c             	mov    %eax,0xc(%edi)
        pcb->next = tcp_active_pcbs;
  80dd47:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80dd4a:	89 43 0c             	mov    %eax,0xc(%ebx)
        tcp_active_pcbs = pcb;
  80dd4d:	89 1d 5c c2 b3 00    	mov    %ebx,0xb3c25c
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  80dd53:	39 d8                	cmp    %ebx,%eax
  80dd55:	0f 85 ef 09 00 00    	jne    80e74a <tcp_input+0xcb2>
  80dd5b:	c7 44 24 08 6c 41 81 	movl   $0x81416c,0x8(%esp)
  80dd62:	00 
  80dd63:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  80dd6a:	00 
  80dd6b:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80dd72:	e8 23 13 00 00       	call   80f09a <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd77:	89 df                	mov    %ebx,%edi
  80dd79:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dd7c:	85 db                	test   %ebx,%ebx
  80dd7e:	0f 85 0e ff ff ff    	jne    80dc92 <tcp_input+0x1fa>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80dd84:	8b 1d 70 c2 b3 00    	mov    0xb3c270,%ebx
  80dd8a:	e9 85 00 00 00       	jmp    80de14 <tcp_input+0x37c>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80dd8f:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80dd93:	74 1c                	je     80ddb1 <tcp_input+0x319>
  80dd95:	c7 44 24 08 98 41 81 	movl   $0x814198,0x8(%esp)
  80dd9c:	00 
  80dd9d:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  80dda4:	00 
  80dda5:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80ddac:	e8 e9 12 00 00       	call   80f09a <_panic>
      if (pcb->remote_port == tcphdr->src &&
  80ddb1:	0f b7 02             	movzwl (%edx),%eax
  80ddb4:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  80ddb8:	75 57                	jne    80de11 <tcp_input+0x379>
  80ddba:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80ddbe:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80ddc2:	75 4d                	jne    80de11 <tcp_input+0x379>
         pcb->local_port == tcphdr->dest &&
  80ddc4:	8b 41 0c             	mov    0xc(%ecx),%eax
  80ddc7:	39 43 04             	cmp    %eax,0x4(%ebx)
  80ddca:	75 45                	jne    80de11 <tcp_input+0x379>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  80ddcc:	8b 41 10             	mov    0x10(%ecx),%eax
  80ddcf:	39 03                	cmp    %eax,(%ebx)
  80ddd1:	75 3e                	jne    80de11 <tcp_input+0x379>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  80ddd3:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80ddd7:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80dddd:	89 c2                	mov    %eax,%edx
  80dddf:	2b 53 24             	sub    0x24(%ebx),%edx
  80dde2:	85 d2                	test   %edx,%edx
  80dde4:	7e 03                	jle    80dde9 <tcp_input+0x351>
    pcb->rcv_nxt = seqno + tcplen;
  80dde6:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  80dde9:	66 83 7d d6 00       	cmpw   $0x0,-0x2a(%ebp)
  80ddee:	74 0c                	je     80ddfc <tcp_input+0x364>
    tcp_ack_now(pcb);
  80ddf0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80ddf4:	89 1c 24             	mov    %ebx,(%esp)
  80ddf7:	e8 95 a9 ff ff       	call   808791 <tcp_output>
  }
  return tcp_output(pcb);
  80ddfc:	89 1c 24             	mov    %ebx,(%esp)
  80ddff:	e8 8d a9 ff ff       	call   808791 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  80de04:	89 34 24             	mov    %esi,(%esp)
  80de07:	e8 18 70 ff ff       	call   804e24 <pbuf_free>
        return;
  80de0c:	e9 c0 09 00 00       	jmp    80e7d1 <tcp_input+0xd39>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80de11:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80de14:	85 db                	test   %ebx,%ebx
  80de16:	0f 85 73 ff ff ff    	jne    80dd8f <tcp_input+0x2f7>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80de1c:	a1 64 c2 b3 00       	mov    0xb3c264,%eax
  80de21:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80de24:	89 c3                	mov    %eax,%ebx
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  80de26:	bf 00 00 00 00       	mov    $0x0,%edi
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80de2b:	e9 af 01 00 00       	jmp    80dfdf <tcp_input+0x547>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  80de30:	85 db                	test   %ebx,%ebx
  80de32:	74 0f                	je     80de43 <tcp_input+0x3ab>
  80de34:	8b 03                	mov    (%ebx),%eax
  80de36:	85 c0                	test   %eax,%eax
  80de38:	74 09                	je     80de43 <tcp_input+0x3ab>
  80de3a:	3b 41 10             	cmp    0x10(%ecx),%eax
  80de3d:	0f 85 97 01 00 00    	jne    80dfda <tcp_input+0x542>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  80de43:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80de47:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  80de4b:	0f 85 89 01 00 00    	jne    80dfda <tcp_input+0x542>
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  80de51:	85 ff                	test   %edi,%edi
  80de53:	74 12                	je     80de67 <tcp_input+0x3cf>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  80de55:	8b 43 0c             	mov    0xc(%ebx),%eax
  80de58:	89 47 0c             	mov    %eax,0xc(%edi)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  80de5b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80de5e:	89 43 0c             	mov    %eax,0xc(%ebx)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  80de61:	89 1d 64 c2 b3 00    	mov    %ebx,0xb3c264
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  80de67:	f6 45 d4 10          	testb  $0x10,-0x2c(%ebp)
  80de6b:	74 45                	je     80deb2 <tcp_input+0x41a>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  80de6d:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  80de72:	0f b7 0a             	movzwl (%edx),%ecx
  80de75:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80de79:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80de7d:	89 54 24 10          	mov    %edx,0x10(%esp)
  80de81:	8d 50 0c             	lea    0xc(%eax),%edx
  80de84:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80de88:	83 c0 10             	add    $0x10,%eax
  80de8b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80de8f:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  80de93:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80de99:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de9d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80dea2:	83 c0 01             	add    $0x1,%eax
  80dea5:	89 04 24             	mov    %eax,(%esp)
  80dea8:	e8 78 ad ff ff       	call   808c25 <tcp_rst>
  80dead:	e9 1b 01 00 00       	jmp    80dfcd <tcp_input+0x535>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  80deb2:	f6 45 d4 02          	testb  $0x2,-0x2c(%ebp)
  80deb6:	0f 84 11 01 00 00    	je     80dfcd <tcp_input+0x535>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  80debc:	0f b6 43 14          	movzbl 0x14(%ebx),%eax
  80dec0:	89 04 24             	mov    %eax,(%esp)
  80dec3:	e8 c2 88 ff ff       	call   80678a <tcp_alloc>
  80dec8:	89 c7                	mov    %eax,%edi
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  80deca:	85 c0                	test   %eax,%eax
  80decc:	0f 84 fb 00 00 00    	je     80dfcd <tcp_input+0x535>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  80ded2:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80ded7:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80deda:	74 05                	je     80dee1 <tcp_input+0x449>
  80dedc:	8b 50 10             	mov    0x10(%eax),%edx
  80dedf:	eb 05                	jmp    80dee6 <tcp_input+0x44e>
  80dee1:	ba 00 00 00 00       	mov    $0x0,%edx
  80dee6:	89 17                	mov    %edx,(%edi)
    npcb->local_port = pcb->local_port;
  80dee8:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  80deec:	66 89 57 1c          	mov    %dx,0x1c(%edi)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  80def0:	83 f8 f4             	cmp    $0xfffffff4,%eax
  80def3:	74 05                	je     80defa <tcp_input+0x462>
  80def5:	8b 40 0c             	mov    0xc(%eax),%eax
  80def8:	eb 05                	jmp    80deff <tcp_input+0x467>
  80defa:	b8 00 00 00 00       	mov    $0x0,%eax
  80deff:	89 47 04             	mov    %eax,0x4(%edi)
    npcb->remote_port = tcphdr->src;
  80df02:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80df08:	0f b7 02             	movzwl (%edx),%eax
  80df0b:	66 89 47 1e          	mov    %ax,0x1e(%edi)
    npcb->state = SYN_RCVD;
  80df0f:	c7 47 10 03 00 00 00 	movl   $0x3,0x10(%edi)
    npcb->rcv_nxt = seqno + 1;
  80df16:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80df1b:	8d 48 01             	lea    0x1(%eax),%ecx
  80df1e:	89 4f 24             	mov    %ecx,0x24(%edi)
    npcb->snd_wnd = tcphdr->wnd;
  80df21:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80df25:	66 89 57 5c          	mov    %dx,0x5c(%edi)
    npcb->ssthresh = npcb->snd_wnd;
  80df29:	66 89 57 50          	mov    %dx,0x50(%edi)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  80df2d:	83 e8 01             	sub    $0x1,%eax
  80df30:	89 47 60             	mov    %eax,0x60(%edi)
    npcb->callback_arg = pcb->callback_arg;
  80df33:	8b 43 18             	mov    0x18(%ebx),%eax
  80df36:	89 47 18             	mov    %eax,0x18(%edi)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  80df39:	8b 43 20             	mov    0x20(%ebx),%eax
  80df3c:	89 87 90 00 00 00    	mov    %eax,0x90(%edi)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  80df42:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80df46:	66 25 99 01          	and    $0x199,%ax
  80df4a:	66 89 47 08          	mov    %ax,0x8(%edi)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  80df4e:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80df53:	89 47 0c             	mov    %eax,0xc(%edi)
  80df56:	89 3d 5c c2 b3 00    	mov    %edi,0xb3c25c
  80df5c:	e8 41 46 ff ff       	call   8025a2 <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  80df61:	89 f8                	mov    %edi,%eax
  80df63:	e8 58 ee ff ff       	call   80cdc0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  80df68:	8d 47 04             	lea    0x4(%edi),%eax
  80df6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80df6f:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80df73:	89 04 24             	mov    %eax,(%esp)
  80df76:	e8 9e 89 ff ff       	call   806919 <tcp_eff_send_mss>
  80df7b:	66 89 47 34          	mov    %ax,0x34(%edi)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  80df7f:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80df86:	e8 35 9e ff ff       	call   807dc0 <htonl>
  80df8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  80df8e:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80df95:	00 
  80df96:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80df99:	89 44 24 14          	mov    %eax,0x14(%esp)
  80df9d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80dfa4:	00 
  80dfa5:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80dfac:	00 
  80dfad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80dfb4:	00 
  80dfb5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80dfbc:	00 
  80dfbd:	89 3c 24             	mov    %edi,(%esp)
  80dfc0:	e8 4b a0 ff ff       	call   808010 <tcp_enqueue>
    return tcp_output(npcb);
  80dfc5:	89 3c 24             	mov    %edi,(%esp)
  80dfc8:	e8 c4 a7 ff ff       	call   808791 <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  80dfcd:	89 34 24             	mov    %esi,(%esp)
  80dfd0:	e8 4f 6e ff ff       	call   804e24 <pbuf_free>
        return;
  80dfd5:	e9 f7 07 00 00       	jmp    80e7d1 <tcp_input+0xd39>
  80dfda:	89 df                	mov    %ebx,%edi
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  80dfdc:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80dfdf:	85 db                	test   %ebx,%ebx
  80dfe1:	0f 85 49 fe ff ff    	jne    80de30 <tcp_input+0x398>
  80dfe7:	e9 ae 07 00 00       	jmp    80e79a <tcp_input+0xd02>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80dfec:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80dff2:	85 c0                	test   %eax,%eax
  80dff4:	74 1e                	je     80e014 <tcp_input+0x57c>
  80dff6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80dffd:	00 
  80dffe:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e002:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e006:	8b 53 18             	mov    0x18(%ebx),%edx
  80e009:	89 14 24             	mov    %edx,(%esp)
  80e00c:	ff d0                	call   *%eax
      if (err == ERR_OK) {
  80e00e:	84 c0                	test   %al,%al
  80e010:	74 0a                	je     80e01c <tcp_input+0x584>
  80e012:	eb 14                	jmp    80e028 <tcp_input+0x590>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80e014:	89 14 24             	mov    %edx,(%esp)
  80e017:	e8 08 6e ff ff       	call   804e24 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80e01c:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80e023:	00 00 00 
  80e026:	eb 0d                	jmp    80e035 <tcp_input+0x59d>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  80e028:	89 34 24             	mov    %esi,(%esp)
  80e02b:	e8 f4 6d ff ff       	call   804e24 <pbuf_free>
        return;
  80e030:	e9 9c 07 00 00       	jmp    80e7d1 <tcp_input+0xd39>
      }
    }

    tcp_input_pcb = pcb;
  80e035:	89 1d 78 c2 b3 00    	mov    %ebx,0xb3c278
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  80e03b:	0f b6 05 c0 c1 b3 00 	movzbl 0xb3c1c0,%eax
  80e042:	a8 04                	test   $0x4,%al
  80e044:	74 64                	je     80e0aa <tcp_input+0x612>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  80e046:	8b 43 10             	mov    0x10(%ebx),%eax
  80e049:	83 f8 02             	cmp    $0x2,%eax
  80e04c:	75 0f                	jne    80e05d <tcp_input+0x5c5>
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80e04e:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e053:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e056:	74 42                	je     80e09a <tcp_input+0x602>
  80e058:	e9 38 05 00 00       	jmp    80e595 <tcp_input+0xafd>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  80e05d:	8b 15 c8 c1 b3 00    	mov    0xb3c1c8,%edx
  80e063:	2b 53 24             	sub    0x24(%ebx),%edx
  80e066:	0f 88 43 07 00 00    	js     80e7af <tcp_input+0xd17>
  80e06c:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  80e070:	29 ca                	sub    %ecx,%edx
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  80e072:	85 d2                	test   %edx,%edx
  80e074:	0f 8f 35 07 00 00    	jg     80e7af <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  80e07a:	85 c0                	test   %eax,%eax
  80e07c:	75 1c                	jne    80e09a <tcp_input+0x602>
  80e07e:	c7 44 24 08 c8 41 81 	movl   $0x8141c8,0x8(%esp)
  80e085:	00 
  80e086:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  80e08d:	00 
  80e08e:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80e095:	e8 00 10 00 00       	call   80f09a <_panic>
      recv_flags = TF_RESET;
  80e09a:	c6 05 bc c1 b3 00 08 	movb   $0x8,0xb3c1bc
      pcb->flags &= ~TF_ACK_DELAY;
  80e0a1:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  80e0a5:	e9 05 07 00 00       	jmp    80e7af <tcp_input+0xd17>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  80e0aa:	8b 15 60 c2 b3 00    	mov    0xb3c260,%edx
  80e0b0:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  80e0b3:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  80e0ba:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  80e0be:	0f 87 d1 04 00 00    	ja     80e595 <tcp_input+0xafd>
  80e0c4:	8b 53 10             	mov    0x10(%ebx),%edx
  80e0c7:	ff 24 95 6c 42 81 00 	jmp    *0x81426c(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  80e0ce:	83 e0 12             	and    $0x12,%eax
  80e0d1:	3c 12                	cmp    $0x12,%al
  80e0d3:	0f 85 03 01 00 00    	jne    80e1dc <tcp_input+0x744>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  80e0d9:	8b 43 78             	mov    0x78(%ebx),%eax
  80e0dc:	8b 40 10             	mov    0x10(%eax),%eax
  80e0df:	8b 40 04             	mov    0x4(%eax),%eax
  80e0e2:	89 04 24             	mov    %eax,(%esp)
  80e0e5:	e8 10 9f ff ff       	call   807ffa <ntohl>
  80e0ea:	8d 50 01             	lea    0x1(%eax),%edx
  80e0ed:	3b 15 c4 c1 b3 00    	cmp    0xb3c1c4,%edx
  80e0f3:	0f 85 e3 00 00 00    	jne    80e1dc <tcp_input+0x744>
      pcb->snd_buf++;
  80e0f9:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  80e0fe:	a1 c8 c1 b3 00       	mov    0xb3c1c8,%eax
  80e103:	8d 48 01             	lea    0x1(%eax),%ecx
  80e106:	89 4b 24             	mov    %ecx,0x24(%ebx)
      pcb->lastack = ackno;
  80e109:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  80e10c:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
  80e112:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  80e116:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  80e11a:	83 e8 01             	sub    $0x1,%eax
  80e11d:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  80e120:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  80e127:	89 d8                	mov    %ebx,%eax
  80e129:	e8 92 ec ff ff       	call   80cdc0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  80e12e:	8d 43 04             	lea    0x4(%ebx),%eax
  80e131:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e135:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80e139:	89 04 24             	mov    %eax,(%esp)
  80e13c:	e8 d8 87 ff ff       	call   806919 <tcp_eff_send_mss>
  80e141:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  80e145:	6b d0 0a             	imul   $0xa,%eax,%edx
  80e148:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e14c:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80e14f:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  80e154:	0f 44 c2             	cmove  %edx,%eax
  80e157:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  80e15b:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  80e15f:	66 85 c0             	test   %ax,%ax
  80e162:	75 1c                	jne    80e180 <tcp_input+0x6e8>
  80e164:	c7 44 24 08 41 42 81 	movl   $0x814241,0x8(%esp)
  80e16b:	00 
  80e16c:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  80e173:	00 
  80e174:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80e17b:	e8 1a 0f 00 00       	call   80f09a <_panic>
      --pcb->snd_queuelen;
  80e180:	83 e8 01             	sub    $0x1,%eax
  80e183:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  80e187:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  80e18a:	8b 10                	mov    (%eax),%edx
  80e18c:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  80e18f:	85 d2                	test   %edx,%edx
  80e191:	75 08                	jne    80e19b <tcp_input+0x703>
        pcb->rtime = -1;
  80e193:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  80e199:	eb 0a                	jmp    80e1a5 <tcp_input+0x70d>
      else {
        pcb->rtime = 0;
  80e19b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  80e1a1:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  80e1a5:	89 04 24             	mov    %eax,(%esp)
  80e1a8:	e8 4c 7c ff ff       	call   805df9 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  80e1ad:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  80e1b3:	85 c0                	test   %eax,%eax
  80e1b5:	74 14                	je     80e1cb <tcp_input+0x733>
  80e1b7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e1be:	00 
  80e1bf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e1c3:	8b 53 18             	mov    0x18(%ebx),%edx
  80e1c6:	89 14 24             	mov    %edx,(%esp)
  80e1c9:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  80e1cb:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e1cf:	89 1c 24             	mov    %ebx,(%esp)
  80e1d2:	e8 ba a5 ff ff       	call   808791 <tcp_output>
  80e1d7:	e9 d3 05 00 00       	jmp    80e7af <tcp_input+0xd17>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  80e1dc:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e1e3:	0f 84 c6 05 00 00    	je     80e7af <tcp_input+0xd17>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e1e9:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e1ef:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
  80e1f4:	0f b7 0a             	movzwl (%edx),%ecx
  80e1f7:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e1fb:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e1ff:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e203:	8d 50 0c             	lea    0xc(%eax),%edx
  80e206:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e20a:	83 c0 10             	add    $0x10,%eax
  80e20d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e211:	0f b7 05 be c1 b3 00 	movzwl 0xb3c1be,%eax
  80e218:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80e21e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e222:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e227:	89 04 24             	mov    %eax,(%esp)
  80e22a:	e8 f6 a9 ff ff       	call   808c25 <tcp_rst>
  80e22f:	e9 7b 05 00 00       	jmp    80e7af <tcp_input+0xd17>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  80e234:	83 e0 14             	and    $0x14,%eax
  80e237:	3c 10                	cmp    $0x10,%al
  80e239:	0f 85 70 05 00 00    	jne    80e7af <tcp_input+0xd17>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  80e23f:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e244:	8d 50 ff             	lea    -0x1(%eax),%edx
  80e247:	3b 53 48             	cmp    0x48(%ebx),%edx
  80e24a:	0f 88 b8 00 00 00    	js     80e308 <tcp_input+0x870>
  80e250:	89 c2                	mov    %eax,%edx
  80e252:	2b 53 54             	sub    0x54(%ebx),%edx
  80e255:	85 d2                	test   %edx,%edx
  80e257:	0f 8f ab 00 00 00    	jg     80e308 <tcp_input+0x870>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  80e25d:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  80e264:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  80e26a:	85 c0                	test   %eax,%eax
  80e26c:	75 1c                	jne    80e28a <tcp_input+0x7f2>
  80e26e:	c7 44 24 08 57 42 81 	movl   $0x814257,0x8(%esp)
  80e275:	00 
  80e276:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  80e27d:	00 
  80e27e:	c7 04 24 e8 41 81 00 	movl   $0x8141e8,(%esp)
  80e285:	e8 10 0e 00 00       	call   80f09a <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  80e28a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e291:	00 
  80e292:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e296:	8b 53 18             	mov    0x18(%ebx),%edx
  80e299:	89 14 24             	mov    %edx,(%esp)
  80e29c:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  80e29e:	84 c0                	test   %al,%al
  80e2a0:	74 17                	je     80e2b9 <tcp_input+0x821>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  80e2a2:	89 1c 24             	mov    %ebx,(%esp)
  80e2a5:	e8 5f 7f ff ff       	call   806209 <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e2aa:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e2b1:	00 00 00 
  80e2b4:	e9 1a 04 00 00       	jmp    80e6d3 <tcp_input+0xc3b>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  80e2b9:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  80e2bd:	89 d8                	mov    %ebx,%eax
  80e2bf:	e8 a6 eb ff ff       	call   80ce6a <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  80e2c4:	66 83 fe 01          	cmp    $0x1,%si
  80e2c8:	75 09                	jne    80e2d3 <tcp_input+0x83b>
  80e2ca:	0f b7 4b 34          	movzwl 0x34(%ebx),%ecx
  80e2ce:	8d 14 09             	lea    (%ecx,%ecx,1),%edx
  80e2d1:	eb 04                	jmp    80e2d7 <tcp_input+0x83f>
  80e2d3:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  80e2d7:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  80e2db:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e2e2:	0f 84 c7 04 00 00    	je     80e7af <tcp_input+0xd17>
  80e2e8:	84 c0                	test   %al,%al
  80e2ea:	0f 84 bf 04 00 00    	je     80e7af <tcp_input+0xd17>
          tcp_ack_now(pcb);
  80e2f0:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e2f4:	89 1c 24             	mov    %ebx,(%esp)
  80e2f7:	e8 95 a4 ff ff       	call   808791 <tcp_output>
          pcb->state = CLOSE_WAIT;
  80e2fc:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e303:	e9 a7 04 00 00       	jmp    80e7af <tcp_input+0xd17>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  80e308:	8b 0d d0 c1 b3 00    	mov    0xb3c1d0,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  80e30e:	8b 15 cc c1 b3 00    	mov    0xb3c1cc,%edx
  80e314:	0f b7 31             	movzwl (%ecx),%esi
  80e317:	89 74 24 14          	mov    %esi,0x14(%esp)
  80e31b:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  80e31f:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80e323:	8d 4a 0c             	lea    0xc(%edx),%ecx
  80e326:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e32a:	83 c2 10             	add    $0x10,%edx
  80e32d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e331:	0f b7 15 be c1 b3 00 	movzwl 0xb3c1be,%edx
  80e338:	03 15 c8 c1 b3 00    	add    0xb3c1c8,%edx
  80e33e:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e342:	89 04 24             	mov    %eax,(%esp)
  80e345:	e8 db a8 ff ff       	call   808c25 <tcp_rst>
  80e34a:	e9 60 04 00 00       	jmp    80e7af <tcp_input+0xd17>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  80e34f:	89 d8                	mov    %ebx,%eax
  80e351:	e8 14 eb ff ff       	call   80ce6a <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  80e356:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e35d:	0f 84 4c 04 00 00    	je     80e7af <tcp_input+0xd17>
  80e363:	84 c0                	test   %al,%al
  80e365:	0f 84 44 04 00 00    	je     80e7af <tcp_input+0xd17>
      tcp_ack_now(pcb);
  80e36b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e36f:	89 1c 24             	mov    %ebx,(%esp)
  80e372:	e8 1a a4 ff ff       	call   808791 <tcp_output>
      pcb->state = CLOSE_WAIT;
  80e377:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  80e37e:	e9 2c 04 00 00       	jmp    80e7af <tcp_input+0xd17>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  80e383:	89 d8                	mov    %ebx,%eax
  80e385:	e8 e0 ea ff ff       	call   80ce6a <tcp_receive>
    if (flags & TCP_FIN) {
  80e38a:	0f b6 05 c0 c1 b3 00 	movzbl 0xb3c1c0,%eax
  80e391:	a8 01                	test   $0x1,%al
  80e393:	0f 84 96 00 00 00    	je     80e42f <tcp_input+0x997>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e399:	a8 10                	test   $0x10,%al
  80e39b:	74 7a                	je     80e417 <tcp_input+0x97f>
  80e39d:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e3a2:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e3a5:	75 70                	jne    80e417 <tcp_input+0x97f>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  80e3a7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e3ab:	89 1c 24             	mov    %ebx,(%esp)
  80e3ae:	e8 de a3 ff ff       	call   808791 <tcp_output>
        tcp_pcb_purge(pcb);
  80e3b3:	89 1c 24             	mov    %ebx,(%esp)
  80e3b6:	e8 67 7b ff ff       	call   805f22 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  80e3bb:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e3c0:	39 c3                	cmp    %eax,%ebx
  80e3c2:	75 0a                	jne    80e3ce <tcp_input+0x936>
  80e3c4:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e3c7:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e3cc:	eb 2a                	jmp    80e3f8 <tcp_input+0x960>
  80e3ce:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e3d3:	eb 1a                	jmp    80e3ef <tcp_input+0x957>
  80e3d5:	8b 50 0c             	mov    0xc(%eax),%edx
  80e3d8:	85 d2                	test   %edx,%edx
  80e3da:	74 11                	je     80e3ed <tcp_input+0x955>
  80e3dc:	39 d3                	cmp    %edx,%ebx
  80e3de:	75 0d                	jne    80e3ed <tcp_input+0x955>
  80e3e0:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e3e5:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e3e8:	89 50 0c             	mov    %edx,0xc(%eax)
  80e3eb:	eb 0b                	jmp    80e3f8 <tcp_input+0x960>
  80e3ed:	89 d0                	mov    %edx,%eax
  80e3ef:	85 c0                	test   %eax,%eax
  80e3f1:	75 e2                	jne    80e3d5 <tcp_input+0x93d>
  80e3f3:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
        pcb->state = TIME_WAIT;
  80e3f8:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  80e3ff:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e404:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e407:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e40d:	e8 90 41 ff ff       	call   8025a2 <tcp_timer_needed>
  80e412:	e9 98 03 00 00       	jmp    80e7af <tcp_input+0xd17>
      } else {
        tcp_ack_now(pcb);
  80e417:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e41b:	89 1c 24             	mov    %ebx,(%esp)
  80e41e:	e8 6e a3 ff ff       	call   808791 <tcp_output>
        pcb->state = CLOSING;
  80e423:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  80e42a:	e9 80 03 00 00       	jmp    80e7af <tcp_input+0xd17>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e42f:	a8 10                	test   $0x10,%al
  80e431:	0f 84 78 03 00 00    	je     80e7af <tcp_input+0xd17>
  80e437:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e43c:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e43f:	0f 85 6a 03 00 00    	jne    80e7af <tcp_input+0xd17>
      pcb->state = FIN_WAIT_2;
  80e445:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  80e44c:	e9 5e 03 00 00       	jmp    80e7af <tcp_input+0xd17>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  80e451:	89 d8                	mov    %ebx,%eax
  80e453:	e8 12 ea ff ff       	call   80ce6a <tcp_receive>
    if (flags & TCP_FIN) {
  80e458:	f6 05 c0 c1 b3 00 01 	testb  $0x1,0xb3c1c0
  80e45f:	0f 84 4a 03 00 00    	je     80e7af <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e465:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e469:	89 1c 24             	mov    %ebx,(%esp)
  80e46c:	e8 20 a3 ff ff       	call   808791 <tcp_output>
      tcp_pcb_purge(pcb);
  80e471:	89 1c 24             	mov    %ebx,(%esp)
  80e474:	e8 a9 7a ff ff       	call   805f22 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e479:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e47e:	39 c3                	cmp    %eax,%ebx
  80e480:	75 0a                	jne    80e48c <tcp_input+0x9f4>
  80e482:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e485:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e48a:	eb 2a                	jmp    80e4b6 <tcp_input+0xa1e>
  80e48c:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e491:	eb 1a                	jmp    80e4ad <tcp_input+0xa15>
  80e493:	8b 50 0c             	mov    0xc(%eax),%edx
  80e496:	85 d2                	test   %edx,%edx
  80e498:	74 11                	je     80e4ab <tcp_input+0xa13>
  80e49a:	39 d3                	cmp    %edx,%ebx
  80e49c:	75 0d                	jne    80e4ab <tcp_input+0xa13>
  80e49e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e4a3:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e4a6:	89 50 0c             	mov    %edx,0xc(%eax)
  80e4a9:	eb 0b                	jmp    80e4b6 <tcp_input+0xa1e>
  80e4ab:	89 d0                	mov    %edx,%eax
  80e4ad:	85 c0                	test   %eax,%eax
  80e4af:	75 e2                	jne    80e493 <tcp_input+0x9fb>
  80e4b1:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
      pcb->state = TIME_WAIT;
  80e4b6:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e4bd:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e4c2:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e4c5:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e4cb:	e8 d2 40 ff ff       	call   8025a2 <tcp_timer_needed>
  80e4d0:	e9 da 02 00 00       	jmp    80e7af <tcp_input+0xd17>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  80e4d5:	89 d8                	mov    %ebx,%eax
  80e4d7:	e8 8e e9 ff ff       	call   80ce6a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e4dc:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e4e3:	0f 84 c6 02 00 00    	je     80e7af <tcp_input+0xd17>
  80e4e9:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e4ee:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e4f1:	0f 85 b8 02 00 00    	jne    80e7af <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  80e4f7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  80e4fb:	89 1c 24             	mov    %ebx,(%esp)
  80e4fe:	e8 8e a2 ff ff       	call   808791 <tcp_output>
      tcp_pcb_purge(pcb);
  80e503:	89 1c 24             	mov    %ebx,(%esp)
  80e506:	e8 17 7a ff ff       	call   805f22 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  80e50b:	a1 5c c2 b3 00       	mov    0xb3c25c,%eax
  80e510:	39 c3                	cmp    %eax,%ebx
  80e512:	75 0a                	jne    80e51e <tcp_input+0xa86>
  80e514:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e517:	a3 5c c2 b3 00       	mov    %eax,0xb3c25c
  80e51c:	eb 2a                	jmp    80e548 <tcp_input+0xab0>
  80e51e:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e523:	eb 1a                	jmp    80e53f <tcp_input+0xaa7>
  80e525:	8b 50 0c             	mov    0xc(%eax),%edx
  80e528:	85 d2                	test   %edx,%edx
  80e52a:	74 11                	je     80e53d <tcp_input+0xaa5>
  80e52c:	39 d3                	cmp    %edx,%ebx
  80e52e:	75 0d                	jne    80e53d <tcp_input+0xaa5>
  80e530:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
  80e535:	8b 53 0c             	mov    0xc(%ebx),%edx
  80e538:	89 50 0c             	mov    %edx,0xc(%eax)
  80e53b:	eb 0b                	jmp    80e548 <tcp_input+0xab0>
  80e53d:	89 d0                	mov    %edx,%eax
  80e53f:	85 c0                	test   %eax,%eax
  80e541:	75 e2                	jne    80e525 <tcp_input+0xa8d>
  80e543:	a3 68 c2 b3 00       	mov    %eax,0xb3c268
      pcb->state = TIME_WAIT;
  80e548:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  80e54f:	a1 70 c2 b3 00       	mov    0xb3c270,%eax
  80e554:	89 43 0c             	mov    %eax,0xc(%ebx)
  80e557:	89 1d 70 c2 b3 00    	mov    %ebx,0xb3c270
  80e55d:	e8 40 40 ff ff       	call   8025a2 <tcp_timer_needed>
  80e562:	e9 48 02 00 00       	jmp    80e7af <tcp_input+0xd17>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  80e567:	89 d8                	mov    %ebx,%eax
  80e569:	e8 fc e8 ff ff       	call   80ce6a <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  80e56e:	f6 05 c0 c1 b3 00 10 	testb  $0x10,0xb3c1c0
  80e575:	0f 84 34 02 00 00    	je     80e7af <tcp_input+0xd17>
  80e57b:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e580:	39 43 54             	cmp    %eax,0x54(%ebx)
  80e583:	0f 85 26 02 00 00    	jne    80e7af <tcp_input+0xd17>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  80e589:	c6 05 bc c1 b3 00 10 	movb   $0x10,0xb3c1bc
  80e590:	e9 1a 02 00 00       	jmp    80e7af <tcp_input+0xd17>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e595:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e59c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  80e59f:	0f b6 05 bc c1 b3 00 	movzbl 0xb3c1bc,%eax
  80e5a6:	a8 08                	test   $0x8,%al
  80e5a8:	74 3f                	je     80e5e9 <tcp_input+0xb51>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  80e5aa:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80e5b0:	85 c0                	test   %eax,%eax
  80e5b2:	74 10                	je     80e5c4 <tcp_input+0xb2c>
  80e5b4:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  80e5bb:	ff 
  80e5bc:	8b 53 18             	mov    0x18(%ebx),%edx
  80e5bf:	89 14 24             	mov    %edx,(%esp)
  80e5c2:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e5c4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5c8:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80e5cf:	e8 c3 79 ff ff       	call   805f97 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e5d4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5d8:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e5df:	e8 8e 64 ff ff       	call   804a72 <memp_free>
  80e5e4:	e9 ea 00 00 00       	jmp    80e6d3 <tcp_input+0xc3b>
      } else if (recv_flags & TF_CLOSED) {
  80e5e9:	a8 10                	test   $0x10,%al
  80e5eb:	74 25                	je     80e612 <tcp_input+0xb7a>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80e5ed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e5f1:	c7 04 24 5c c2 b3 00 	movl   $0xb3c25c,(%esp)
  80e5f8:	e8 9a 79 ff ff       	call   805f97 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  80e5fd:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e601:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e608:	e8 65 64 ff ff       	call   804a72 <memp_free>
  80e60d:	e9 c1 00 00 00       	jmp    80e6d3 <tcp_input+0xc3b>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e612:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  80e616:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  80e61b:	66 85 d2             	test   %dx,%dx
  80e61e:	74 1d                	je     80e63d <tcp_input+0xba5>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  80e620:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  80e626:	85 c9                	test   %ecx,%ecx
  80e628:	74 13                	je     80e63d <tcp_input+0xba5>
  80e62a:	0f b7 d2             	movzwl %dx,%edx
  80e62d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e631:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e635:	8b 43 18             	mov    0x18(%ebx),%eax
  80e638:	89 04 24             	mov    %eax,(%esp)
  80e63b:	ff d1                	call   *%ecx
        }
      
        if (recv_data != NULL) {
  80e63d:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80e643:	85 d2                	test   %edx,%edx
  80e645:	74 51                	je     80e698 <tcp_input+0xc00>
          if(flags & TCP_PSH) {
  80e647:	f6 05 c0 c1 b3 00 08 	testb  $0x8,0xb3c1c0
  80e64e:	0f 84 6a 01 00 00    	je     80e7be <tcp_input+0xd26>
            recv_data->flags |= PBUF_FLAG_PUSH;
  80e654:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
  80e658:	e9 61 01 00 00       	jmp    80e7be <tcp_input+0xd26>
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e65d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e664:	00 
  80e665:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e669:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e66d:	8b 53 18             	mov    0x18(%ebx),%edx
  80e670:	89 14 24             	mov    %edx,(%esp)
  80e673:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  80e675:	84 c0                	test   %al,%al
  80e677:	75 13                	jne    80e68c <tcp_input+0xbf4>
  80e679:	eb 1d                	jmp    80e698 <tcp_input+0xc00>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e67b:	89 14 24             	mov    %edx,(%esp)
  80e67e:	66 90                	xchg   %ax,%ax
  80e680:	e8 9f 67 ff ff       	call   804e24 <pbuf_free>
  80e685:	b8 00 00 00 00       	mov    $0x0,%eax
  80e68a:	eb 0c                	jmp    80e698 <tcp_input+0xc00>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  80e68c:	8b 15 b8 c1 b3 00    	mov    0xb3c1b8,%edx
  80e692:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  80e698:	f6 05 bc c1 b3 00 20 	testb  $0x20,0xb3c1bc
  80e69f:	74 26                	je     80e6c7 <tcp_input+0xc2f>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  80e6a1:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e6a7:	85 c0                	test   %eax,%eax
  80e6a9:	74 20                	je     80e6cb <tcp_input+0xc33>
  80e6ab:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80e6b2:	00 
  80e6b3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e6ba:	00 
  80e6bb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e6bf:	8b 53 18             	mov    0x18(%ebx),%edx
  80e6c2:	89 14 24             	mov    %edx,(%esp)
  80e6c5:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  80e6c7:	84 c0                	test   %al,%al
  80e6c9:	75 08                	jne    80e6d3 <tcp_input+0xc3b>
          tcp_output(pcb);
  80e6cb:	89 1c 24             	mov    %ebx,(%esp)
  80e6ce:	e8 be a0 ff ff       	call   808791 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  80e6d3:	a1 d8 c1 b3 00       	mov    0xb3c1d8,%eax
  80e6d8:	85 c0                	test   %eax,%eax
  80e6da:	0f 84 f1 00 00 00    	je     80e7d1 <tcp_input+0xd39>
    {
      pbuf_free(inseg.p);
  80e6e0:	89 04 24             	mov    %eax,(%esp)
  80e6e3:	e8 3c 67 ff ff       	call   804e24 <pbuf_free>
      inseg.p = NULL;
  80e6e8:	c7 05 d8 c1 b3 00 00 	movl   $0x0,0xb3c1d8
  80e6ef:	00 00 00 
  80e6f2:	e9 da 00 00 00       	jmp    80e7d1 <tcp_input+0xd39>
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  80e6f7:	8b 15 d0 c1 b3 00    	mov    0xb3c1d0,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  80e6fd:	a1 cc c1 b3 00       	mov    0xb3c1cc,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  80e702:	0f b7 0a             	movzwl (%edx),%ecx
  80e705:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  80e709:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  80e70d:	89 54 24 10          	mov    %edx,0x10(%esp)
  80e711:	8d 50 0c             	lea    0xc(%eax),%edx
  80e714:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e718:	83 c0 10             	add    $0x10,%eax
  80e71b:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e71f:	0f b7 05 be c1 b3 00 	movzwl 0xb3c1be,%eax
  80e726:	03 05 c8 c1 b3 00    	add    0xb3c1c8,%eax
  80e72c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e730:	a1 c4 c1 b3 00       	mov    0xb3c1c4,%eax
  80e735:	89 04 24             	mov    %eax,(%esp)
  80e738:	e8 e8 a4 ff ff       	call   808c25 <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  80e73d:	89 34 24             	mov    %esi,(%esp)
  80e740:	e8 df 66 ff ff       	call   804e24 <pbuf_free>
  80e745:	e9 87 00 00 00       	jmp    80e7d1 <tcp_input+0xd39>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  80e74a:	c7 05 d4 c1 b3 00 00 	movl   $0x0,0xb3c1d4
  80e751:	00 00 00 
    inseg.len = p->tot_len;
  80e754:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80e758:	66 a3 e0 c1 b3 00    	mov    %ax,0xb3c1e0
    inseg.dataptr = p->payload;
  80e75e:	8b 46 04             	mov    0x4(%esi),%eax
  80e761:	a3 dc c1 b3 00       	mov    %eax,0xb3c1dc
    inseg.p = p;
  80e766:	89 35 d8 c1 b3 00    	mov    %esi,0xb3c1d8
    inseg.tcphdr = tcphdr;
  80e76c:	a1 d0 c1 b3 00       	mov    0xb3c1d0,%eax
  80e771:	a3 e4 c1 b3 00       	mov    %eax,0xb3c1e4

    recv_data = NULL;
  80e776:	c7 05 b8 c1 b3 00 00 	movl   $0x0,0xb3c1b8
  80e77d:	00 00 00 
    recv_flags = 0;
  80e780:	c6 05 bc c1 b3 00 00 	movb   $0x0,0xb3c1bc

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80e787:	8b 93 80 00 00 00    	mov    0x80(%ebx),%edx
  80e78d:	85 d2                	test   %edx,%edx
  80e78f:	0f 85 57 f8 ff ff    	jne    80dfec <tcp_input+0x554>
  80e795:	e9 9b f8 ff ff       	jmp    80e035 <tcp_input+0x59d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  80e79a:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80e79e:	89 04 24             	mov    %eax,(%esp)
  80e7a1:	e8 0d 96 ff ff       	call   807db3 <ntohs>
  80e7a6:	a8 04                	test   $0x4,%al
  80e7a8:	75 93                	jne    80e73d <tcp_input+0xca5>
  80e7aa:	e9 48 ff ff ff       	jmp    80e6f7 <tcp_input+0xc5f>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  80e7af:	c7 05 78 c2 b3 00 00 	movl   $0x0,0xb3c278
  80e7b6:	00 00 00 
  80e7b9:	e9 e1 fd ff ff       	jmp    80e59f <tcp_input+0xb07>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  80e7be:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  80e7c4:	85 c0                	test   %eax,%eax
  80e7c6:	0f 85 91 fe ff ff    	jne    80e65d <tcp_input+0xbc5>
  80e7cc:	e9 aa fe ff ff       	jmp    80e67b <tcp_input+0xbe3>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  80e7d1:	83 c4 4c             	add    $0x4c,%esp
  80e7d4:	5b                   	pop    %ebx
  80e7d5:	5e                   	pop    %esi
  80e7d6:	5f                   	pop    %edi
  80e7d7:	5d                   	pop    %ebp
  80e7d8:	c3                   	ret    

0080e7d9 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  80e7d9:	55                   	push   %ebp
  80e7da:	89 e5                	mov    %esp,%ebp
  80e7dc:	57                   	push   %edi
  80e7dd:	56                   	push   %esi
  80e7de:	53                   	push   %ebx
  80e7df:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  80e7e2:	8b 45 08             	mov    0x8(%ebp),%eax
  80e7e5:	8b 40 04             	mov    0x4(%eax),%eax
  proto = IPH_PROTO(iphdr);
  80e7e8:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80e7eb:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e7ef:	89 04 24             	mov    %eax,(%esp)
  80e7f2:	e8 bc 95 ff ff       	call   807db3 <ntohs>

  prev = NULL;
  pcb = raw_pcbs;
  80e7f7:	8b 1d e8 c1 b3 00    	mov    0xb3c1e8,%ebx
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  80e7fd:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  80e801:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  80e806:	0f b6 f8             	movzbl %al,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e809:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80e80c:	83 c0 0c             	add    $0xc,%eax
  80e80f:	89 45 e0             	mov    %eax,-0x20(%ebp)

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e812:	eb 62                	jmp    80e876 <raw_input+0x9d>
    if (pcb->protocol == proto) {
  80e814:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e818:	39 f8                	cmp    %edi,%eax
  80e81a:	75 55                	jne    80e871 <raw_input+0x98>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  80e81c:	8b 43 14             	mov    0x14(%ebx),%eax
  80e81f:	85 c0                	test   %eax,%eax
  80e821:	74 4e                	je     80e871 <raw_input+0x98>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  80e823:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e826:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80e82a:	8b 55 08             	mov    0x8(%ebp),%edx
  80e82d:	89 54 24 08          	mov    %edx,0x8(%esp)
  80e831:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e835:	8b 53 18             	mov    0x18(%ebx),%edx
  80e838:	89 14 24             	mov    %edx,(%esp)
  80e83b:	ff d0                	call   *%eax
  80e83d:	84 c0                	test   %al,%al
  80e83f:	74 30                	je     80e871 <raw_input+0x98>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  80e841:	85 f6                	test   %esi,%esi
  80e843:	74 21                	je     80e866 <raw_input+0x8d>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  80e845:	8b 43 0c             	mov    0xc(%ebx),%eax
  80e848:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  80e84b:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80e850:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  80e853:	89 1d e8 c1 b3 00    	mov    %ebx,0xb3c1e8
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
  80e859:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e85d:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
  80e864:	eb 0b                	jmp    80e871 <raw_input+0x98>
          eaten = 1;
  80e866:	c6 45 e7 01          	movb   $0x1,-0x19(%ebp)
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
        {
          /* receive function ate the packet */
          p = NULL;
  80e86a:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
        }
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
  80e871:	89 de                	mov    %ebx,%esi
    pcb = pcb->next;
  80e873:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  80e876:	85 db                	test   %ebx,%ebx
  80e878:	74 06                	je     80e880 <raw_input+0xa7>
  80e87a:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80e87e:	74 94                	je     80e814 <raw_input+0x3b>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  80e880:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80e884:	83 c4 2c             	add    $0x2c,%esp
  80e887:	5b                   	pop    %ebx
  80e888:	5e                   	pop    %esi
  80e889:	5f                   	pop    %edi
  80e88a:	5d                   	pop    %ebp
  80e88b:	c3                   	ret    

0080e88c <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e88c:	55                   	push   %ebp
  80e88d:	89 e5                	mov    %esp,%ebp
  80e88f:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->local_ip, ipaddr);
  80e892:	85 c0                	test   %eax,%eax
  80e894:	74 04                	je     80e89a <raw_bind+0xe>
  80e896:	8b 10                	mov    (%eax),%edx
  80e898:	eb 05                	jmp    80e89f <raw_bind+0x13>
  80e89a:	ba 00 00 00 00       	mov    $0x0,%edx
  80e89f:	8b 45 08             	mov    0x8(%ebp),%eax
  80e8a2:	89 10                	mov    %edx,(%eax)
  return ERR_OK;
}
  80e8a4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8a9:	5d                   	pop    %ebp
  80e8aa:	c3                   	ret    

0080e8ab <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  80e8ab:	55                   	push   %ebp
  80e8ac:	89 e5                	mov    %esp,%ebp
  80e8ae:	8b 45 0c             	mov    0xc(%ebp),%eax
  ip_addr_set(&pcb->remote_ip, ipaddr);
  80e8b1:	85 c0                	test   %eax,%eax
  80e8b3:	74 04                	je     80e8b9 <raw_connect+0xe>
  80e8b5:	8b 10                	mov    (%eax),%edx
  80e8b7:	eb 05                	jmp    80e8be <raw_connect+0x13>
  80e8b9:	ba 00 00 00 00       	mov    $0x0,%edx
  80e8be:	8b 45 08             	mov    0x8(%ebp),%eax
  80e8c1:	89 50 04             	mov    %edx,0x4(%eax)
  return ERR_OK;
}
  80e8c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80e8c9:	5d                   	pop    %ebp
  80e8ca:	c3                   	ret    

0080e8cb <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  80e8cb:	55                   	push   %ebp
  80e8cc:	89 e5                	mov    %esp,%ebp
  80e8ce:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80e8d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e8d4:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  80e8d7:	8b 55 10             	mov    0x10(%ebp),%edx
  80e8da:	89 50 18             	mov    %edx,0x18(%eax)
}
  80e8dd:	5d                   	pop    %ebp
  80e8de:	c3                   	ret    

0080e8df <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  80e8df:	55                   	push   %ebp
  80e8e0:	89 e5                	mov    %esp,%ebp
  80e8e2:	57                   	push   %edi
  80e8e3:	56                   	push   %esi
  80e8e4:	53                   	push   %ebx
  80e8e5:	83 ec 2c             	sub    $0x2c,%esp
  80e8e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e8eb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  80e8ee:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80e8f5:	00 
  80e8f6:	89 3c 24             	mov    %edi,(%esp)
  80e8f9:	e8 42 64 ff ff       	call   804d40 <pbuf_header>
  80e8fe:	84 c0                	test   %al,%al
  80e900:	74 43                	je     80e945 <raw_sendto+0x66>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  80e902:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e909:	00 
  80e90a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e911:	00 
  80e912:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e919:	e8 e7 65 ff ff       	call   804f05 <pbuf_alloc>
  80e91e:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80e920:	85 c0                	test   %eax,%eax
  80e922:	0f 84 b8 00 00 00    	je     80e9e0 <raw_sendto+0x101>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80e928:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80e92c:	89 04 24             	mov    %eax,(%esp)
  80e92f:	e8 26 6a ff ff       	call   80535a <pbuf_chain>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e934:	8b 45 10             	mov    0x10(%ebp),%eax
  80e937:	89 04 24             	mov    %eax,(%esp)
  80e93a:	e8 d1 81 ff ff       	call   806b10 <ip_route>
  80e93f:	85 c0                	test   %eax,%eax
  80e941:	75 4e                	jne    80e991 <raw_sendto+0xb2>
  80e943:	eb 34                	jmp    80e979 <raw_sendto+0x9a>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  80e945:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80e94c:	ff 
  80e94d:	89 3c 24             	mov    %edi,(%esp)
  80e950:	e8 eb 63 ff ff       	call   804d40 <pbuf_header>
  80e955:	84 c0                	test   %al,%al
  80e957:	0f 84 91 00 00 00    	je     80e9ee <raw_sendto+0x10f>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  80e95d:	c7 44 24 08 94 42 81 	movl   $0x814294,0x8(%esp)
  80e964:	00 
  80e965:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  80e96c:	00 
  80e96d:	c7 04 24 ba 42 81 00 	movl   $0x8142ba,(%esp)
  80e974:	e8 21 07 00 00       	call   80f09a <_panic>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e979:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  80e97e:	39 f7                	cmp    %esi,%edi
  80e980:	74 7f                	je     80ea01 <raw_sendto+0x122>
      pbuf_free(q);
  80e982:	89 34 24             	mov    %esi,(%esp)
  80e985:	e8 9a 64 ff ff       	call   804e24 <pbuf_free>
    }
    return ERR_RTE;
  80e98a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e98f:	eb 70                	jmp    80ea01 <raw_sendto+0x122>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  80e991:	89 da                	mov    %ebx,%edx
  80e993:	85 db                	test   %ebx,%ebx
  80e995:	74 05                	je     80e99c <raw_sendto+0xbd>
  80e997:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e99a:	75 03                	jne    80e99f <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80e99c:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  80e99f:	89 44 24 18          	mov    %eax,0x18(%esp)
  80e9a3:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80e9a7:	89 44 24 14          	mov    %eax,0x14(%esp)
  80e9ab:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80e9af:	89 44 24 10          	mov    %eax,0x10(%esp)
  80e9b3:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80e9b7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80e9bb:	8b 45 10             	mov    0x10(%ebp),%eax
  80e9be:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e9c2:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e9c6:	89 34 24             	mov    %esi,(%esp)
  80e9c9:	e8 80 84 ff ff       	call   806e4e <ip_output_if>
  80e9ce:	89 c3                	mov    %eax,%ebx
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  80e9d0:	39 fe                	cmp    %edi,%esi
  80e9d2:	74 2d                	je     80ea01 <raw_sendto+0x122>
    /* free the header */
    pbuf_free(q);
  80e9d4:	89 34 24             	mov    %esi,(%esp)
  80e9d7:	e8 48 64 ff ff       	call   804e24 <pbuf_free>
  }
  return err;
  80e9dc:	89 d8                	mov    %ebx,%eax
  80e9de:	eb 21                	jmp    80ea01 <raw_sendto+0x122>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  80e9e0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e9e5:	eb 1a                	jmp    80ea01 <raw_sendto+0x122>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  80e9e7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e9ec:	eb 13                	jmp    80ea01 <raw_sendto+0x122>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  80e9ee:	8b 45 10             	mov    0x10(%ebp),%eax
  80e9f1:	89 04 24             	mov    %eax,(%esp)
  80e9f4:	e8 17 81 ff ff       	call   806b10 <ip_route>
  80e9f9:	85 c0                	test   %eax,%eax
  80e9fb:	74 ea                	je     80e9e7 <raw_sendto+0x108>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  80e9fd:	89 fe                	mov    %edi,%esi
  80e9ff:	eb 90                	jmp    80e991 <raw_sendto+0xb2>
  if (q != p) {
    /* free the header */
    pbuf_free(q);
  }
  return err;
}
  80ea01:	83 c4 2c             	add    $0x2c,%esp
  80ea04:	5b                   	pop    %ebx
  80ea05:	5e                   	pop    %esi
  80ea06:	5f                   	pop    %edi
  80ea07:	5d                   	pop    %ebp
  80ea08:	c3                   	ret    

0080ea09 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  80ea09:	55                   	push   %ebp
  80ea0a:	89 e5                	mov    %esp,%ebp
  80ea0c:	83 ec 18             	sub    $0x18,%esp
  80ea0f:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  80ea12:	8d 50 04             	lea    0x4(%eax),%edx
  80ea15:	89 54 24 08          	mov    %edx,0x8(%esp)
  80ea19:	8b 55 0c             	mov    0xc(%ebp),%edx
  80ea1c:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ea20:	89 04 24             	mov    %eax,(%esp)
  80ea23:	e8 b7 fe ff ff       	call   80e8df <raw_sendto>
}
  80ea28:	c9                   	leave  
  80ea29:	c3                   	ret    

0080ea2a <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  80ea2a:	55                   	push   %ebp
  80ea2b:	89 e5                	mov    %esp,%ebp
  80ea2d:	83 ec 18             	sub    $0x18,%esp
  80ea30:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  80ea33:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80ea38:	39 c8                	cmp    %ecx,%eax
  80ea3a:	75 1e                	jne    80ea5a <raw_remove+0x30>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  80ea3c:	8b 40 0c             	mov    0xc(%eax),%eax
  80ea3f:	a3 e8 c1 b3 00       	mov    %eax,0xb3c1e8
  80ea44:	eb 18                	jmp    80ea5e <raw_remove+0x34>
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80ea46:	8b 50 0c             	mov    0xc(%eax),%edx
  80ea49:	85 d2                	test   %edx,%edx
  80ea4b:	74 0a                	je     80ea57 <raw_remove+0x2d>
  80ea4d:	39 d1                	cmp    %edx,%ecx
  80ea4f:	75 06                	jne    80ea57 <raw_remove+0x2d>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80ea51:	8b 51 0c             	mov    0xc(%ecx),%edx
  80ea54:	89 50 0c             	mov    %edx,0xc(%eax)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80ea57:	8b 40 0c             	mov    0xc(%eax),%eax
  80ea5a:	85 c0                	test   %eax,%eax
  80ea5c:	75 e8                	jne    80ea46 <raw_remove+0x1c>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  80ea5e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80ea62:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea69:	e8 04 60 ff ff       	call   804a72 <memp_free>
}
  80ea6e:	c9                   	leave  
  80ea6f:	c3                   	ret    

0080ea70 <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  80ea70:	55                   	push   %ebp
  80ea71:	89 e5                	mov    %esp,%ebp
  80ea73:	56                   	push   %esi
  80ea74:	53                   	push   %ebx
  80ea75:	83 ec 10             	sub    $0x10,%esp
  80ea78:	8b 75 08             	mov    0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  80ea7b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ea82:	e8 8b 5f ff ff       	call   804a12 <memp_malloc>
  80ea87:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  80ea89:	85 c0                	test   %eax,%eax
  80ea8b:	74 2f                	je     80eabc <raw_new+0x4c>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  80ea8d:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80ea94:	00 
  80ea95:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ea9c:	00 
  80ea9d:	89 04 24             	mov    %eax,(%esp)
  80eaa0:	e8 62 0e 00 00       	call   80f907 <memset>
    pcb->protocol = proto;
  80eaa5:	89 f0                	mov    %esi,%eax
  80eaa7:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  80eaaa:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  80eaae:	a1 e8 c1 b3 00       	mov    0xb3c1e8,%eax
  80eab3:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  80eab6:	89 1d e8 c1 b3 00    	mov    %ebx,0xb3c1e8
  }
  return pcb;
}
  80eabc:	89 d8                	mov    %ebx,%eax
  80eabe:	83 c4 10             	add    $0x10,%esp
  80eac1:	5b                   	pop    %ebx
  80eac2:	5e                   	pop    %esi
  80eac3:	5d                   	pop    %ebp
  80eac4:	c3                   	ret    
  80eac5:	66 90                	xchg   %ax,%ax
  80eac7:	66 90                	xchg   %ax,%ax
  80eac9:	66 90                	xchg   %ax,%ax
  80eacb:	66 90                	xchg   %ax,%ax
  80eacd:	66 90                	xchg   %ax,%ax
  80eacf:	90                   	nop

0080ead0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  80ead0:	55                   	push   %ebp
  80ead1:	89 e5                	mov    %esp,%ebp
  80ead3:	57                   	push   %edi
  80ead4:	56                   	push   %esi
  80ead5:	53                   	push   %ebx
  80ead6:	83 ec 3c             	sub    $0x3c,%esp
  80ead9:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  80eadc:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  80eadf:	0f b7 06             	movzwl (%esi),%eax
  80eae2:	89 04 24             	mov    %eax,(%esp)
  80eae5:	e8 c9 92 ff ff       	call   807db3 <ntohs>
  80eaea:	66 c1 e8 06          	shr    $0x6,%ax
  80eaee:	83 e0 3c             	and    $0x3c,%eax
  80eaf1:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  80eaf5:	89 c7                	mov    %eax,%edi
  80eaf7:	f7 df                	neg    %edi
  80eaf9:	0f bf ff             	movswl %di,%edi
  80eafc:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80eb00:	89 1c 24             	mov    %ebx,(%esp)
  80eb03:	e8 38 62 ff ff       	call   804d40 <pbuf_header>
  80eb08:	84 c0                	test   %al,%al
  80eb0a:	0f 85 eb 02 00 00    	jne    80edfb <icmp_input+0x32b>
  80eb10:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  80eb15:	0f 86 e0 02 00 00    	jbe    80edfb <icmp_input+0x32b>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  80eb1b:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  80eb1e:	80 38 08             	cmpb   $0x8,(%eax)
  80eb21:	0f 85 ca 02 00 00    	jne    80edf1 <icmp_input+0x321>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  80eb27:	8b 45 0c             	mov    0xc(%ebp),%eax
  80eb2a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eb2e:	8d 46 10             	lea    0x10(%esi),%eax
  80eb31:	89 04 24             	mov    %eax,(%esp)
  80eb34:	e8 88 7f ff ff       	call   806ac1 <ip_addr_isbroadcast>
  80eb39:	84 c0                	test   %al,%al
  80eb3b:	75 29                	jne    80eb66 <icmp_input+0x96>
  80eb3d:	8b 46 10             	mov    0x10(%esi),%eax
  80eb40:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eb43:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80eb4a:	e8 ab 94 ff ff       	call   807ffa <ntohl>
  80eb4f:	23 45 e0             	and    -0x20(%ebp),%eax
  80eb52:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80eb55:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80eb5c:	e8 99 94 ff ff       	call   807ffa <ntohl>
  80eb61:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80eb64:	75 0f                	jne    80eb75 <icmp_input+0xa5>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  80eb66:	89 1c 24             	mov    %ebx,(%esp)
  80eb69:	e8 b6 62 ff ff       	call   804e24 <pbuf_free>
      return;
  80eb6e:	66 90                	xchg   %ax,%ax
  80eb70:	e9 98 02 00 00       	jmp    80ee0d <icmp_input+0x33d>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  80eb75:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  80eb7a:	0f 86 7b 02 00 00    	jbe    80edfb <icmp_input+0x32b>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  80eb80:	89 1c 24             	mov    %ebx,(%esp)
  80eb83:	e8 df 90 ff ff       	call   807c67 <inet_chksum_pbuf>
  80eb88:	66 85 c0             	test   %ax,%ax
  80eb8b:	74 0d                	je     80eb9a <icmp_input+0xca>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  80eb8d:	89 1c 24             	mov    %ebx,(%esp)
  80eb90:	e8 8f 62 ff ff       	call   804e24 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  80eb95:	e9 73 02 00 00       	jmp    80ee0d <icmp_input+0x33d>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80eb9a:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  80eba1:	00 
  80eba2:	89 1c 24             	mov    %ebx,(%esp)
  80eba5:	e8 96 61 ff ff       	call   804d40 <pbuf_header>
  80ebaa:	84 c0                	test   %al,%al
  80ebac:	0f 84 f0 00 00 00    	je     80eca2 <icmp_input+0x1d2>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  80ebb2:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ebb6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebba:	89 1c 24             	mov    %ebx,(%esp)
  80ebbd:	e8 7e 61 ff ff       	call   804d40 <pbuf_header>
  80ebc2:	84 c0                	test   %al,%al
  80ebc4:	74 1c                	je     80ebe2 <icmp_input+0x112>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  80ebc6:	c7 44 24 08 d0 42 81 	movl   $0x8142d0,0x8(%esp)
  80ebcd:	00 
  80ebce:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  80ebd5:	00 
  80ebd6:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80ebdd:	e8 b8 04 00 00       	call   80f09a <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  80ebe2:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80ebe6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ebed:	00 
  80ebee:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebf2:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ebf9:	e8 07 63 ff ff       	call   804f05 <pbuf_alloc>
  80ebfe:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  80ec01:	85 c0                	test   %eax,%eax
  80ec03:	0f 84 fc 01 00 00    	je     80ee05 <icmp_input+0x335>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  80ec09:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80ec0d:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ec11:	83 c0 08             	add    $0x8,%eax
  80ec14:	39 c2                	cmp    %eax,%edx
  80ec16:	73 1c                	jae    80ec34 <icmp_input+0x164>
  80ec18:	c7 44 24 08 04 43 81 	movl   $0x814304,0x8(%esp)
  80ec1f:	00 
  80ec20:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  80ec27:	00 
  80ec28:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80ec2f:	e8 66 04 00 00       	call   80f09a <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  80ec34:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ec38:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ec3b:	89 04 24             	mov    %eax,(%esp)
  80ec3e:	e8 f1 67 ff ff       	call   805434 <pbuf_copy>
  80ec43:	84 c0                	test   %al,%al
  80ec45:	74 1c                	je     80ec63 <icmp_input+0x193>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  80ec47:	c7 44 24 08 3c 43 81 	movl   $0x81433c,0x8(%esp)
  80ec4e:	00 
  80ec4f:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  80ec56:	00 
  80ec57:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80ec5e:	e8 37 04 00 00       	call   80f09a <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  80ec63:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80ec66:	8b 70 04             	mov    0x4(%eax),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  80ec69:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80ec6d:	89 04 24             	mov    %eax,(%esp)
  80ec70:	e8 cb 60 ff ff       	call   804d40 <pbuf_header>
  80ec75:	84 c0                	test   %al,%al
  80ec77:	74 1c                	je     80ec95 <icmp_input+0x1c5>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ec79:	c7 44 24 08 64 43 81 	movl   $0x814364,0x8(%esp)
  80ec80:	00 
  80ec81:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80ec88:	00 
  80ec89:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80ec90:	e8 05 04 00 00       	call   80f09a <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  80ec95:	89 1c 24             	mov    %ebx,(%esp)
  80ec98:	e8 87 61 ff ff       	call   804e24 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  80ec9d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80eca0:	eb 30                	jmp    80ecd2 <icmp_input+0x202>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  80eca2:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  80eca9:	ff 
  80ecaa:	89 1c 24             	mov    %ebx,(%esp)
  80ecad:	e8 8e 60 ff ff       	call   804d40 <pbuf_header>
  80ecb2:	84 c0                	test   %al,%al
  80ecb4:	74 1c                	je     80ecd2 <icmp_input+0x202>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  80ecb6:	c7 44 24 08 64 43 81 	movl   $0x814364,0x8(%esp)
  80ecbd:	00 
  80ecbe:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80ecc5:	00 
  80ecc6:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80eccd:	e8 c8 03 00 00       	call   80f09a <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  80ecd2:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  80ecd5:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  80ecd8:	8b 56 10             	mov    0x10(%esi),%edx
  80ecdb:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  80ecde:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  80ece1:	0f b7 07             	movzwl (%edi),%eax
  80ece4:	89 04 24             	mov    %eax,(%esp)
  80ece7:	e8 c7 90 ff ff       	call   807db3 <ntohs>
  80ecec:	0f b6 c0             	movzbl %al,%eax
  80ecef:	89 04 24             	mov    %eax,(%esp)
  80ecf2:	e8 af 90 ff ff       	call   807da6 <htons>
  80ecf7:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  80ecfa:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ecfe:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ed02:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  80ed09:	e8 98 90 ff ff       	call   807da6 <htons>
  80ed0e:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  80ed12:	72 22                	jb     80ed36 <icmp_input+0x266>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  80ed14:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ed18:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ed1c:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80ed23:	e8 7e 90 ff ff       	call   807da6 <htons>
  80ed28:	0f b7 4d e0          	movzwl -0x20(%ebp),%ecx
  80ed2c:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  80ed30:	66 89 47 02          	mov    %ax,0x2(%edi)
  80ed34:	eb 1c                	jmp    80ed52 <icmp_input+0x282>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  80ed36:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  80ed3a:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  80ed3e:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80ed45:	e8 5c 90 ff ff       	call   807da6 <htons>
  80ed4a:	66 03 45 e0          	add    -0x20(%ebp),%ax
  80ed4e:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  80ed52:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80ed56:	89 04 24             	mov    %eax,(%esp)
  80ed59:	e8 55 90 ff ff       	call   807db3 <ntohs>
  80ed5e:	66 0d 00 ff          	or     $0xff00,%ax
  80ed62:	0f b7 c0             	movzwl %ax,%eax
  80ed65:	89 04 24             	mov    %eax,(%esp)
  80ed68:	e8 39 90 ff ff       	call   807da6 <htons>
  80ed6d:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  80ed71:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80ed77:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ed7e:	00 
  80ed7f:	89 34 24             	mov    %esi,(%esp)
  80ed82:	e8 ca 8e ff ff       	call   807c51 <inet_chksum>
  80ed87:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  80ed8b:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  80ed8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ed93:	89 1c 24             	mov    %ebx,(%esp)
  80ed96:	e8 a5 5f ff ff       	call   804d40 <pbuf_header>
  80ed9b:	84 c0                	test   %al,%al
  80ed9d:	74 1c                	je     80edbb <icmp_input+0x2eb>
      LWIP_ASSERT("Can't move over header in packet", 0);
  80ed9f:	c7 44 24 08 30 34 81 	movl   $0x813430,0x8(%esp)
  80eda6:	00 
  80eda7:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80edae:	00 
  80edaf:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80edb6:	e8 df 02 00 00       	call   80f09a <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  80edbb:	8b 45 0c             	mov    0xc(%ebp),%eax
  80edbe:	89 44 24 18          	mov    %eax,0x18(%esp)
  80edc2:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80edc9:	00 
  80edca:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80edd1:	00 
  80edd2:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80edd9:	00 
  80edda:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ede1:	00 
  80ede2:	83 c6 0c             	add    $0xc,%esi
  80ede5:	89 74 24 04          	mov    %esi,0x4(%esp)
  80ede9:	89 1c 24             	mov    %ebx,(%esp)
  80edec:	e8 5d 80 ff ff       	call   806e4e <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  80edf1:	89 1c 24             	mov    %ebx,(%esp)
  80edf4:	e8 2b 60 ff ff       	call   804e24 <pbuf_free>
  return;
  80edf9:	eb 12                	jmp    80ee0d <icmp_input+0x33d>
lenerr:
  pbuf_free(p);
  80edfb:	89 1c 24             	mov    %ebx,(%esp)
  80edfe:	e8 21 60 ff ff       	call   804e24 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  80ee03:	eb 08                	jmp    80ee0d <icmp_input+0x33d>
memerr:
  pbuf_free(p);
  80ee05:	89 1c 24             	mov    %ebx,(%esp)
  80ee08:	e8 17 60 ff ff       	call   804e24 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  80ee0d:	83 c4 3c             	add    $0x3c,%esp
  80ee10:	5b                   	pop    %ebx
  80ee11:	5e                   	pop    %esi
  80ee12:	5f                   	pop    %edi
  80ee13:	5d                   	pop    %ebp
  80ee14:	c3                   	ret    

0080ee15 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  80ee15:	55                   	push   %ebp
  80ee16:	89 e5                	mov    %esp,%ebp
  80ee18:	57                   	push   %edi
  80ee19:	56                   	push   %esi
  80ee1a:	53                   	push   %ebx
  80ee1b:	83 ec 2c             	sub    $0x2c,%esp
  80ee1e:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ee21:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ee28:	00 
  80ee29:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ee30:	00 
  80ee31:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ee38:	e8 c8 60 ff ff       	call   804f05 <pbuf_alloc>
  80ee3d:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ee3f:	85 c0                	test   %eax,%eax
  80ee41:	0f 84 d8 00 00 00    	je     80ef1f <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ee47:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ee4c:	77 1c                	ja     80ee6a <icmp_dest_unreach+0x55>
  80ee4e:	c7 44 24 08 98 43 81 	movl   $0x814398,0x8(%esp)
  80ee55:	00 
  80ee56:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  80ee5d:	00 
  80ee5e:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80ee65:	e8 30 02 00 00       	call   80f09a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ee6a:	8b 47 04             	mov    0x4(%edi),%eax
  80ee6d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  80ee70:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  80ee73:	0f b7 06             	movzwl (%esi),%eax
  80ee76:	89 04 24             	mov    %eax,(%esp)
  80ee79:	e8 35 8f ff ff       	call   807db3 <ntohs>
  80ee7e:	0f b6 c0             	movzbl %al,%eax
  80ee81:	80 cc 03             	or     $0x3,%ah
  80ee84:	89 04 24             	mov    %eax,(%esp)
  80ee87:	e8 1a 8f ff ff       	call   807da6 <htons>
  80ee8c:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  80ee8f:	0f b7 c0             	movzwl %ax,%eax
  80ee92:	89 04 24             	mov    %eax,(%esp)
  80ee95:	e8 19 8f ff ff       	call   807db3 <ntohs>
  80ee9a:	b0 00                	mov    $0x0,%al
  80ee9c:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80eea0:	0f b7 c0             	movzwl %ax,%eax
  80eea3:	89 04 24             	mov    %eax,(%esp)
  80eea6:	e8 fb 8e ff ff       	call   807da6 <htons>
  80eeab:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  80eeae:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80eeb5:	00 
  80eeb6:	8b 47 04             	mov    0x4(%edi),%eax
  80eeb9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eebd:	8b 53 04             	mov    0x4(%ebx),%edx
  80eec0:	8d 42 08             	lea    0x8(%edx),%eax
  80eec3:	89 04 24             	mov    %eax,(%esp)
  80eec6:	e8 f1 0a 00 00       	call   80f9bc <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  80eecb:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  80eed1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80eed5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eed9:	89 34 24             	mov    %esi,(%esp)
  80eedc:	e8 70 8d ff ff       	call   807c51 <inet_chksum>
  80eee1:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80eee5:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80eeec:	00 
  80eeed:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80eef4:	00 
  80eef5:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80eefc:	00 
  80eefd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ef00:	83 c0 0c             	add    $0xc,%eax
  80ef03:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ef07:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef0e:	00 
  80ef0f:	89 1c 24             	mov    %ebx,(%esp)
  80ef12:	e8 c9 80 ff ff       	call   806fe0 <ip_output>
  pbuf_free(q);
  80ef17:	89 1c 24             	mov    %ebx,(%esp)
  80ef1a:	e8 05 5f ff ff       	call   804e24 <pbuf_free>
}
  80ef1f:	83 c4 2c             	add    $0x2c,%esp
  80ef22:	5b                   	pop    %ebx
  80ef23:	5e                   	pop    %esi
  80ef24:	5f                   	pop    %edi
  80ef25:	5d                   	pop    %ebp
  80ef26:	c3                   	ret    

0080ef27 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  80ef27:	55                   	push   %ebp
  80ef28:	89 e5                	mov    %esp,%ebp
  80ef2a:	57                   	push   %edi
  80ef2b:	56                   	push   %esi
  80ef2c:	53                   	push   %ebx
  80ef2d:	83 ec 2c             	sub    $0x2c,%esp
  80ef30:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  80ef33:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ef3a:	00 
  80ef3b:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  80ef42:	00 
  80ef43:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ef4a:	e8 b6 5f ff ff       	call   804f05 <pbuf_alloc>
  80ef4f:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  80ef51:	85 c0                	test   %eax,%eax
  80ef53:	0f 84 d8 00 00 00    	je     80f031 <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  80ef59:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  80ef5e:	77 1c                	ja     80ef7c <icmp_time_exceeded+0x55>
  80ef60:	c7 44 24 08 98 43 81 	movl   $0x814398,0x8(%esp)
  80ef67:	00 
  80ef68:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  80ef6f:	00 
  80ef70:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  80ef77:	e8 1e 01 00 00       	call   80f09a <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  80ef7c:	8b 47 04             	mov    0x4(%edi),%eax
  80ef7f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  80ef82:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  80ef85:	0f b7 06             	movzwl (%esi),%eax
  80ef88:	89 04 24             	mov    %eax,(%esp)
  80ef8b:	e8 23 8e ff ff       	call   807db3 <ntohs>
  80ef90:	0f b6 c0             	movzbl %al,%eax
  80ef93:	80 cc 0b             	or     $0xb,%ah
  80ef96:	89 04 24             	mov    %eax,(%esp)
  80ef99:	e8 08 8e ff ff       	call   807da6 <htons>
  80ef9e:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  80efa1:	0f b7 c0             	movzwl %ax,%eax
  80efa4:	89 04 24             	mov    %eax,(%esp)
  80efa7:	e8 07 8e ff ff       	call   807db3 <ntohs>
  80efac:	b0 00                	mov    $0x0,%al
  80efae:	66 0b 45 0c          	or     0xc(%ebp),%ax
  80efb2:	0f b7 c0             	movzwl %ax,%eax
  80efb5:	89 04 24             	mov    %eax,(%esp)
  80efb8:	e8 e9 8d ff ff       	call   807da6 <htons>
  80efbd:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  80efc0:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  80efc7:	00 
  80efc8:	8b 47 04             	mov    0x4(%edi),%eax
  80efcb:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efcf:	8b 53 04             	mov    0x4(%ebx),%edx
  80efd2:	8d 42 08             	lea    0x8(%edx),%eax
  80efd5:	89 04 24             	mov    %eax,(%esp)
  80efd8:	e8 df 09 00 00       	call   80f9bc <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  80efdd:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  80efe3:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80efe7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80efeb:	89 34 24             	mov    %esi,(%esp)
  80efee:	e8 5e 8c ff ff       	call   807c51 <inet_chksum>
  80eff3:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  80eff7:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  80effe:	00 
  80efff:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80f006:	00 
  80f007:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80f00e:	00 
  80f00f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f012:	83 c0 0c             	add    $0xc,%eax
  80f015:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f019:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f020:	00 
  80f021:	89 1c 24             	mov    %ebx,(%esp)
  80f024:	e8 b7 7f ff ff       	call   806fe0 <ip_output>
  pbuf_free(q);
  80f029:	89 1c 24             	mov    %ebx,(%esp)
  80f02c:	e8 f3 5d ff ff       	call   804e24 <pbuf_free>
}
  80f031:	83 c4 2c             	add    $0x2c,%esp
  80f034:	5b                   	pop    %ebx
  80f035:	5e                   	pop    %esi
  80f036:	5f                   	pop    %edi
  80f037:	5d                   	pop    %ebp
  80f038:	c3                   	ret    

0080f039 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

void
libmain(int argc, char **argv)
{
  80f039:	55                   	push   %ebp
  80f03a:	89 e5                	mov    %esp,%ebp
  80f03c:	56                   	push   %esi
  80f03d:	53                   	push   %ebx
  80f03e:	83 ec 10             	sub    $0x10,%esp
  80f041:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f044:	8b 75 0c             	mov    0xc(%ebp),%esi
	// set thisenv to point at our Env structure in envs[].
	// LAB 3: Your code here.
	thisenv = &envs[ENVX(sys_getenvid())];
  80f047:	e8 49 0b 00 00       	call   80fb95 <sys_getenvid>
  80f04c:	25 ff 03 00 00       	and    $0x3ff,%eax
  80f051:	c1 e0 07             	shl    $0x7,%eax
  80f054:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80f059:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c

	// save the name of the program so that panic() can use it
	if (argc > 0)
  80f05e:	85 db                	test   %ebx,%ebx
  80f060:	7e 07                	jle    80f069 <libmain+0x30>
		binaryname = argv[0];
  80f062:	8b 06                	mov    (%esi),%eax
  80f064:	a3 e8 52 81 00       	mov    %eax,0x8152e8

	// call user main routine
	umain(argc, argv);
  80f069:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f06d:	89 1c 24             	mov    %ebx,(%esp)
  80f070:	e8 da 15 ff ff       	call   80064f <umain>

	// exit gracefully
	exit();
  80f075:	e8 07 00 00 00       	call   80f081 <exit>
}
  80f07a:	83 c4 10             	add    $0x10,%esp
  80f07d:	5b                   	pop    %ebx
  80f07e:	5e                   	pop    %esi
  80f07f:	5d                   	pop    %ebp
  80f080:	c3                   	ret    

0080f081 <exit>:

#include <inc/lib.h>

void
exit(void)
{
  80f081:	55                   	push   %ebp
  80f082:	89 e5                	mov    %esp,%ebp
  80f084:	83 ec 18             	sub    $0x18,%esp
	close_all();
  80f087:	e8 9e 15 00 00       	call   81062a <close_all>
	sys_env_destroy(0);
  80f08c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f093:	e8 ab 0a 00 00       	call   80fb43 <sys_env_destroy>
}
  80f098:	c9                   	leave  
  80f099:	c3                   	ret    

0080f09a <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  80f09a:	55                   	push   %ebp
  80f09b:	89 e5                	mov    %esp,%ebp
  80f09d:	56                   	push   %esi
  80f09e:	53                   	push   %ebx
  80f09f:	83 ec 20             	sub    $0x20,%esp
	va_list ap;

	va_start(ap, fmt);
  80f0a2:	8d 5d 14             	lea    0x14(%ebp),%ebx

	// Print the panic message
	cprintf("[%08x] user panic in %s at %s:%d: ",
  80f0a5:	8b 35 e8 52 81 00    	mov    0x8152e8,%esi
  80f0ab:	e8 e5 0a 00 00       	call   80fb95 <sys_getenvid>
  80f0b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f0b3:	89 54 24 10          	mov    %edx,0x10(%esp)
  80f0b7:	8b 55 08             	mov    0x8(%ebp),%edx
  80f0ba:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f0be:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f0c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f0c6:	c7 04 24 e8 43 81 00 	movl   $0x8143e8,(%esp)
  80f0cd:	e8 c1 00 00 00       	call   80f193 <cprintf>
		sys_getenvid(), binaryname, file, line);
	vcprintf(fmt, ap);
  80f0d2:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f0d6:	8b 45 10             	mov    0x10(%ebp),%eax
  80f0d9:	89 04 24             	mov    %eax,(%esp)
  80f0dc:	e8 51 00 00 00       	call   80f132 <vcprintf>
	cprintf("\n");
  80f0e1:	c7 04 24 08 1f 81 00 	movl   $0x811f08,(%esp)
  80f0e8:	e8 a6 00 00 00       	call   80f193 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  80f0ed:	cc                   	int3   
  80f0ee:	eb fd                	jmp    80f0ed <_panic+0x53>

0080f0f0 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  80f0f0:	55                   	push   %ebp
  80f0f1:	89 e5                	mov    %esp,%ebp
  80f0f3:	53                   	push   %ebx
  80f0f4:	83 ec 14             	sub    $0x14,%esp
  80f0f7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  80f0fa:	8b 13                	mov    (%ebx),%edx
  80f0fc:	8d 42 01             	lea    0x1(%edx),%eax
  80f0ff:	89 03                	mov    %eax,(%ebx)
  80f101:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f104:	88 4c 13 08          	mov    %cl,0x8(%ebx,%edx,1)
	if (b->idx == 256-1) {
  80f108:	3d ff 00 00 00       	cmp    $0xff,%eax
  80f10d:	75 19                	jne    80f128 <putch+0x38>
		sys_cputs(b->buf, b->idx);
  80f10f:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f116:	00 
  80f117:	8d 43 08             	lea    0x8(%ebx),%eax
  80f11a:	89 04 24             	mov    %eax,(%esp)
  80f11d:	e8 e4 09 00 00       	call   80fb06 <sys_cputs>
		b->idx = 0;
  80f122:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  80f128:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  80f12c:	83 c4 14             	add    $0x14,%esp
  80f12f:	5b                   	pop    %ebx
  80f130:	5d                   	pop    %ebp
  80f131:	c3                   	ret    

0080f132 <vcprintf>:

int
vcprintf(const char *fmt, va_list ap)
{
  80f132:	55                   	push   %ebp
  80f133:	89 e5                	mov    %esp,%ebp
  80f135:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  80f13b:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  80f142:	00 00 00 
	b.cnt = 0;
  80f145:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  80f14c:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  80f14f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f152:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f156:	8b 45 08             	mov    0x8(%ebp),%eax
  80f159:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f15d:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  80f163:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f167:	c7 04 24 f0 f0 80 00 	movl   $0x80f0f0,(%esp)
  80f16e:	e8 ab 01 00 00       	call   80f31e <vprintfmt>
	sys_cputs(b.buf, b.idx);
  80f173:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  80f179:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f17d:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  80f183:	89 04 24             	mov    %eax,(%esp)
  80f186:	e8 7b 09 00 00       	call   80fb06 <sys_cputs>

	return b.cnt;
}
  80f18b:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  80f191:	c9                   	leave  
  80f192:	c3                   	ret    

0080f193 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  80f193:	55                   	push   %ebp
  80f194:	89 e5                	mov    %esp,%ebp
  80f196:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  80f199:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  80f19c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1a0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1a3:	89 04 24             	mov    %eax,(%esp)
  80f1a6:	e8 87 ff ff ff       	call   80f132 <vcprintf>
	va_end(ap);

	return cnt;
}
  80f1ab:	c9                   	leave  
  80f1ac:	c3                   	ret    
  80f1ad:	66 90                	xchg   %ax,%ax
  80f1af:	90                   	nop

0080f1b0 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  80f1b0:	55                   	push   %ebp
  80f1b1:	89 e5                	mov    %esp,%ebp
  80f1b3:	57                   	push   %edi
  80f1b4:	56                   	push   %esi
  80f1b5:	53                   	push   %ebx
  80f1b6:	83 ec 3c             	sub    $0x3c,%esp
  80f1b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f1bc:	89 d7                	mov    %edx,%edi
  80f1be:	8b 45 08             	mov    0x8(%ebp),%eax
  80f1c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80f1c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f1c7:	89 c3                	mov    %eax,%ebx
  80f1c9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80f1cc:	8b 45 10             	mov    0x10(%ebp),%eax
  80f1cf:	8b 75 14             	mov    0x14(%ebp),%esi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  80f1d2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80f1d7:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80f1da:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80f1dd:	39 d9                	cmp    %ebx,%ecx
  80f1df:	72 05                	jb     80f1e6 <printnum+0x36>
  80f1e1:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80f1e4:	77 69                	ja     80f24f <printnum+0x9f>
		printnum(putch, putdat, num / base, base, width - 1, padc);
  80f1e6:	8b 4d 18             	mov    0x18(%ebp),%ecx
  80f1e9:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  80f1ed:	83 ee 01             	sub    $0x1,%esi
  80f1f0:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f1f4:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f1f8:	8b 44 24 08          	mov    0x8(%esp),%eax
  80f1fc:	8b 54 24 0c          	mov    0xc(%esp),%edx
  80f200:	89 c3                	mov    %eax,%ebx
  80f202:	89 d6                	mov    %edx,%esi
  80f204:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80f207:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80f20a:	89 54 24 08          	mov    %edx,0x8(%esp)
  80f20e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  80f212:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f215:	89 04 24             	mov    %eax,(%esp)
  80f218:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f21b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f21f:	e8 cc 28 00 00       	call   811af0 <__udivdi3>
  80f224:	89 d9                	mov    %ebx,%ecx
  80f226:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f22a:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f22e:	89 04 24             	mov    %eax,(%esp)
  80f231:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f235:	89 fa                	mov    %edi,%edx
  80f237:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f23a:	e8 71 ff ff ff       	call   80f1b0 <printnum>
  80f23f:	eb 1b                	jmp    80f25c <printnum+0xac>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  80f241:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f245:	8b 45 18             	mov    0x18(%ebp),%eax
  80f248:	89 04 24             	mov    %eax,(%esp)
  80f24b:	ff d3                	call   *%ebx
  80f24d:	eb 03                	jmp    80f252 <printnum+0xa2>
  80f24f:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  80f252:	83 ee 01             	sub    $0x1,%esi
  80f255:	85 f6                	test   %esi,%esi
  80f257:	7f e8                	jg     80f241 <printnum+0x91>
  80f259:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  80f25c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f260:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80f264:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80f267:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80f26a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f26e:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f272:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f275:	89 04 24             	mov    %eax,(%esp)
  80f278:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f27b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f27f:	e8 9c 29 00 00       	call   811c20 <__umoddi3>
  80f284:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f288:	0f be 80 0b 44 81 00 	movsbl 0x81440b(%eax),%eax
  80f28f:	89 04 24             	mov    %eax,(%esp)
  80f292:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80f295:	ff d0                	call   *%eax
}
  80f297:	83 c4 3c             	add    $0x3c,%esp
  80f29a:	5b                   	pop    %ebx
  80f29b:	5e                   	pop    %esi
  80f29c:	5f                   	pop    %edi
  80f29d:	5d                   	pop    %ebp
  80f29e:	c3                   	ret    

0080f29f <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  80f29f:	55                   	push   %ebp
  80f2a0:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  80f2a2:	83 fa 01             	cmp    $0x1,%edx
  80f2a5:	7e 0e                	jle    80f2b5 <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  80f2a7:	8b 10                	mov    (%eax),%edx
  80f2a9:	8d 4a 08             	lea    0x8(%edx),%ecx
  80f2ac:	89 08                	mov    %ecx,(%eax)
  80f2ae:	8b 02                	mov    (%edx),%eax
  80f2b0:	8b 52 04             	mov    0x4(%edx),%edx
  80f2b3:	eb 22                	jmp    80f2d7 <getuint+0x38>
	else if (lflag)
  80f2b5:	85 d2                	test   %edx,%edx
  80f2b7:	74 10                	je     80f2c9 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  80f2b9:	8b 10                	mov    (%eax),%edx
  80f2bb:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f2be:	89 08                	mov    %ecx,(%eax)
  80f2c0:	8b 02                	mov    (%edx),%eax
  80f2c2:	ba 00 00 00 00       	mov    $0x0,%edx
  80f2c7:	eb 0e                	jmp    80f2d7 <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  80f2c9:	8b 10                	mov    (%eax),%edx
  80f2cb:	8d 4a 04             	lea    0x4(%edx),%ecx
  80f2ce:	89 08                	mov    %ecx,(%eax)
  80f2d0:	8b 02                	mov    (%edx),%eax
  80f2d2:	ba 00 00 00 00       	mov    $0x0,%edx
}
  80f2d7:	5d                   	pop    %ebp
  80f2d8:	c3                   	ret    

0080f2d9 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  80f2d9:	55                   	push   %ebp
  80f2da:	89 e5                	mov    %esp,%ebp
  80f2dc:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  80f2df:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  80f2e3:	8b 10                	mov    (%eax),%edx
  80f2e5:	3b 50 04             	cmp    0x4(%eax),%edx
  80f2e8:	73 0a                	jae    80f2f4 <sprintputch+0x1b>
		*b->buf++ = ch;
  80f2ea:	8d 4a 01             	lea    0x1(%edx),%ecx
  80f2ed:	89 08                	mov    %ecx,(%eax)
  80f2ef:	8b 45 08             	mov    0x8(%ebp),%eax
  80f2f2:	88 02                	mov    %al,(%edx)
}
  80f2f4:	5d                   	pop    %ebp
  80f2f5:	c3                   	ret    

0080f2f6 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  80f2f6:	55                   	push   %ebp
  80f2f7:	89 e5                	mov    %esp,%ebp
  80f2f9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  80f2fc:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  80f2ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f303:	8b 45 10             	mov    0x10(%ebp),%eax
  80f306:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f30a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f30d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f311:	8b 45 08             	mov    0x8(%ebp),%eax
  80f314:	89 04 24             	mov    %eax,(%esp)
  80f317:	e8 02 00 00 00       	call   80f31e <vprintfmt>
	va_end(ap);
}
  80f31c:	c9                   	leave  
  80f31d:	c3                   	ret    

0080f31e <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  80f31e:	55                   	push   %ebp
  80f31f:	89 e5                	mov    %esp,%ebp
  80f321:	57                   	push   %edi
  80f322:	56                   	push   %esi
  80f323:	53                   	push   %ebx
  80f324:	83 ec 3c             	sub    $0x3c,%esp
  80f327:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f32a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f32d:	eb 14                	jmp    80f343 <vprintfmt+0x25>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  80f32f:	85 c0                	test   %eax,%eax
  80f331:	0f 84 b3 03 00 00    	je     80f6ea <vprintfmt+0x3cc>
				return;
			putch(ch, putdat);
  80f337:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f33b:	89 04 24             	mov    %eax,(%esp)
  80f33e:	ff 55 08             	call   *0x8(%ebp)
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  80f341:	89 f3                	mov    %esi,%ebx
  80f343:	8d 73 01             	lea    0x1(%ebx),%esi
  80f346:	0f b6 03             	movzbl (%ebx),%eax
  80f349:	83 f8 25             	cmp    $0x25,%eax
  80f34c:	75 e1                	jne    80f32f <vprintfmt+0x11>
  80f34e:	c6 45 d8 20          	movb   $0x20,-0x28(%ebp)
  80f352:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  80f359:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
  80f360:	c7 45 dc ff ff ff ff 	movl   $0xffffffff,-0x24(%ebp)
  80f367:	ba 00 00 00 00       	mov    $0x0,%edx
  80f36c:	eb 1d                	jmp    80f38b <vprintfmt+0x6d>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f36e:	89 de                	mov    %ebx,%esi

		// flag to pad on the right
		case '-':
			padc = '-';
  80f370:	c6 45 d8 2d          	movb   $0x2d,-0x28(%ebp)
  80f374:	eb 15                	jmp    80f38b <vprintfmt+0x6d>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f376:	89 de                	mov    %ebx,%esi
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  80f378:	c6 45 d8 30          	movb   $0x30,-0x28(%ebp)
  80f37c:	eb 0d                	jmp    80f38b <vprintfmt+0x6d>
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
  80f37e:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80f381:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80f384:	c7 45 d4 ff ff ff ff 	movl   $0xffffffff,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f38b:	8d 5e 01             	lea    0x1(%esi),%ebx
  80f38e:	0f b6 0e             	movzbl (%esi),%ecx
  80f391:	0f b6 c1             	movzbl %cl,%eax
  80f394:	83 e9 23             	sub    $0x23,%ecx
  80f397:	80 f9 55             	cmp    $0x55,%cl
  80f39a:	0f 87 2a 03 00 00    	ja     80f6ca <vprintfmt+0x3ac>
  80f3a0:	0f b6 c9             	movzbl %cl,%ecx
  80f3a3:	ff 24 8d 40 45 81 00 	jmp    *0x814540(,%ecx,4)
  80f3aa:	89 de                	mov    %ebx,%esi
  80f3ac:	b9 00 00 00 00       	mov    $0x0,%ecx
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  80f3b1:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  80f3b4:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
				ch = *fmt;
  80f3b8:	0f be 06             	movsbl (%esi),%eax
				if (ch < '0' || ch > '9')
  80f3bb:	8d 58 d0             	lea    -0x30(%eax),%ebx
  80f3be:	83 fb 09             	cmp    $0x9,%ebx
  80f3c1:	77 36                	ja     80f3f9 <vprintfmt+0xdb>
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  80f3c3:	83 c6 01             	add    $0x1,%esi
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
					break;
			}
  80f3c6:	eb e9                	jmp    80f3b1 <vprintfmt+0x93>
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  80f3c8:	8b 45 14             	mov    0x14(%ebp),%eax
  80f3cb:	8d 48 04             	lea    0x4(%eax),%ecx
  80f3ce:	89 4d 14             	mov    %ecx,0x14(%ebp)
  80f3d1:	8b 00                	mov    (%eax),%eax
  80f3d3:	89 45 d4             	mov    %eax,-0x2c(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f3d6:	89 de                	mov    %ebx,%esi
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  80f3d8:	eb 22                	jmp    80f3fc <vprintfmt+0xde>
  80f3da:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80f3dd:	85 c9                	test   %ecx,%ecx
  80f3df:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3e4:	0f 49 c1             	cmovns %ecx,%eax
  80f3e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f3ea:	89 de                	mov    %ebx,%esi
  80f3ec:	eb 9d                	jmp    80f38b <vprintfmt+0x6d>
  80f3ee:	89 de                	mov    %ebx,%esi
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  80f3f0:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
			goto reswitch;
  80f3f7:	eb 92                	jmp    80f38b <vprintfmt+0x6d>
  80f3f9:	89 4d d4             	mov    %ecx,-0x2c(%ebp)

		process_precision:
			if (width < 0)
  80f3fc:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80f400:	79 89                	jns    80f38b <vprintfmt+0x6d>
  80f402:	e9 77 ff ff ff       	jmp    80f37e <vprintfmt+0x60>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  80f407:	83 c2 01             	add    $0x1,%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f40a:	89 de                	mov    %ebx,%esi
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
			goto reswitch;
  80f40c:	e9 7a ff ff ff       	jmp    80f38b <vprintfmt+0x6d>

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  80f411:	8b 45 14             	mov    0x14(%ebp),%eax
  80f414:	8d 50 04             	lea    0x4(%eax),%edx
  80f417:	89 55 14             	mov    %edx,0x14(%ebp)
  80f41a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f41e:	8b 00                	mov    (%eax),%eax
  80f420:	89 04 24             	mov    %eax,(%esp)
  80f423:	ff 55 08             	call   *0x8(%ebp)
			break;
  80f426:	e9 18 ff ff ff       	jmp    80f343 <vprintfmt+0x25>

		// error message
		case 'e':
			err = va_arg(ap, int);
  80f42b:	8b 45 14             	mov    0x14(%ebp),%eax
  80f42e:	8d 50 04             	lea    0x4(%eax),%edx
  80f431:	89 55 14             	mov    %edx,0x14(%ebp)
  80f434:	8b 00                	mov    (%eax),%eax
  80f436:	99                   	cltd   
  80f437:	31 d0                	xor    %edx,%eax
  80f439:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err >= MAXERROR || (p = error_string[err]) == NULL)
  80f43b:	83 f8 11             	cmp    $0x11,%eax
  80f43e:	7f 0b                	jg     80f44b <vprintfmt+0x12d>
  80f440:	8b 14 85 a0 46 81 00 	mov    0x8146a0(,%eax,4),%edx
  80f447:	85 d2                	test   %edx,%edx
  80f449:	75 20                	jne    80f46b <vprintfmt+0x14d>
				printfmt(putch, putdat, "error %d", err);
  80f44b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f44f:	c7 44 24 08 23 44 81 	movl   $0x814423,0x8(%esp)
  80f456:	00 
  80f457:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f45b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f45e:	89 04 24             	mov    %eax,(%esp)
  80f461:	e8 90 fe ff ff       	call   80f2f6 <printfmt>
  80f466:	e9 d8 fe ff ff       	jmp    80f343 <vprintfmt+0x25>
			else
				printfmt(putch, putdat, "%s", p);
  80f46b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f46f:	c7 44 24 08 f1 35 81 	movl   $0x8135f1,0x8(%esp)
  80f476:	00 
  80f477:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f47b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f47e:	89 04 24             	mov    %eax,(%esp)
  80f481:	e8 70 fe ff ff       	call   80f2f6 <printfmt>
  80f486:	e9 b8 fe ff ff       	jmp    80f343 <vprintfmt+0x25>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  80f48b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80f48e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f491:	89 45 d0             	mov    %eax,-0x30(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  80f494:	8b 45 14             	mov    0x14(%ebp),%eax
  80f497:	8d 50 04             	lea    0x4(%eax),%edx
  80f49a:	89 55 14             	mov    %edx,0x14(%ebp)
  80f49d:	8b 30                	mov    (%eax),%esi
				p = "(null)";
  80f49f:	85 f6                	test   %esi,%esi
  80f4a1:	b8 1c 44 81 00       	mov    $0x81441c,%eax
  80f4a6:	0f 44 f0             	cmove  %eax,%esi
			if (width > 0 && padc != '-')
  80f4a9:	80 7d d8 2d          	cmpb   $0x2d,-0x28(%ebp)
  80f4ad:	0f 84 97 00 00 00    	je     80f54a <vprintfmt+0x22c>
  80f4b3:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80f4b7:	0f 8e 9b 00 00 00    	jle    80f558 <vprintfmt+0x23a>
				for (width -= strnlen(p, precision); width > 0; width--)
  80f4bd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80f4c1:	89 34 24             	mov    %esi,(%esp)
  80f4c4:	e8 cf 02 00 00       	call   80f798 <strnlen>
  80f4c9:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80f4cc:	29 c2                	sub    %eax,%edx
  80f4ce:	89 55 d0             	mov    %edx,-0x30(%ebp)
					putch(padc, putdat);
  80f4d1:	0f be 45 d8          	movsbl -0x28(%ebp),%eax
  80f4d5:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80f4d8:	89 75 d8             	mov    %esi,-0x28(%ebp)
  80f4db:	8b 75 08             	mov    0x8(%ebp),%esi
  80f4de:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f4e1:	89 d3                	mov    %edx,%ebx
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f4e3:	eb 0f                	jmp    80f4f4 <vprintfmt+0x1d6>
					putch(padc, putdat);
  80f4e5:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f4e9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f4ec:	89 04 24             	mov    %eax,(%esp)
  80f4ef:	ff d6                	call   *%esi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  80f4f1:	83 eb 01             	sub    $0x1,%ebx
  80f4f4:	85 db                	test   %ebx,%ebx
  80f4f6:	7f ed                	jg     80f4e5 <vprintfmt+0x1c7>
  80f4f8:	8b 75 d8             	mov    -0x28(%ebp),%esi
  80f4fb:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80f4fe:	85 d2                	test   %edx,%edx
  80f500:	b8 00 00 00 00       	mov    $0x0,%eax
  80f505:	0f 49 c2             	cmovns %edx,%eax
  80f508:	29 c2                	sub    %eax,%edx
  80f50a:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f50d:	89 d7                	mov    %edx,%edi
  80f50f:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f512:	eb 50                	jmp    80f564 <vprintfmt+0x246>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  80f514:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80f518:	74 1e                	je     80f538 <vprintfmt+0x21a>
  80f51a:	0f be d2             	movsbl %dl,%edx
  80f51d:	83 ea 20             	sub    $0x20,%edx
  80f520:	83 fa 5e             	cmp    $0x5e,%edx
  80f523:	76 13                	jbe    80f538 <vprintfmt+0x21a>
					putch('?', putdat);
  80f525:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f528:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f52c:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  80f533:	ff 55 08             	call   *0x8(%ebp)
  80f536:	eb 0d                	jmp    80f545 <vprintfmt+0x227>
				else
					putch(ch, putdat);
  80f538:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f53b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f53f:	89 04 24             	mov    %eax,(%esp)
  80f542:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  80f545:	83 ef 01             	sub    $0x1,%edi
  80f548:	eb 1a                	jmp    80f564 <vprintfmt+0x246>
  80f54a:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f54d:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80f550:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f553:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f556:	eb 0c                	jmp    80f564 <vprintfmt+0x246>
  80f558:	89 7d 0c             	mov    %edi,0xc(%ebp)
  80f55b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80f55e:	89 5d 10             	mov    %ebx,0x10(%ebp)
  80f561:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  80f564:	83 c6 01             	add    $0x1,%esi
  80f567:	0f b6 56 ff          	movzbl -0x1(%esi),%edx
  80f56b:	0f be c2             	movsbl %dl,%eax
  80f56e:	85 c0                	test   %eax,%eax
  80f570:	74 27                	je     80f599 <vprintfmt+0x27b>
  80f572:	85 db                	test   %ebx,%ebx
  80f574:	78 9e                	js     80f514 <vprintfmt+0x1f6>
  80f576:	83 eb 01             	sub    $0x1,%ebx
  80f579:	79 99                	jns    80f514 <vprintfmt+0x1f6>
  80f57b:	89 f8                	mov    %edi,%eax
  80f57d:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f580:	8b 75 08             	mov    0x8(%ebp),%esi
  80f583:	89 c3                	mov    %eax,%ebx
  80f585:	eb 1a                	jmp    80f5a1 <vprintfmt+0x283>
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  80f587:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f58b:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f592:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  80f594:	83 eb 01             	sub    $0x1,%ebx
  80f597:	eb 08                	jmp    80f5a1 <vprintfmt+0x283>
  80f599:	89 fb                	mov    %edi,%ebx
  80f59b:	8b 75 08             	mov    0x8(%ebp),%esi
  80f59e:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80f5a1:	85 db                	test   %ebx,%ebx
  80f5a3:	7f e2                	jg     80f587 <vprintfmt+0x269>
  80f5a5:	89 75 08             	mov    %esi,0x8(%ebp)
  80f5a8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80f5ab:	e9 93 fd ff ff       	jmp    80f343 <vprintfmt+0x25>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  80f5b0:	83 fa 01             	cmp    $0x1,%edx
  80f5b3:	7e 16                	jle    80f5cb <vprintfmt+0x2ad>
		return va_arg(*ap, long long);
  80f5b5:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5b8:	8d 50 08             	lea    0x8(%eax),%edx
  80f5bb:	89 55 14             	mov    %edx,0x14(%ebp)
  80f5be:	8b 50 04             	mov    0x4(%eax),%edx
  80f5c1:	8b 00                	mov    (%eax),%eax
  80f5c3:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80f5c6:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80f5c9:	eb 32                	jmp    80f5fd <vprintfmt+0x2df>
	else if (lflag)
  80f5cb:	85 d2                	test   %edx,%edx
  80f5cd:	74 18                	je     80f5e7 <vprintfmt+0x2c9>
		return va_arg(*ap, long);
  80f5cf:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5d2:	8d 50 04             	lea    0x4(%eax),%edx
  80f5d5:	89 55 14             	mov    %edx,0x14(%ebp)
  80f5d8:	8b 30                	mov    (%eax),%esi
  80f5da:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80f5dd:	89 f0                	mov    %esi,%eax
  80f5df:	c1 f8 1f             	sar    $0x1f,%eax
  80f5e2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f5e5:	eb 16                	jmp    80f5fd <vprintfmt+0x2df>
	else
		return va_arg(*ap, int);
  80f5e7:	8b 45 14             	mov    0x14(%ebp),%eax
  80f5ea:	8d 50 04             	lea    0x4(%eax),%edx
  80f5ed:	89 55 14             	mov    %edx,0x14(%ebp)
  80f5f0:	8b 30                	mov    (%eax),%esi
  80f5f2:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80f5f5:	89 f0                	mov    %esi,%eax
  80f5f7:	c1 f8 1f             	sar    $0x1f,%eax
  80f5fa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  80f5fd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f600:	8b 55 e4             	mov    -0x1c(%ebp),%edx
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  80f603:	b9 0a 00 00 00       	mov    $0xa,%ecx
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  80f608:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80f60c:	0f 89 80 00 00 00    	jns    80f692 <vprintfmt+0x374>
				putch('-', putdat);
  80f612:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f616:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  80f61d:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  80f620:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80f623:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80f626:	f7 d8                	neg    %eax
  80f628:	83 d2 00             	adc    $0x0,%edx
  80f62b:	f7 da                	neg    %edx
			}
			base = 10;
  80f62d:	b9 0a 00 00 00       	mov    $0xa,%ecx
  80f632:	eb 5e                	jmp    80f692 <vprintfmt+0x374>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  80f634:	8d 45 14             	lea    0x14(%ebp),%eax
  80f637:	e8 63 fc ff ff       	call   80f29f <getuint>
			base = 10;
  80f63c:	b9 0a 00 00 00       	mov    $0xa,%ecx
			goto number;
  80f641:	eb 4f                	jmp    80f692 <vprintfmt+0x374>

		// (unsigned) octal
		case 'o':
			num = getuint(&ap, lflag);
  80f643:	8d 45 14             	lea    0x14(%ebp),%eax
  80f646:	e8 54 fc ff ff       	call   80f29f <getuint>
			base = 8;
  80f64b:	b9 08 00 00 00       	mov    $0x8,%ecx
			goto number;
  80f650:	eb 40                	jmp    80f692 <vprintfmt+0x374>

		// pointer
		case 'p':
			putch('0', putdat);
  80f652:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f656:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  80f65d:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  80f660:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f664:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  80f66b:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  80f66e:	8b 45 14             	mov    0x14(%ebp),%eax
  80f671:	8d 50 04             	lea    0x4(%eax),%edx
  80f674:	89 55 14             	mov    %edx,0x14(%ebp)

		// pointer
		case 'p':
			putch('0', putdat);
			putch('x', putdat);
			num = (unsigned long long)
  80f677:	8b 00                	mov    (%eax),%eax
  80f679:	ba 00 00 00 00       	mov    $0x0,%edx
				(uintptr_t) va_arg(ap, void *);
			base = 16;
  80f67e:	b9 10 00 00 00       	mov    $0x10,%ecx
			goto number;
  80f683:	eb 0d                	jmp    80f692 <vprintfmt+0x374>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  80f685:	8d 45 14             	lea    0x14(%ebp),%eax
  80f688:	e8 12 fc ff ff       	call   80f29f <getuint>
			base = 16;
  80f68d:	b9 10 00 00 00       	mov    $0x10,%ecx
		number:
			printnum(putch, putdat, num, base, width, padc);
  80f692:	0f be 75 d8          	movsbl -0x28(%ebp),%esi
  80f696:	89 74 24 10          	mov    %esi,0x10(%esp)
  80f69a:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80f69d:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80f6a1:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f6a5:	89 04 24             	mov    %eax,(%esp)
  80f6a8:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f6ac:	89 fa                	mov    %edi,%edx
  80f6ae:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6b1:	e8 fa fa ff ff       	call   80f1b0 <printnum>
			break;
  80f6b6:	e9 88 fc ff ff       	jmp    80f343 <vprintfmt+0x25>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80f6bb:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f6bf:	89 04 24             	mov    %eax,(%esp)
  80f6c2:	ff 55 08             	call   *0x8(%ebp)
			break;
  80f6c5:	e9 79 fc ff ff       	jmp    80f343 <vprintfmt+0x25>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80f6ca:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80f6ce:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80f6d5:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  80f6d8:	89 f3                	mov    %esi,%ebx
  80f6da:	eb 03                	jmp    80f6df <vprintfmt+0x3c1>
  80f6dc:	83 eb 01             	sub    $0x1,%ebx
  80f6df:	80 7b ff 25          	cmpb   $0x25,-0x1(%ebx)
  80f6e3:	75 f7                	jne    80f6dc <vprintfmt+0x3be>
  80f6e5:	e9 59 fc ff ff       	jmp    80f343 <vprintfmt+0x25>
				/* do nothing */;
			break;
		}
	}
}
  80f6ea:	83 c4 3c             	add    $0x3c,%esp
  80f6ed:	5b                   	pop    %ebx
  80f6ee:	5e                   	pop    %esi
  80f6ef:	5f                   	pop    %edi
  80f6f0:	5d                   	pop    %ebp
  80f6f1:	c3                   	ret    

0080f6f2 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  80f6f2:	55                   	push   %ebp
  80f6f3:	89 e5                	mov    %esp,%ebp
  80f6f5:	83 ec 28             	sub    $0x28,%esp
  80f6f8:	8b 45 08             	mov    0x8(%ebp),%eax
  80f6fb:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  80f6fe:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80f701:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  80f705:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  80f708:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
  80f70f:	85 c0                	test   %eax,%eax
  80f711:	74 30                	je     80f743 <vsnprintf+0x51>
  80f713:	85 d2                	test   %edx,%edx
  80f715:	7e 2c                	jle    80f743 <vsnprintf+0x51>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  80f717:	8b 45 14             	mov    0x14(%ebp),%eax
  80f71a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f71e:	8b 45 10             	mov    0x10(%ebp),%eax
  80f721:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f725:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80f728:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f72c:	c7 04 24 d9 f2 80 00 	movl   $0x80f2d9,(%esp)
  80f733:	e8 e6 fb ff ff       	call   80f31e <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  80f738:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80f73b:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  80f73e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f741:	eb 05                	jmp    80f748 <vsnprintf+0x56>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80f743:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80f748:	c9                   	leave  
  80f749:	c3                   	ret    

0080f74a <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  80f74a:	55                   	push   %ebp
  80f74b:	89 e5                	mov    %esp,%ebp
  80f74d:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  80f750:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80f753:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f757:	8b 45 10             	mov    0x10(%ebp),%eax
  80f75a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f75e:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f761:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f765:	8b 45 08             	mov    0x8(%ebp),%eax
  80f768:	89 04 24             	mov    %eax,(%esp)
  80f76b:	e8 82 ff ff ff       	call   80f6f2 <vsnprintf>
	va_end(ap);

	return rc;
}
  80f770:	c9                   	leave  
  80f771:	c3                   	ret    
  80f772:	66 90                	xchg   %ax,%ax
  80f774:	66 90                	xchg   %ax,%ax
  80f776:	66 90                	xchg   %ax,%ax
  80f778:	66 90                	xchg   %ax,%ax
  80f77a:	66 90                	xchg   %ax,%ax
  80f77c:	66 90                	xchg   %ax,%ax
  80f77e:	66 90                	xchg   %ax,%ax

0080f780 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  80f780:	55                   	push   %ebp
  80f781:	89 e5                	mov    %esp,%ebp
  80f783:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  80f786:	b8 00 00 00 00       	mov    $0x0,%eax
  80f78b:	eb 03                	jmp    80f790 <strlen+0x10>
		n++;
  80f78d:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  80f790:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  80f794:	75 f7                	jne    80f78d <strlen+0xd>
		n++;
	return n;
}
  80f796:	5d                   	pop    %ebp
  80f797:	c3                   	ret    

0080f798 <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80f798:	55                   	push   %ebp
  80f799:	89 e5                	mov    %esp,%ebp
  80f79b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f79e:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f7a1:	b8 00 00 00 00       	mov    $0x0,%eax
  80f7a6:	eb 03                	jmp    80f7ab <strnlen+0x13>
		n++;
  80f7a8:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  80f7ab:	39 d0                	cmp    %edx,%eax
  80f7ad:	74 06                	je     80f7b5 <strnlen+0x1d>
  80f7af:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  80f7b3:	75 f3                	jne    80f7a8 <strnlen+0x10>
		n++;
	return n;
}
  80f7b5:	5d                   	pop    %ebp
  80f7b6:	c3                   	ret    

0080f7b7 <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80f7b7:	55                   	push   %ebp
  80f7b8:	89 e5                	mov    %esp,%ebp
  80f7ba:	53                   	push   %ebx
  80f7bb:	8b 45 08             	mov    0x8(%ebp),%eax
  80f7be:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  80f7c1:	89 c2                	mov    %eax,%edx
  80f7c3:	83 c2 01             	add    $0x1,%edx
  80f7c6:	83 c1 01             	add    $0x1,%ecx
  80f7c9:	0f b6 59 ff          	movzbl -0x1(%ecx),%ebx
  80f7cd:	88 5a ff             	mov    %bl,-0x1(%edx)
  80f7d0:	84 db                	test   %bl,%bl
  80f7d2:	75 ef                	jne    80f7c3 <strcpy+0xc>
		/* do nothing */;
	return ret;
}
  80f7d4:	5b                   	pop    %ebx
  80f7d5:	5d                   	pop    %ebp
  80f7d6:	c3                   	ret    

0080f7d7 <strcat>:

char *
strcat(char *dst, const char *src)
{
  80f7d7:	55                   	push   %ebp
  80f7d8:	89 e5                	mov    %esp,%ebp
  80f7da:	53                   	push   %ebx
  80f7db:	83 ec 08             	sub    $0x8,%esp
  80f7de:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int len = strlen(dst);
  80f7e1:	89 1c 24             	mov    %ebx,(%esp)
  80f7e4:	e8 97 ff ff ff       	call   80f780 <strlen>
	strcpy(dst + len, src);
  80f7e9:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f7ec:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f7f0:	01 d8                	add    %ebx,%eax
  80f7f2:	89 04 24             	mov    %eax,(%esp)
  80f7f5:	e8 bd ff ff ff       	call   80f7b7 <strcpy>
	return dst;
}
  80f7fa:	89 d8                	mov    %ebx,%eax
  80f7fc:	83 c4 08             	add    $0x8,%esp
  80f7ff:	5b                   	pop    %ebx
  80f800:	5d                   	pop    %ebp
  80f801:	c3                   	ret    

0080f802 <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80f802:	55                   	push   %ebp
  80f803:	89 e5                	mov    %esp,%ebp
  80f805:	56                   	push   %esi
  80f806:	53                   	push   %ebx
  80f807:	8b 75 08             	mov    0x8(%ebp),%esi
  80f80a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f80d:	89 f3                	mov    %esi,%ebx
  80f80f:	03 5d 10             	add    0x10(%ebp),%ebx
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f812:	89 f2                	mov    %esi,%edx
  80f814:	eb 0f                	jmp    80f825 <strncpy+0x23>
		*dst++ = *src;
  80f816:	83 c2 01             	add    $0x1,%edx
  80f819:	0f b6 01             	movzbl (%ecx),%eax
  80f81c:	88 42 ff             	mov    %al,-0x1(%edx)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  80f81f:	80 39 01             	cmpb   $0x1,(%ecx)
  80f822:	83 d9 ff             	sbb    $0xffffffff,%ecx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80f825:	39 da                	cmp    %ebx,%edx
  80f827:	75 ed                	jne    80f816 <strncpy+0x14>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  80f829:	89 f0                	mov    %esi,%eax
  80f82b:	5b                   	pop    %ebx
  80f82c:	5e                   	pop    %esi
  80f82d:	5d                   	pop    %ebp
  80f82e:	c3                   	ret    

0080f82f <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  80f82f:	55                   	push   %ebp
  80f830:	89 e5                	mov    %esp,%ebp
  80f832:	56                   	push   %esi
  80f833:	53                   	push   %ebx
  80f834:	8b 75 08             	mov    0x8(%ebp),%esi
  80f837:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f83a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80f83d:	89 f0                	mov    %esi,%eax
  80f83f:	8d 5c 0e ff          	lea    -0x1(%esi,%ecx,1),%ebx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  80f843:	85 c9                	test   %ecx,%ecx
  80f845:	75 0b                	jne    80f852 <strlcpy+0x23>
  80f847:	eb 1d                	jmp    80f866 <strlcpy+0x37>
		while (--size > 0 && *src != '\0')
			*dst++ = *src++;
  80f849:	83 c0 01             	add    $0x1,%eax
  80f84c:	83 c2 01             	add    $0x1,%edx
  80f84f:	88 48 ff             	mov    %cl,-0x1(%eax)
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  80f852:	39 d8                	cmp    %ebx,%eax
  80f854:	74 0b                	je     80f861 <strlcpy+0x32>
  80f856:	0f b6 0a             	movzbl (%edx),%ecx
  80f859:	84 c9                	test   %cl,%cl
  80f85b:	75 ec                	jne    80f849 <strlcpy+0x1a>
  80f85d:	89 c2                	mov    %eax,%edx
  80f85f:	eb 02                	jmp    80f863 <strlcpy+0x34>
  80f861:	89 c2                	mov    %eax,%edx
			*dst++ = *src++;
		*dst = '\0';
  80f863:	c6 02 00             	movb   $0x0,(%edx)
	}
	return dst - dst_in;
  80f866:	29 f0                	sub    %esi,%eax
}
  80f868:	5b                   	pop    %ebx
  80f869:	5e                   	pop    %esi
  80f86a:	5d                   	pop    %ebp
  80f86b:	c3                   	ret    

0080f86c <strcmp>:

int
strcmp(const char *p, const char *q)
{
  80f86c:	55                   	push   %ebp
  80f86d:	89 e5                	mov    %esp,%ebp
  80f86f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f872:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80f875:	eb 06                	jmp    80f87d <strcmp+0x11>
		p++, q++;
  80f877:	83 c1 01             	add    $0x1,%ecx
  80f87a:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  80f87d:	0f b6 01             	movzbl (%ecx),%eax
  80f880:	84 c0                	test   %al,%al
  80f882:	74 04                	je     80f888 <strcmp+0x1c>
  80f884:	3a 02                	cmp    (%edx),%al
  80f886:	74 ef                	je     80f877 <strcmp+0xb>
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
  80f888:	0f b6 c0             	movzbl %al,%eax
  80f88b:	0f b6 12             	movzbl (%edx),%edx
  80f88e:	29 d0                	sub    %edx,%eax
}
  80f890:	5d                   	pop    %ebp
  80f891:	c3                   	ret    

0080f892 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80f892:	55                   	push   %ebp
  80f893:	89 e5                	mov    %esp,%ebp
  80f895:	53                   	push   %ebx
  80f896:	8b 45 08             	mov    0x8(%ebp),%eax
  80f899:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f89c:	89 c3                	mov    %eax,%ebx
  80f89e:	03 5d 10             	add    0x10(%ebp),%ebx
	while (n > 0 && *p && *p == *q)
  80f8a1:	eb 06                	jmp    80f8a9 <strncmp+0x17>
		n--, p++, q++;
  80f8a3:	83 c0 01             	add    $0x1,%eax
  80f8a6:	83 c2 01             	add    $0x1,%edx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80f8a9:	39 d8                	cmp    %ebx,%eax
  80f8ab:	74 15                	je     80f8c2 <strncmp+0x30>
  80f8ad:	0f b6 08             	movzbl (%eax),%ecx
  80f8b0:	84 c9                	test   %cl,%cl
  80f8b2:	74 04                	je     80f8b8 <strncmp+0x26>
  80f8b4:	3a 0a                	cmp    (%edx),%cl
  80f8b6:	74 eb                	je     80f8a3 <strncmp+0x11>
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  80f8b8:	0f b6 00             	movzbl (%eax),%eax
  80f8bb:	0f b6 12             	movzbl (%edx),%edx
  80f8be:	29 d0                	sub    %edx,%eax
  80f8c0:	eb 05                	jmp    80f8c7 <strncmp+0x35>
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
  80f8c2:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  80f8c7:	5b                   	pop    %ebx
  80f8c8:	5d                   	pop    %ebp
  80f8c9:	c3                   	ret    

0080f8ca <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80f8ca:	55                   	push   %ebp
  80f8cb:	89 e5                	mov    %esp,%ebp
  80f8cd:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8d0:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f8d4:	eb 07                	jmp    80f8dd <strchr+0x13>
		if (*s == c)
  80f8d6:	38 ca                	cmp    %cl,%dl
  80f8d8:	74 0f                	je     80f8e9 <strchr+0x1f>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80f8da:	83 c0 01             	add    $0x1,%eax
  80f8dd:	0f b6 10             	movzbl (%eax),%edx
  80f8e0:	84 d2                	test   %dl,%dl
  80f8e2:	75 f2                	jne    80f8d6 <strchr+0xc>
		if (*s == c)
			return (char *) s;
	return 0;
  80f8e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f8e9:	5d                   	pop    %ebp
  80f8ea:	c3                   	ret    

0080f8eb <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80f8eb:	55                   	push   %ebp
  80f8ec:	89 e5                	mov    %esp,%ebp
  80f8ee:	8b 45 08             	mov    0x8(%ebp),%eax
  80f8f1:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  80f8f5:	eb 07                	jmp    80f8fe <strfind+0x13>
		if (*s == c)
  80f8f7:	38 ca                	cmp    %cl,%dl
  80f8f9:	74 0a                	je     80f905 <strfind+0x1a>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  80f8fb:	83 c0 01             	add    $0x1,%eax
  80f8fe:	0f b6 10             	movzbl (%eax),%edx
  80f901:	84 d2                	test   %dl,%dl
  80f903:	75 f2                	jne    80f8f7 <strfind+0xc>
		if (*s == c)
			break;
	return (char *) s;
}
  80f905:	5d                   	pop    %ebp
  80f906:	c3                   	ret    

0080f907 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  80f907:	55                   	push   %ebp
  80f908:	89 e5                	mov    %esp,%ebp
  80f90a:	57                   	push   %edi
  80f90b:	56                   	push   %esi
  80f90c:	53                   	push   %ebx
  80f90d:	8b 7d 08             	mov    0x8(%ebp),%edi
  80f910:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  80f913:	85 c9                	test   %ecx,%ecx
  80f915:	74 36                	je     80f94d <memset+0x46>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  80f917:	f7 c7 03 00 00 00    	test   $0x3,%edi
  80f91d:	75 28                	jne    80f947 <memset+0x40>
  80f91f:	f6 c1 03             	test   $0x3,%cl
  80f922:	75 23                	jne    80f947 <memset+0x40>
		c &= 0xFF;
  80f924:	0f b6 55 0c          	movzbl 0xc(%ebp),%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80f928:	89 d3                	mov    %edx,%ebx
  80f92a:	c1 e3 08             	shl    $0x8,%ebx
  80f92d:	89 d6                	mov    %edx,%esi
  80f92f:	c1 e6 18             	shl    $0x18,%esi
  80f932:	89 d0                	mov    %edx,%eax
  80f934:	c1 e0 10             	shl    $0x10,%eax
  80f937:	09 f0                	or     %esi,%eax
  80f939:	09 c2                	or     %eax,%edx
  80f93b:	89 d0                	mov    %edx,%eax
  80f93d:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
  80f93f:	c1 e9 02             	shr    $0x2,%ecx
	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
		c &= 0xFF;
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
  80f942:	fc                   	cld    
  80f943:	f3 ab                	rep stos %eax,%es:(%edi)
  80f945:	eb 06                	jmp    80f94d <memset+0x46>
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  80f947:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f94a:	fc                   	cld    
  80f94b:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  80f94d:	89 f8                	mov    %edi,%eax
  80f94f:	5b                   	pop    %ebx
  80f950:	5e                   	pop    %esi
  80f951:	5f                   	pop    %edi
  80f952:	5d                   	pop    %ebp
  80f953:	c3                   	ret    

0080f954 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  80f954:	55                   	push   %ebp
  80f955:	89 e5                	mov    %esp,%ebp
  80f957:	57                   	push   %edi
  80f958:	56                   	push   %esi
  80f959:	8b 45 08             	mov    0x8(%ebp),%eax
  80f95c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80f95f:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;

	s = src;
	d = dst;
	if (s < d && s + n > d) {
  80f962:	39 c6                	cmp    %eax,%esi
  80f964:	73 35                	jae    80f99b <memmove+0x47>
  80f966:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  80f969:	39 d0                	cmp    %edx,%eax
  80f96b:	73 2e                	jae    80f99b <memmove+0x47>
		s += n;
		d += n;
  80f96d:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
  80f970:	89 d6                	mov    %edx,%esi
  80f972:	09 fe                	or     %edi,%esi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f974:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80f97a:	75 13                	jne    80f98f <memmove+0x3b>
  80f97c:	f6 c1 03             	test   $0x3,%cl
  80f97f:	75 0e                	jne    80f98f <memmove+0x3b>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  80f981:	83 ef 04             	sub    $0x4,%edi
  80f984:	8d 72 fc             	lea    -0x4(%edx),%esi
  80f987:	c1 e9 02             	shr    $0x2,%ecx
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
  80f98a:	fd                   	std    
  80f98b:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f98d:	eb 09                	jmp    80f998 <memmove+0x44>
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  80f98f:	83 ef 01             	sub    $0x1,%edi
  80f992:	8d 72 ff             	lea    -0x1(%edx),%esi
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80f995:	fd                   	std    
  80f996:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  80f998:	fc                   	cld    
  80f999:	eb 1d                	jmp    80f9b8 <memmove+0x64>
  80f99b:	89 f2                	mov    %esi,%edx
  80f99d:	09 c2                	or     %eax,%edx
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80f99f:	f6 c2 03             	test   $0x3,%dl
  80f9a2:	75 0f                	jne    80f9b3 <memmove+0x5f>
  80f9a4:	f6 c1 03             	test   $0x3,%cl
  80f9a7:	75 0a                	jne    80f9b3 <memmove+0x5f>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80f9a9:	c1 e9 02             	shr    $0x2,%ecx
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
			asm volatile("cld; rep movsl\n"
  80f9ac:	89 c7                	mov    %eax,%edi
  80f9ae:	fc                   	cld    
  80f9af:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  80f9b1:	eb 05                	jmp    80f9b8 <memmove+0x64>
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  80f9b3:	89 c7                	mov    %eax,%edi
  80f9b5:	fc                   	cld    
  80f9b6:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  80f9b8:	5e                   	pop    %esi
  80f9b9:	5f                   	pop    %edi
  80f9ba:	5d                   	pop    %ebp
  80f9bb:	c3                   	ret    

0080f9bc <memcpy>:
}
#endif

void *
memcpy(void *dst, const void *src, size_t n)
{
  80f9bc:	55                   	push   %ebp
  80f9bd:	89 e5                	mov    %esp,%ebp
  80f9bf:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  80f9c2:	8b 45 10             	mov    0x10(%ebp),%eax
  80f9c5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f9c9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f9cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f9d0:	8b 45 08             	mov    0x8(%ebp),%eax
  80f9d3:	89 04 24             	mov    %eax,(%esp)
  80f9d6:	e8 79 ff ff ff       	call   80f954 <memmove>
}
  80f9db:	c9                   	leave  
  80f9dc:	c3                   	ret    

0080f9dd <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  80f9dd:	55                   	push   %ebp
  80f9de:	89 e5                	mov    %esp,%ebp
  80f9e0:	56                   	push   %esi
  80f9e1:	53                   	push   %ebx
  80f9e2:	8b 55 08             	mov    0x8(%ebp),%edx
  80f9e5:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80f9e8:	89 d6                	mov    %edx,%esi
  80f9ea:	03 75 10             	add    0x10(%ebp),%esi
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80f9ed:	eb 1a                	jmp    80fa09 <memcmp+0x2c>
		if (*s1 != *s2)
  80f9ef:	0f b6 02             	movzbl (%edx),%eax
  80f9f2:	0f b6 19             	movzbl (%ecx),%ebx
  80f9f5:	38 d8                	cmp    %bl,%al
  80f9f7:	74 0a                	je     80fa03 <memcmp+0x26>
			return (int) *s1 - (int) *s2;
  80f9f9:	0f b6 c0             	movzbl %al,%eax
  80f9fc:	0f b6 db             	movzbl %bl,%ebx
  80f9ff:	29 d8                	sub    %ebx,%eax
  80fa01:	eb 0f                	jmp    80fa12 <memcmp+0x35>
		s1++, s2++;
  80fa03:	83 c2 01             	add    $0x1,%edx
  80fa06:	83 c1 01             	add    $0x1,%ecx
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  80fa09:	39 f2                	cmp    %esi,%edx
  80fa0b:	75 e2                	jne    80f9ef <memcmp+0x12>
		if (*s1 != *s2)
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
  80fa0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80fa12:	5b                   	pop    %ebx
  80fa13:	5e                   	pop    %esi
  80fa14:	5d                   	pop    %ebp
  80fa15:	c3                   	ret    

0080fa16 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  80fa16:	55                   	push   %ebp
  80fa17:	89 e5                	mov    %esp,%ebp
  80fa19:	8b 45 08             	mov    0x8(%ebp),%eax
  80fa1c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	const void *ends = (const char *) s + n;
  80fa1f:	89 c2                	mov    %eax,%edx
  80fa21:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  80fa24:	eb 07                	jmp    80fa2d <memfind+0x17>
		if (*(const unsigned char *) s == (unsigned char) c)
  80fa26:	38 08                	cmp    %cl,(%eax)
  80fa28:	74 07                	je     80fa31 <memfind+0x1b>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  80fa2a:	83 c0 01             	add    $0x1,%eax
  80fa2d:	39 d0                	cmp    %edx,%eax
  80fa2f:	72 f5                	jb     80fa26 <memfind+0x10>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  80fa31:	5d                   	pop    %ebp
  80fa32:	c3                   	ret    

0080fa33 <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80fa33:	55                   	push   %ebp
  80fa34:	89 e5                	mov    %esp,%ebp
  80fa36:	57                   	push   %edi
  80fa37:	56                   	push   %esi
  80fa38:	53                   	push   %ebx
  80fa39:	8b 55 08             	mov    0x8(%ebp),%edx
  80fa3c:	8b 45 10             	mov    0x10(%ebp),%eax
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fa3f:	eb 03                	jmp    80fa44 <strtol+0x11>
		s++;
  80fa41:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80fa44:	0f b6 0a             	movzbl (%edx),%ecx
  80fa47:	80 f9 09             	cmp    $0x9,%cl
  80fa4a:	74 f5                	je     80fa41 <strtol+0xe>
  80fa4c:	80 f9 20             	cmp    $0x20,%cl
  80fa4f:	74 f0                	je     80fa41 <strtol+0xe>
		s++;

	// plus/minus sign
	if (*s == '+')
  80fa51:	80 f9 2b             	cmp    $0x2b,%cl
  80fa54:	75 0a                	jne    80fa60 <strtol+0x2d>
		s++;
  80fa56:	83 c2 01             	add    $0x1,%edx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  80fa59:	bf 00 00 00 00       	mov    $0x0,%edi
  80fa5e:	eb 11                	jmp    80fa71 <strtol+0x3e>
  80fa60:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  80fa65:	80 f9 2d             	cmp    $0x2d,%cl
  80fa68:	75 07                	jne    80fa71 <strtol+0x3e>
		s++, neg = 1;
  80fa6a:	8d 52 01             	lea    0x1(%edx),%edx
  80fa6d:	66 bf 01 00          	mov    $0x1,%di

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80fa71:	a9 ef ff ff ff       	test   $0xffffffef,%eax
  80fa76:	75 15                	jne    80fa8d <strtol+0x5a>
  80fa78:	80 3a 30             	cmpb   $0x30,(%edx)
  80fa7b:	75 10                	jne    80fa8d <strtol+0x5a>
  80fa7d:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80fa81:	75 0a                	jne    80fa8d <strtol+0x5a>
		s += 2, base = 16;
  80fa83:	83 c2 02             	add    $0x2,%edx
  80fa86:	b8 10 00 00 00       	mov    $0x10,%eax
  80fa8b:	eb 10                	jmp    80fa9d <strtol+0x6a>
	else if (base == 0 && s[0] == '0')
  80fa8d:	85 c0                	test   %eax,%eax
  80fa8f:	75 0c                	jne    80fa9d <strtol+0x6a>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80fa91:	b0 0a                	mov    $0xa,%al
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80fa93:	80 3a 30             	cmpb   $0x30,(%edx)
  80fa96:	75 05                	jne    80fa9d <strtol+0x6a>
		s++, base = 8;
  80fa98:	83 c2 01             	add    $0x1,%edx
  80fa9b:	b0 08                	mov    $0x8,%al
	else if (base == 0)
		base = 10;
  80fa9d:	bb 00 00 00 00       	mov    $0x0,%ebx
  80faa2:	89 45 10             	mov    %eax,0x10(%ebp)

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  80faa5:	0f b6 0a             	movzbl (%edx),%ecx
  80faa8:	8d 71 d0             	lea    -0x30(%ecx),%esi
  80faab:	89 f0                	mov    %esi,%eax
  80faad:	3c 09                	cmp    $0x9,%al
  80faaf:	77 08                	ja     80fab9 <strtol+0x86>
			dig = *s - '0';
  80fab1:	0f be c9             	movsbl %cl,%ecx
  80fab4:	83 e9 30             	sub    $0x30,%ecx
  80fab7:	eb 20                	jmp    80fad9 <strtol+0xa6>
		else if (*s >= 'a' && *s <= 'z')
  80fab9:	8d 71 9f             	lea    -0x61(%ecx),%esi
  80fabc:	89 f0                	mov    %esi,%eax
  80fabe:	3c 19                	cmp    $0x19,%al
  80fac0:	77 08                	ja     80faca <strtol+0x97>
			dig = *s - 'a' + 10;
  80fac2:	0f be c9             	movsbl %cl,%ecx
  80fac5:	83 e9 57             	sub    $0x57,%ecx
  80fac8:	eb 0f                	jmp    80fad9 <strtol+0xa6>
		else if (*s >= 'A' && *s <= 'Z')
  80faca:	8d 71 bf             	lea    -0x41(%ecx),%esi
  80facd:	89 f0                	mov    %esi,%eax
  80facf:	3c 19                	cmp    $0x19,%al
  80fad1:	77 16                	ja     80fae9 <strtol+0xb6>
			dig = *s - 'A' + 10;
  80fad3:	0f be c9             	movsbl %cl,%ecx
  80fad6:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  80fad9:	3b 4d 10             	cmp    0x10(%ebp),%ecx
  80fadc:	7d 0f                	jge    80faed <strtol+0xba>
			break;
		s++, val = (val * base) + dig;
  80fade:	83 c2 01             	add    $0x1,%edx
  80fae1:	0f af 5d 10          	imul   0x10(%ebp),%ebx
  80fae5:	01 cb                	add    %ecx,%ebx
		// we don't properly detect overflow!
	}
  80fae7:	eb bc                	jmp    80faa5 <strtol+0x72>
  80fae9:	89 d8                	mov    %ebx,%eax
  80faeb:	eb 02                	jmp    80faef <strtol+0xbc>
  80faed:	89 d8                	mov    %ebx,%eax

	if (endptr)
  80faef:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80faf3:	74 05                	je     80fafa <strtol+0xc7>
		*endptr = (char *) s;
  80faf5:	8b 75 0c             	mov    0xc(%ebp),%esi
  80faf8:	89 16                	mov    %edx,(%esi)
	return (neg ? -val : val);
  80fafa:	f7 d8                	neg    %eax
  80fafc:	85 ff                	test   %edi,%edi
  80fafe:	0f 44 c3             	cmove  %ebx,%eax
}
  80fb01:	5b                   	pop    %ebx
  80fb02:	5e                   	pop    %esi
  80fb03:	5f                   	pop    %edi
  80fb04:	5d                   	pop    %ebp
  80fb05:	c3                   	ret    

0080fb06 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  80fb06:	55                   	push   %ebp
  80fb07:	89 e5                	mov    %esp,%ebp
  80fb09:	57                   	push   %edi
  80fb0a:	56                   	push   %esi
  80fb0b:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb0c:	b8 00 00 00 00       	mov    $0x0,%eax
  80fb11:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fb14:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb17:	89 c3                	mov    %eax,%ebx
  80fb19:	89 c7                	mov    %eax,%edi
  80fb1b:	89 c6                	mov    %eax,%esi
  80fb1d:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  80fb1f:	5b                   	pop    %ebx
  80fb20:	5e                   	pop    %esi
  80fb21:	5f                   	pop    %edi
  80fb22:	5d                   	pop    %ebp
  80fb23:	c3                   	ret    

0080fb24 <sys_cgetc>:

int
sys_cgetc(void)
{
  80fb24:	55                   	push   %ebp
  80fb25:	89 e5                	mov    %esp,%ebp
  80fb27:	57                   	push   %edi
  80fb28:	56                   	push   %esi
  80fb29:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb2a:	ba 00 00 00 00       	mov    $0x0,%edx
  80fb2f:	b8 01 00 00 00       	mov    $0x1,%eax
  80fb34:	89 d1                	mov    %edx,%ecx
  80fb36:	89 d3                	mov    %edx,%ebx
  80fb38:	89 d7                	mov    %edx,%edi
  80fb3a:	89 d6                	mov    %edx,%esi
  80fb3c:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  80fb3e:	5b                   	pop    %ebx
  80fb3f:	5e                   	pop    %esi
  80fb40:	5f                   	pop    %edi
  80fb41:	5d                   	pop    %ebp
  80fb42:	c3                   	ret    

0080fb43 <sys_env_destroy>:

int
sys_env_destroy(envid_t envid)
{
  80fb43:	55                   	push   %ebp
  80fb44:	89 e5                	mov    %esp,%ebp
  80fb46:	57                   	push   %edi
  80fb47:	56                   	push   %esi
  80fb48:	53                   	push   %ebx
  80fb49:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb4c:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fb51:	b8 03 00 00 00       	mov    $0x3,%eax
  80fb56:	8b 55 08             	mov    0x8(%ebp),%edx
  80fb59:	89 cb                	mov    %ecx,%ebx
  80fb5b:	89 cf                	mov    %ecx,%edi
  80fb5d:	89 ce                	mov    %ecx,%esi
  80fb5f:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fb61:	85 c0                	test   %eax,%eax
  80fb63:	7e 28                	jle    80fb8d <sys_env_destroy+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fb65:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fb69:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  80fb70:	00 
  80fb71:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fb78:	00 
  80fb79:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fb80:	00 
  80fb81:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fb88:	e8 0d f5 ff ff       	call   80f09a <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80fb8d:	83 c4 2c             	add    $0x2c,%esp
  80fb90:	5b                   	pop    %ebx
  80fb91:	5e                   	pop    %esi
  80fb92:	5f                   	pop    %edi
  80fb93:	5d                   	pop    %ebp
  80fb94:	c3                   	ret    

0080fb95 <sys_getenvid>:

envid_t
sys_getenvid(void)
{
  80fb95:	55                   	push   %ebp
  80fb96:	89 e5                	mov    %esp,%ebp
  80fb98:	57                   	push   %edi
  80fb99:	56                   	push   %esi
  80fb9a:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fb9b:	ba 00 00 00 00       	mov    $0x0,%edx
  80fba0:	b8 02 00 00 00       	mov    $0x2,%eax
  80fba5:	89 d1                	mov    %edx,%ecx
  80fba7:	89 d3                	mov    %edx,%ebx
  80fba9:	89 d7                	mov    %edx,%edi
  80fbab:	89 d6                	mov    %edx,%esi
  80fbad:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80fbaf:	5b                   	pop    %ebx
  80fbb0:	5e                   	pop    %esi
  80fbb1:	5f                   	pop    %edi
  80fbb2:	5d                   	pop    %ebp
  80fbb3:	c3                   	ret    

0080fbb4 <sys_yield>:

void
sys_yield(void)
{
  80fbb4:	55                   	push   %ebp
  80fbb5:	89 e5                	mov    %esp,%ebp
  80fbb7:	57                   	push   %edi
  80fbb8:	56                   	push   %esi
  80fbb9:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbba:	ba 00 00 00 00       	mov    $0x0,%edx
  80fbbf:	b8 0b 00 00 00       	mov    $0xb,%eax
  80fbc4:	89 d1                	mov    %edx,%ecx
  80fbc6:	89 d3                	mov    %edx,%ebx
  80fbc8:	89 d7                	mov    %edx,%edi
  80fbca:	89 d6                	mov    %edx,%esi
  80fbcc:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  80fbce:	5b                   	pop    %ebx
  80fbcf:	5e                   	pop    %esi
  80fbd0:	5f                   	pop    %edi
  80fbd1:	5d                   	pop    %ebp
  80fbd2:	c3                   	ret    

0080fbd3 <sys_page_alloc>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80fbd3:	55                   	push   %ebp
  80fbd4:	89 e5                	mov    %esp,%ebp
  80fbd6:	57                   	push   %edi
  80fbd7:	56                   	push   %esi
  80fbd8:	53                   	push   %ebx
  80fbd9:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fbdc:	be 00 00 00 00       	mov    $0x0,%esi
  80fbe1:	b8 04 00 00 00       	mov    $0x4,%eax
  80fbe6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fbe9:	8b 55 08             	mov    0x8(%ebp),%edx
  80fbec:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fbef:	89 f7                	mov    %esi,%edi
  80fbf1:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fbf3:	85 c0                	test   %eax,%eax
  80fbf5:	7e 28                	jle    80fc1f <sys_page_alloc+0x4c>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fbf7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fbfb:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  80fc02:	00 
  80fc03:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fc0a:	00 
  80fc0b:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fc12:	00 
  80fc13:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fc1a:	e8 7b f4 ff ff       	call   80f09a <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80fc1f:	83 c4 2c             	add    $0x2c,%esp
  80fc22:	5b                   	pop    %ebx
  80fc23:	5e                   	pop    %esi
  80fc24:	5f                   	pop    %edi
  80fc25:	5d                   	pop    %ebp
  80fc26:	c3                   	ret    

0080fc27 <sys_page_map>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80fc27:	55                   	push   %ebp
  80fc28:	89 e5                	mov    %esp,%ebp
  80fc2a:	57                   	push   %edi
  80fc2b:	56                   	push   %esi
  80fc2c:	53                   	push   %ebx
  80fc2d:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc30:	b8 05 00 00 00       	mov    $0x5,%eax
  80fc35:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc38:	8b 55 08             	mov    0x8(%ebp),%edx
  80fc3b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fc3e:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fc41:	8b 75 18             	mov    0x18(%ebp),%esi
  80fc44:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fc46:	85 c0                	test   %eax,%eax
  80fc48:	7e 28                	jle    80fc72 <sys_page_map+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fc4a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fc4e:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80fc55:	00 
  80fc56:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fc5d:	00 
  80fc5e:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fc65:	00 
  80fc66:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fc6d:	e8 28 f4 ff ff       	call   80f09a <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80fc72:	83 c4 2c             	add    $0x2c,%esp
  80fc75:	5b                   	pop    %ebx
  80fc76:	5e                   	pop    %esi
  80fc77:	5f                   	pop    %edi
  80fc78:	5d                   	pop    %ebp
  80fc79:	c3                   	ret    

0080fc7a <sys_page_unmap>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80fc7a:	55                   	push   %ebp
  80fc7b:	89 e5                	mov    %esp,%ebp
  80fc7d:	57                   	push   %edi
  80fc7e:	56                   	push   %esi
  80fc7f:	53                   	push   %ebx
  80fc80:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fc83:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fc88:	b8 06 00 00 00       	mov    $0x6,%eax
  80fc8d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fc90:	8b 55 08             	mov    0x8(%ebp),%edx
  80fc93:	89 df                	mov    %ebx,%edi
  80fc95:	89 de                	mov    %ebx,%esi
  80fc97:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fc99:	85 c0                	test   %eax,%eax
  80fc9b:	7e 28                	jle    80fcc5 <sys_page_unmap+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fc9d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fca1:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80fca8:	00 
  80fca9:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fcb0:	00 
  80fcb1:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fcb8:	00 
  80fcb9:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fcc0:	e8 d5 f3 ff ff       	call   80f09a <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  80fcc5:	83 c4 2c             	add    $0x2c,%esp
  80fcc8:	5b                   	pop    %ebx
  80fcc9:	5e                   	pop    %esi
  80fcca:	5f                   	pop    %edi
  80fccb:	5d                   	pop    %ebp
  80fccc:	c3                   	ret    

0080fccd <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  80fccd:	55                   	push   %ebp
  80fcce:	89 e5                	mov    %esp,%ebp
  80fcd0:	57                   	push   %edi
  80fcd1:	56                   	push   %esi
  80fcd2:	53                   	push   %ebx
  80fcd3:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fcd6:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fcdb:	b8 08 00 00 00       	mov    $0x8,%eax
  80fce0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fce3:	8b 55 08             	mov    0x8(%ebp),%edx
  80fce6:	89 df                	mov    %ebx,%edi
  80fce8:	89 de                	mov    %ebx,%esi
  80fcea:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fcec:	85 c0                	test   %eax,%eax
  80fcee:	7e 28                	jle    80fd18 <sys_env_set_status+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fcf0:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fcf4:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  80fcfb:	00 
  80fcfc:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fd03:	00 
  80fd04:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fd0b:	00 
  80fd0c:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fd13:	e8 82 f3 ff ff       	call   80f09a <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80fd18:	83 c4 2c             	add    $0x2c,%esp
  80fd1b:	5b                   	pop    %ebx
  80fd1c:	5e                   	pop    %esi
  80fd1d:	5f                   	pop    %edi
  80fd1e:	5d                   	pop    %ebp
  80fd1f:	c3                   	ret    

0080fd20 <sys_env_set_trapframe>:

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  80fd20:	55                   	push   %ebp
  80fd21:	89 e5                	mov    %esp,%ebp
  80fd23:	57                   	push   %edi
  80fd24:	56                   	push   %esi
  80fd25:	53                   	push   %ebx
  80fd26:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd29:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd2e:	b8 09 00 00 00       	mov    $0x9,%eax
  80fd33:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd36:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd39:	89 df                	mov    %ebx,%edi
  80fd3b:	89 de                	mov    %ebx,%esi
  80fd3d:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fd3f:	85 c0                	test   %eax,%eax
  80fd41:	7e 28                	jle    80fd6b <sys_env_set_trapframe+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fd43:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd47:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  80fd4e:	00 
  80fd4f:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fd56:	00 
  80fd57:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fd5e:	00 
  80fd5f:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fd66:	e8 2f f3 ff ff       	call   80f09a <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  80fd6b:	83 c4 2c             	add    $0x2c,%esp
  80fd6e:	5b                   	pop    %ebx
  80fd6f:	5e                   	pop    %esi
  80fd70:	5f                   	pop    %edi
  80fd71:	5d                   	pop    %ebp
  80fd72:	c3                   	ret    

0080fd73 <sys_env_set_pgfault_upcall>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  80fd73:	55                   	push   %ebp
  80fd74:	89 e5                	mov    %esp,%ebp
  80fd76:	57                   	push   %edi
  80fd77:	56                   	push   %esi
  80fd78:	53                   	push   %ebx
  80fd79:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fd7c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fd81:	b8 0a 00 00 00       	mov    $0xa,%eax
  80fd86:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fd89:	8b 55 08             	mov    0x8(%ebp),%edx
  80fd8c:	89 df                	mov    %ebx,%edi
  80fd8e:	89 de                	mov    %ebx,%esi
  80fd90:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fd92:	85 c0                	test   %eax,%eax
  80fd94:	7e 28                	jle    80fdbe <sys_env_set_pgfault_upcall+0x4b>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fd96:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fd9a:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  80fda1:	00 
  80fda2:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fda9:	00 
  80fdaa:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fdb1:	00 
  80fdb2:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fdb9:	e8 dc f2 ff ff       	call   80f09a <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  80fdbe:	83 c4 2c             	add    $0x2c,%esp
  80fdc1:	5b                   	pop    %ebx
  80fdc2:	5e                   	pop    %esi
  80fdc3:	5f                   	pop    %edi
  80fdc4:	5d                   	pop    %ebp
  80fdc5:	c3                   	ret    

0080fdc6 <sys_ipc_try_send>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80fdc6:	55                   	push   %ebp
  80fdc7:	89 e5                	mov    %esp,%ebp
  80fdc9:	57                   	push   %edi
  80fdca:	56                   	push   %esi
  80fdcb:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fdcc:	be 00 00 00 00       	mov    $0x0,%esi
  80fdd1:	b8 0c 00 00 00       	mov    $0xc,%eax
  80fdd6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fdd9:	8b 55 08             	mov    0x8(%ebp),%edx
  80fddc:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fddf:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fde2:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80fde4:	5b                   	pop    %ebx
  80fde5:	5e                   	pop    %esi
  80fde6:	5f                   	pop    %edi
  80fde7:	5d                   	pop    %ebp
  80fde8:	c3                   	ret    

0080fde9 <sys_ipc_recv>:

int
sys_ipc_recv(void *dstva)
{
  80fde9:	55                   	push   %ebp
  80fdea:	89 e5                	mov    %esp,%ebp
  80fdec:	57                   	push   %edi
  80fded:	56                   	push   %esi
  80fdee:	53                   	push   %ebx
  80fdef:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fdf2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fdf7:	b8 0d 00 00 00       	mov    $0xd,%eax
  80fdfc:	8b 55 08             	mov    0x8(%ebp),%edx
  80fdff:	89 cb                	mov    %ecx,%ebx
  80fe01:	89 cf                	mov    %ecx,%edi
  80fe03:	89 ce                	mov    %ecx,%esi
  80fe05:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fe07:	85 c0                	test   %eax,%eax
  80fe09:	7e 28                	jle    80fe33 <sys_ipc_recv+0x4a>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fe0b:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fe0f:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  80fe16:	00 
  80fe17:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fe1e:	00 
  80fe1f:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fe26:	00 
  80fe27:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80fe2e:	e8 67 f2 ff ff       	call   80f09a <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  80fe33:	83 c4 2c             	add    $0x2c,%esp
  80fe36:	5b                   	pop    %ebx
  80fe37:	5e                   	pop    %esi
  80fe38:	5f                   	pop    %edi
  80fe39:	5d                   	pop    %ebp
  80fe3a:	c3                   	ret    

0080fe3b <sys_time_msec>:

unsigned int
sys_time_msec(void)
{
  80fe3b:	55                   	push   %ebp
  80fe3c:	89 e5                	mov    %esp,%ebp
  80fe3e:	57                   	push   %edi
  80fe3f:	56                   	push   %esi
  80fe40:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe41:	ba 00 00 00 00       	mov    $0x0,%edx
  80fe46:	b8 0e 00 00 00       	mov    $0xe,%eax
  80fe4b:	89 d1                	mov    %edx,%ecx
  80fe4d:	89 d3                	mov    %edx,%ebx
  80fe4f:	89 d7                	mov    %edx,%edi
  80fe51:	89 d6                	mov    %edx,%esi
  80fe53:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  80fe55:	5b                   	pop    %ebx
  80fe56:	5e                   	pop    %esi
  80fe57:	5f                   	pop    %edi
  80fe58:	5d                   	pop    %ebp
  80fe59:	c3                   	ret    

0080fe5a <sys_e1000_transmit>:

int
sys_e1000_transmit(char *pkt, size_t length)
{
  80fe5a:	55                   	push   %ebp
  80fe5b:	89 e5                	mov    %esp,%ebp
  80fe5d:	57                   	push   %edi
  80fe5e:	56                   	push   %esi
  80fe5f:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe60:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe65:	b8 0f 00 00 00       	mov    $0xf,%eax
  80fe6a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe6d:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe70:	89 df                	mov    %ebx,%edi
  80fe72:	89 de                	mov    %ebx,%esi
  80fe74:	cd 30                	int    $0x30

int
sys_e1000_transmit(char *pkt, size_t length)
{
	return syscall(SYS_e1000_transmit, 0, (uint32_t) pkt, length, 0, 0, 0);
}
  80fe76:	5b                   	pop    %ebx
  80fe77:	5e                   	pop    %esi
  80fe78:	5f                   	pop    %edi
  80fe79:	5d                   	pop    %ebp
  80fe7a:	c3                   	ret    

0080fe7b <sys_e1000_receive>:

int
sys_e1000_receive(char *pkt, size_t *length)
{
  80fe7b:	55                   	push   %ebp
  80fe7c:	89 e5                	mov    %esp,%ebp
  80fe7e:	57                   	push   %edi
  80fe7f:	56                   	push   %esi
  80fe80:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fe81:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fe86:	b8 10 00 00 00       	mov    $0x10,%eax
  80fe8b:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fe8e:	8b 55 08             	mov    0x8(%ebp),%edx
  80fe91:	89 df                	mov    %ebx,%edi
  80fe93:	89 de                	mov    %ebx,%esi
  80fe95:	cd 30                	int    $0x30

int
sys_e1000_receive(char *pkt, size_t *length)
{
	return syscall(SYS_e1000_receive, 0, (uint32_t) pkt, (uint32_t) length, 0, 0, 0);
}
  80fe97:	5b                   	pop    %ebx
  80fe98:	5e                   	pop    %esi
  80fe99:	5f                   	pop    %edi
  80fe9a:	5d                   	pop    %ebp
  80fe9b:	c3                   	ret    

0080fe9c <sys_e1000_get_mac>:

int
sys_e1000_get_mac(uint8_t *mac_addr)
{
  80fe9c:	55                   	push   %ebp
  80fe9d:	89 e5                	mov    %esp,%ebp
  80fe9f:	57                   	push   %edi
  80fea0:	56                   	push   %esi
  80fea1:	53                   	push   %ebx
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fea2:	b9 00 00 00 00       	mov    $0x0,%ecx
  80fea7:	b8 11 00 00 00       	mov    $0x11,%eax
  80feac:	8b 55 08             	mov    0x8(%ebp),%edx
  80feaf:	89 cb                	mov    %ecx,%ebx
  80feb1:	89 cf                	mov    %ecx,%edi
  80feb3:	89 ce                	mov    %ecx,%esi
  80feb5:	cd 30                	int    $0x30

int
sys_e1000_get_mac(uint8_t *mac_addr)
{
	return syscall(SYS_e1000_get_mac, 0, (uint32_t) mac_addr, 0, 0, 0, 0);
}
  80feb7:	5b                   	pop    %ebx
  80feb8:	5e                   	pop    %esi
  80feb9:	5f                   	pop    %edi
  80feba:	5d                   	pop    %ebp
  80febb:	c3                   	ret    

0080febc <sys_exec>:

int 
sys_exec(uint32_t eip, uint32_t esp, void * v_ph, uint32_t phnum)
{
  80febc:	55                   	push   %ebp
  80febd:	89 e5                	mov    %esp,%ebp
  80febf:	57                   	push   %edi
  80fec0:	56                   	push   %esi
  80fec1:	53                   	push   %ebx
  80fec2:	83 ec 2c             	sub    $0x2c,%esp
	//
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80fec5:	be 00 00 00 00       	mov    $0x0,%esi
  80feca:	b8 12 00 00 00       	mov    $0x12,%eax
  80fecf:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80fed2:	8b 55 08             	mov    0x8(%ebp),%edx
  80fed5:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80fed8:	8b 7d 14             	mov    0x14(%ebp),%edi
  80fedb:	cd 30                	int    $0x30
		       "b" (a3),
		       "D" (a4),
		       "S" (a5)
		     : "cc", "memory");

	if(check && ret > 0)
  80fedd:	85 c0                	test   %eax,%eax
  80fedf:	7e 28                	jle    80ff09 <sys_exec+0x4d>
		panic("syscall %d returned %d (> 0)", num, ret);
  80fee1:	89 44 24 10          	mov    %eax,0x10(%esp)
  80fee5:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  80feec:	00 
  80feed:	c7 44 24 08 07 47 81 	movl   $0x814707,0x8(%esp)
  80fef4:	00 
  80fef5:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80fefc:	00 
  80fefd:	c7 04 24 24 47 81 00 	movl   $0x814724,(%esp)
  80ff04:	e8 91 f1 ff ff       	call   80f09a <_panic>

int 
sys_exec(uint32_t eip, uint32_t esp, void * v_ph, uint32_t phnum)
{
	return syscall(SYS_exec, 1, eip, esp, (uint32_t)v_ph, phnum, 0);
}
  80ff09:	83 c4 2c             	add    $0x2c,%esp
  80ff0c:	5b                   	pop    %ebx
  80ff0d:	5e                   	pop    %esi
  80ff0e:	5f                   	pop    %edi
  80ff0f:	5d                   	pop    %ebp
  80ff10:	c3                   	ret    

0080ff11 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  80ff11:	55                   	push   %ebp
  80ff12:	89 e5                	mov    %esp,%ebp
  80ff14:	53                   	push   %ebx
  80ff15:	83 ec 24             	sub    $0x24,%esp
  80ff18:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  80ff1b:	8b 18                	mov    (%eax),%ebx
	// Hint:
	//   Use the read-only page table mappings at uvpt
	//   (see <inc/memlayout.h>).

	// LAB 4: Your code here.
	if ((err & FEC_WR) == 0)
  80ff1d:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  80ff21:	75 20                	jne    80ff43 <pgfault+0x32>
		panic("pgfault: faulting address [%08x] not a write\n", addr);
  80ff23:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80ff27:	c7 44 24 08 34 47 81 	movl   $0x814734,0x8(%esp)
  80ff2e:	00 
  80ff2f:	c7 44 24 04 1e 00 00 	movl   $0x1e,0x4(%esp)
  80ff36:	00 
  80ff37:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  80ff3e:	e8 57 f1 ff ff       	call   80f09a <_panic>

	void *page_aligned_addr = (void *) ROUNDDOWN(addr, PGSIZE);
  80ff43:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
	uint32_t page_num = (uint32_t) page_aligned_addr / PGSIZE;
  80ff49:	89 d8                	mov    %ebx,%eax
  80ff4b:	c1 e8 0c             	shr    $0xc,%eax
	if (!(uvpt[page_num] & PTE_COW))
  80ff4e:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  80ff55:	f6 c4 08             	test   $0x8,%ah
  80ff58:	75 1c                	jne    80ff76 <pgfault+0x65>
		panic("pgfault: fault was not on a copy-on-write page\n");
  80ff5a:	c7 44 24 08 64 47 81 	movl   $0x814764,0x8(%esp)
  80ff61:	00 
  80ff62:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80ff69:	00 
  80ff6a:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  80ff71:	e8 24 f1 ff ff       	call   80f09a <_panic>
	// Hint:
	//   You should make three system calls.

	// LAB 4: Your code here.
	// Allocate
	if ((r = sys_page_alloc(0, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0)
  80ff76:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80ff7d:	00 
  80ff7e:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80ff85:	00 
  80ff86:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80ff8d:	e8 41 fc ff ff       	call   80fbd3 <sys_page_alloc>
  80ff92:	85 c0                	test   %eax,%eax
  80ff94:	79 20                	jns    80ffb6 <pgfault+0xa5>
		panic("sys_page_alloc: %e\n", r);
  80ff96:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80ff9a:	c7 44 24 08 bf 47 81 	movl   $0x8147bf,0x8(%esp)
  80ffa1:	00 
  80ffa2:	c7 44 24 04 2d 00 00 	movl   $0x2d,0x4(%esp)
  80ffa9:	00 
  80ffaa:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  80ffb1:	e8 e4 f0 ff ff       	call   80f09a <_panic>

	// Copy over
	void *src_addr = (void *) ROUNDDOWN(addr, PGSIZE);
	memmove(PFTEMP, src_addr, PGSIZE);
  80ffb6:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  80ffbd:	00 
  80ffbe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ffc2:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  80ffc9:	e8 86 f9 ff ff       	call   80f954 <memmove>

	// Remap
	if ((r = sys_page_map(0, PFTEMP, 0, src_addr, PTE_P | PTE_U | PTE_W)) < 0)
  80ffce:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  80ffd5:	00 
  80ffd6:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80ffda:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ffe1:	00 
  80ffe2:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  80ffe9:	00 
  80ffea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fff1:	e8 31 fc ff ff       	call   80fc27 <sys_page_map>
  80fff6:	85 c0                	test   %eax,%eax
  80fff8:	79 20                	jns    81001a <pgfault+0x109>
		panic("sys_page_map: %e\n", r);
  80fffa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80fffe:	c7 44 24 08 d3 47 81 	movl   $0x8147d3,0x8(%esp)
  810005:	00 
  810006:	c7 44 24 04 35 00 00 	movl   $0x35,0x4(%esp)
  81000d:	00 
  81000e:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  810015:	e8 80 f0 ff ff       	call   80f09a <_panic>

	//panic("pgfault not implemented");
}
  81001a:	83 c4 24             	add    $0x24,%esp
  81001d:	5b                   	pop    %ebx
  81001e:	5d                   	pop    %ebp
  81001f:	c3                   	ret    

00810020 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  810020:	55                   	push   %ebp
  810021:	89 e5                	mov    %esp,%ebp
  810023:	57                   	push   %edi
  810024:	56                   	push   %esi
  810025:	53                   	push   %ebx
  810026:	83 ec 2c             	sub    $0x2c,%esp
	// LAB 4: Your code here.
	int r;
	envid_t child_envid;

	set_pgfault_handler(pgfault);
  810029:	c7 04 24 11 ff 80 00 	movl   $0x80ff11,(%esp)
  810030:	e8 d1 19 00 00       	call   811a06 <set_pgfault_handler>
// This must be inlined.  Exercise for reader: why?
static inline envid_t __attribute__((always_inline))
sys_exofork(void)
{
	envid_t ret;
	asm volatile("int %2"
  810035:	b8 07 00 00 00       	mov    $0x7,%eax
  81003a:	cd 30                	int    $0x30
  81003c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  81003f:	89 45 e0             	mov    %eax,-0x20(%ebp)

	child_envid = sys_exofork();
	if (child_envid < 0)
  810042:	85 c0                	test   %eax,%eax
  810044:	79 20                	jns    810066 <fork+0x46>
		panic("sys_exofork: %e\n", child_envid);
  810046:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81004a:	c7 44 24 08 e5 47 81 	movl   $0x8147e5,0x8(%esp)
  810051:	00 
  810052:	c7 44 24 04 7f 00 00 	movl   $0x7f,0x4(%esp)
  810059:	00 
  81005a:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  810061:	e8 34 f0 ff ff       	call   80f09a <_panic>
	if (child_envid == 0) { // child
  810066:	bf 00 00 00 00       	mov    $0x0,%edi
  81006b:	bb 00 00 00 00       	mov    $0x0,%ebx
  810070:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  810074:	75 21                	jne    810097 <fork+0x77>
		// Fix thisenv like dumbfork does and return 0
		thisenv = &envs[ENVX(sys_getenvid())];
  810076:	e8 1a fb ff ff       	call   80fb95 <sys_getenvid>
  81007b:	25 ff 03 00 00       	and    $0x3ff,%eax
  810080:	c1 e0 07             	shl    $0x7,%eax
  810083:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  810088:	a3 7c c2 b3 00       	mov    %eax,0xb3c27c
		return 0;
  81008d:	b8 00 00 00 00       	mov    $0x0,%eax
  810092:	e9 53 02 00 00       	jmp    8102ea <fork+0x2ca>
	// Note that we don't remap anything above UTOP because the kernel took
	// care of that for us in env_setup_vm().
	uint32_t page_num;
	pte_t *pte;
	for (page_num = 0; page_num < PGNUM(UTOP - PGSIZE); page_num++) {
		uint32_t pdx = ROUNDDOWN(page_num, NPDENTRIES) / NPDENTRIES;
  810097:	89 d8                	mov    %ebx,%eax
  810099:	c1 e8 0a             	shr    $0xa,%eax
		if ((uvpd[pdx] & PTE_P) == PTE_P &&
  81009c:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  8100a3:	a8 01                	test   $0x1,%al
  8100a5:	0f 84 7a 01 00 00    	je     810225 <fork+0x205>
			((uvpt[page_num] & PTE_P) == PTE_P)) {
  8100ab:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
	// care of that for us in env_setup_vm().
	uint32_t page_num;
	pte_t *pte;
	for (page_num = 0; page_num < PGNUM(UTOP - PGSIZE); page_num++) {
		uint32_t pdx = ROUNDDOWN(page_num, NPDENTRIES) / NPDENTRIES;
		if ((uvpd[pdx] & PTE_P) == PTE_P &&
  8100b2:	a8 01                	test   $0x1,%al
  8100b4:	0f 84 6b 01 00 00    	je     810225 <fork+0x205>
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	uint32_t perm = PTE_P | PTE_COW;
	envid_t this_envid = thisenv->env_id;
  8100ba:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  8100bf:	8b 40 48             	mov    0x48(%eax),%eax
  8100c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	// LAB 4: Your code here.
	if (uvpt[pn] & PTE_SHARE) {
  8100c5:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  8100cc:	f6 c4 04             	test   $0x4,%ah
  8100cf:	74 52                	je     810123 <fork+0x103>
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), uvpt[pn] & PTE_SYSCALL)) < 0)
  8100d1:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  8100d8:	25 07 0e 00 00       	and    $0xe07,%eax
  8100dd:	89 44 24 10          	mov    %eax,0x10(%esp)
  8100e1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8100e5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8100e8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8100ec:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8100f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8100f3:	89 04 24             	mov    %eax,(%esp)
  8100f6:	e8 2c fb ff ff       	call   80fc27 <sys_page_map>
  8100fb:	85 c0                	test   %eax,%eax
  8100fd:	0f 89 22 01 00 00    	jns    810225 <fork+0x205>
			panic("sys_page_map: %e\n", r);
  810103:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810107:	c7 44 24 08 d3 47 81 	movl   $0x8147d3,0x8(%esp)
  81010e:	00 
  81010f:	c7 44 24 04 4f 00 00 	movl   $0x4f,0x4(%esp)
  810116:	00 
  810117:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  81011e:	e8 77 ef ff ff       	call   80f09a <_panic>
	} else if (uvpt[pn] & PTE_COW || uvpt[pn] & PTE_W) {
  810123:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  81012a:	f6 c4 08             	test   $0x8,%ah
  81012d:	75 0f                	jne    81013e <fork+0x11e>
  81012f:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  810136:	a8 02                	test   $0x2,%al
  810138:	0f 84 99 00 00 00    	je     8101d7 <fork+0x1b7>
		if (uvpt[pn] & PTE_U)
  81013e:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  810145:	83 e0 04             	and    $0x4,%eax
//
static int
duppage(envid_t envid, unsigned pn)
{
	int r;
	uint32_t perm = PTE_P | PTE_COW;
  810148:	83 f8 01             	cmp    $0x1,%eax
  81014b:	19 f6                	sbb    %esi,%esi
  81014d:	83 e6 fc             	and    $0xfffffffc,%esi
  810150:	81 c6 05 08 00 00    	add    $0x805,%esi
	} else if (uvpt[pn] & PTE_COW || uvpt[pn] & PTE_W) {
		if (uvpt[pn] & PTE_U)
			perm |= PTE_U;

		// Map page COW, U and P in child
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), perm)) < 0)
  810156:	89 74 24 10          	mov    %esi,0x10(%esp)
  81015a:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  81015e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  810161:	89 44 24 08          	mov    %eax,0x8(%esp)
  810165:	89 7c 24 04          	mov    %edi,0x4(%esp)
  810169:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81016c:	89 04 24             	mov    %eax,(%esp)
  81016f:	e8 b3 fa ff ff       	call   80fc27 <sys_page_map>
  810174:	85 c0                	test   %eax,%eax
  810176:	79 20                	jns    810198 <fork+0x178>
			panic("sys_page_map: %e\n", r);
  810178:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81017c:	c7 44 24 08 d3 47 81 	movl   $0x8147d3,0x8(%esp)
  810183:	00 
  810184:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
  81018b:	00 
  81018c:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  810193:	e8 02 ef ff ff       	call   80f09a <_panic>

		// Map page COW, U and P in parent
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), this_envid, (void *) (pn*PGSIZE), perm)) < 0)
  810198:	89 74 24 10          	mov    %esi,0x10(%esp)
  81019c:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8101a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8101a3:	89 44 24 08          	mov    %eax,0x8(%esp)
  8101a7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8101ab:	89 04 24             	mov    %eax,(%esp)
  8101ae:	e8 74 fa ff ff       	call   80fc27 <sys_page_map>
  8101b3:	85 c0                	test   %eax,%eax
  8101b5:	79 6e                	jns    810225 <fork+0x205>
			panic("sys_page_map: %e\n", r);
  8101b7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8101bb:	c7 44 24 08 d3 47 81 	movl   $0x8147d3,0x8(%esp)
  8101c2:	00 
  8101c3:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
  8101ca:	00 
  8101cb:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  8101d2:	e8 c3 ee ff ff       	call   80f09a <_panic>

	} else { // map pages that are present but not writable or COW with their original permissions
		if ((r = sys_page_map(this_envid, (void *) (pn*PGSIZE), envid, (void *) (pn*PGSIZE), uvpt[pn] & PTE_SYSCALL)) < 0)
  8101d7:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  8101de:	25 07 0e 00 00       	and    $0xe07,%eax
  8101e3:	89 44 24 10          	mov    %eax,0x10(%esp)
  8101e7:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8101eb:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8101ee:	89 44 24 08          	mov    %eax,0x8(%esp)
  8101f2:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8101f6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8101f9:	89 04 24             	mov    %eax,(%esp)
  8101fc:	e8 26 fa ff ff       	call   80fc27 <sys_page_map>
  810201:	85 c0                	test   %eax,%eax
  810203:	79 20                	jns    810225 <fork+0x205>
			panic("sys_page_map: %e\n", r);
  810205:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810209:	c7 44 24 08 d3 47 81 	movl   $0x8147d3,0x8(%esp)
  810210:	00 
  810211:	c7 44 24 04 5e 00 00 	movl   $0x5e,0x4(%esp)
  810218:	00 
  810219:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  810220:	e8 75 ee ff ff       	call   80f09a <_panic>
	// and let duppage worry about the permissions.
	// Note that we don't remap anything above UTOP because the kernel took
	// care of that for us in env_setup_vm().
	uint32_t page_num;
	pte_t *pte;
	for (page_num = 0; page_num < PGNUM(UTOP - PGSIZE); page_num++) {
  810225:	83 c3 01             	add    $0x1,%ebx
  810228:	81 c7 00 10 00 00    	add    $0x1000,%edi
  81022e:	81 fb ff eb 0e 00    	cmp    $0xeebff,%ebx
  810234:	0f 85 5d fe ff ff    	jne    810097 <fork+0x77>
	}

	// Allocate exception stack space for child. The child can't do this themselves
	// because the mechanism by which it would is to run the pgfault handler, which
	// needs to run on the exception stack (catch 22).
	if ((r = sys_page_alloc(child_envid, (void *) (UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
  81023a:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  810241:	00 
  810242:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  810249:	ee 
  81024a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  81024d:	89 04 24             	mov    %eax,(%esp)
  810250:	e8 7e f9 ff ff       	call   80fbd3 <sys_page_alloc>
  810255:	85 c0                	test   %eax,%eax
  810257:	79 20                	jns    810279 <fork+0x259>
		panic("sys_page_alloc: %e\n", r);
  810259:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81025d:	c7 44 24 08 bf 47 81 	movl   $0x8147bf,0x8(%esp)
  810264:	00 
  810265:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  81026c:	00 
  81026d:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  810274:	e8 21 ee ff ff       	call   80f09a <_panic>

	// Set page fault handler for the child
	if ((r = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall)) < 0)
  810279:	c7 44 24 04 87 1a 81 	movl   $0x811a87,0x4(%esp)
  810280:	00 
  810281:	8b 45 dc             	mov    -0x24(%ebp),%eax
  810284:	89 04 24             	mov    %eax,(%esp)
  810287:	e8 e7 fa ff ff       	call   80fd73 <sys_env_set_pgfault_upcall>
  81028c:	85 c0                	test   %eax,%eax
  81028e:	79 20                	jns    8102b0 <fork+0x290>
		panic("sys_env_set_pgfault_upcall: %e\n", r);
  810290:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810294:	c7 44 24 08 94 47 81 	movl   $0x814794,0x8(%esp)
  81029b:	00 
  81029c:	c7 44 24 04 9e 00 00 	movl   $0x9e,0x4(%esp)
  8102a3:	00 
  8102a4:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  8102ab:	e8 ea ed ff ff       	call   80f09a <_panic>

	// Mark child environment as runnable
	if ((r = sys_env_set_status(child_envid, ENV_RUNNABLE)) < 0)
  8102b0:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8102b7:	00 
  8102b8:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8102bb:	89 04 24             	mov    %eax,(%esp)
  8102be:	e8 0a fa ff ff       	call   80fccd <sys_env_set_status>
  8102c3:	85 c0                	test   %eax,%eax
  8102c5:	79 20                	jns    8102e7 <fork+0x2c7>
		panic("sys_env_set_status: %e\n", r);
  8102c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8102cb:	c7 44 24 08 f6 47 81 	movl   $0x8147f6,0x8(%esp)
  8102d2:	00 
  8102d3:	c7 44 24 04 a2 00 00 	movl   $0xa2,0x4(%esp)
  8102da:	00 
  8102db:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  8102e2:	e8 b3 ed ff ff       	call   80f09a <_panic>

	return child_envid;
  8102e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
}
  8102ea:	83 c4 2c             	add    $0x2c,%esp
  8102ed:	5b                   	pop    %ebx
  8102ee:	5e                   	pop    %esi
  8102ef:	5f                   	pop    %edi
  8102f0:	5d                   	pop    %ebp
  8102f1:	c3                   	ret    

008102f2 <sfork>:

// Challenge!
int
sfork(void)
{
  8102f2:	55                   	push   %ebp
  8102f3:	89 e5                	mov    %esp,%ebp
  8102f5:	83 ec 18             	sub    $0x18,%esp
//	return __fork(1);
	panic("sfork not implemented");
  8102f8:	c7 44 24 08 0e 48 81 	movl   $0x81480e,0x8(%esp)
  8102ff:	00 
  810300:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  810307:	00 
  810308:	c7 04 24 b4 47 81 00 	movl   $0x8147b4,(%esp)
  81030f:	e8 86 ed ff ff       	call   80f09a <_panic>
  810314:	66 90                	xchg   %ax,%ax
  810316:	66 90                	xchg   %ax,%ax
  810318:	66 90                	xchg   %ax,%ax
  81031a:	66 90                	xchg   %ax,%ax
  81031c:	66 90                	xchg   %ax,%ax
  81031e:	66 90                	xchg   %ax,%ax

00810320 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  810320:	55                   	push   %ebp
  810321:	89 e5                	mov    %esp,%ebp
  810323:	56                   	push   %esi
  810324:	53                   	push   %ebx
  810325:	83 ec 10             	sub    $0x10,%esp
  810328:	8b 75 08             	mov    0x8(%ebp),%esi
  81032b:	8b 45 0c             	mov    0xc(%ebp),%eax
  81032e:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// LAB 4: Your code here.
	int r;
	if (pg == NULL)
  810331:	85 c0                	test   %eax,%eax
		pg = (void *) KERNBASE; // KERNBASE should be rejected by sys_ipc_recv()
  810333:	ba 00 00 00 f0       	mov    $0xf0000000,%edx
  810338:	0f 44 c2             	cmove  %edx,%eax

	if ((r = sys_ipc_recv(pg)) != 0) {
  81033b:	89 04 24             	mov    %eax,(%esp)
  81033e:	e8 a6 fa ff ff       	call   80fde9 <sys_ipc_recv>
  810343:	85 c0                	test   %eax,%eax
  810345:	74 16                	je     81035d <ipc_recv+0x3d>
		if (from_env_store != NULL)
  810347:	85 f6                	test   %esi,%esi
  810349:	74 06                	je     810351 <ipc_recv+0x31>
			*from_env_store = 0;
  81034b:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		if (perm_store != NULL)
  810351:	85 db                	test   %ebx,%ebx
  810353:	74 2c                	je     810381 <ipc_recv+0x61>
			*perm_store = 0;
  810355:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  81035b:	eb 24                	jmp    810381 <ipc_recv+0x61>
		return r;
	}

	if (from_env_store != NULL)
  81035d:	85 f6                	test   %esi,%esi
  81035f:	74 0a                	je     81036b <ipc_recv+0x4b>
		*from_env_store = thisenv->env_ipc_from;
  810361:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810366:	8b 40 74             	mov    0x74(%eax),%eax
  810369:	89 06                	mov    %eax,(%esi)
	if (perm_store != NULL)
  81036b:	85 db                	test   %ebx,%ebx
  81036d:	74 0a                	je     810379 <ipc_recv+0x59>
		*perm_store = thisenv->env_ipc_perm;
  81036f:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  810374:	8b 40 78             	mov    0x78(%eax),%eax
  810377:	89 03                	mov    %eax,(%ebx)

	return thisenv->env_ipc_value;
  810379:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81037e:	8b 40 70             	mov    0x70(%eax),%eax
}
  810381:	83 c4 10             	add    $0x10,%esp
  810384:	5b                   	pop    %ebx
  810385:	5e                   	pop    %esi
  810386:	5d                   	pop    %ebp
  810387:	c3                   	ret    

00810388 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_try_send a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  810388:	55                   	push   %ebp
  810389:	89 e5                	mov    %esp,%ebp
  81038b:	57                   	push   %edi
  81038c:	56                   	push   %esi
  81038d:	53                   	push   %ebx
  81038e:	83 ec 1c             	sub    $0x1c,%esp
  810391:	8b 75 0c             	mov    0xc(%ebp),%esi
  810394:	8b 5d 10             	mov    0x10(%ebp),%ebx
  810397:	8b 7d 14             	mov    0x14(%ebp),%edi
	// LAB 4: Your code here.
	if (pg == NULL)
		pg = (void *) KERNBASE;
  81039a:	85 db                	test   %ebx,%ebx
  81039c:	b8 00 00 00 f0       	mov    $0xf0000000,%eax
  8103a1:	0f 44 d8             	cmove  %eax,%ebx

	int r = sys_ipc_try_send(to_env, val, pg, perm); // non-blocking call
  8103a4:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8103a8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8103ac:	89 74 24 04          	mov    %esi,0x4(%esp)
  8103b0:	8b 45 08             	mov    0x8(%ebp),%eax
  8103b3:	89 04 24             	mov    %eax,(%esp)
  8103b6:	e8 0b fa ff ff       	call   80fdc6 <sys_ipc_try_send>
	if (r == 0) return;
  8103bb:	85 c0                	test   %eax,%eax
  8103bd:	75 22                	jne    8103e1 <ipc_send+0x59>
  8103bf:	eb 4c                	jmp    81040d <ipc_send+0x85>
		
	while ((r == -E_IPC_NOT_RECV) || (r == 0)) {
		if (r == 0)
  8103c1:	84 d2                	test   %dl,%dl
  8103c3:	75 48                	jne    81040d <ipc_send+0x85>
			return;

		sys_yield(); // release CPU before attempting to send again
  8103c5:	e8 ea f7 ff ff       	call   80fbb4 <sys_yield>

		r = sys_ipc_try_send(to_env, val, pg, perm);
  8103ca:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8103ce:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8103d2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8103d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8103d9:	89 04 24             	mov    %eax,(%esp)
  8103dc:	e8 e5 f9 ff ff       	call   80fdc6 <sys_ipc_try_send>
		pg = (void *) KERNBASE;

	int r = sys_ipc_try_send(to_env, val, pg, perm); // non-blocking call
	if (r == 0) return;
		
	while ((r == -E_IPC_NOT_RECV) || (r == 0)) {
  8103e1:	85 c0                	test   %eax,%eax
  8103e3:	0f 94 c2             	sete   %dl
  8103e6:	74 d9                	je     8103c1 <ipc_send+0x39>
  8103e8:	83 f8 f9             	cmp    $0xfffffff9,%eax
  8103eb:	74 d4                	je     8103c1 <ipc_send+0x39>

		sys_yield(); // release CPU before attempting to send again

		r = sys_ipc_try_send(to_env, val, pg, perm);
	}
	panic("ipc_send: %e\n", r);
  8103ed:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8103f1:	c7 44 24 08 24 48 81 	movl   $0x814824,0x8(%esp)
  8103f8:	00 
  8103f9:	c7 44 24 04 48 00 00 	movl   $0x48,0x4(%esp)
  810400:	00 
  810401:	c7 04 24 32 48 81 00 	movl   $0x814832,(%esp)
  810408:	e8 8d ec ff ff       	call   80f09a <_panic>
}
  81040d:	83 c4 1c             	add    $0x1c,%esp
  810410:	5b                   	pop    %ebx
  810411:	5e                   	pop    %esi
  810412:	5f                   	pop    %edi
  810413:	5d                   	pop    %ebp
  810414:	c3                   	ret    

00810415 <ipc_find_env>:
// Find the first environment of the given type.  We'll use this to
// find special environments.
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
  810415:	55                   	push   %ebp
  810416:	89 e5                	mov    %esp,%ebp
  810418:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; i < NENV; i++)
  81041b:	b8 00 00 00 00       	mov    $0x0,%eax
		if (envs[i].env_type == type)
  810420:	89 c2                	mov    %eax,%edx
  810422:	c1 e2 07             	shl    $0x7,%edx
  810425:	81 c2 00 00 c0 ee    	add    $0xeec00000,%edx
  81042b:	8b 52 50             	mov    0x50(%edx),%edx
  81042e:	39 ca                	cmp    %ecx,%edx
  810430:	75 0d                	jne    81043f <ipc_find_env+0x2a>
			return envs[i].env_id;
  810432:	c1 e0 07             	shl    $0x7,%eax
  810435:	05 08 00 c0 ee       	add    $0xeec00008,%eax
  81043a:	8b 40 40             	mov    0x40(%eax),%eax
  81043d:	eb 0e                	jmp    81044d <ipc_find_env+0x38>
// Returns 0 if no such environment exists.
envid_t
ipc_find_env(enum EnvType type)
{
	int i;
	for (i = 0; i < NENV; i++)
  81043f:	83 c0 01             	add    $0x1,%eax
  810442:	3d 00 04 00 00       	cmp    $0x400,%eax
  810447:	75 d7                	jne    810420 <ipc_find_env+0xb>
		if (envs[i].env_type == type)
			return envs[i].env_id;
	return 0;
  810449:	66 b8 00 00          	mov    $0x0,%ax
}
  81044d:	5d                   	pop    %ebp
  81044e:	c3                   	ret    
  81044f:	90                   	nop

00810450 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  810450:	55                   	push   %ebp
  810451:	89 e5                	mov    %esp,%ebp
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  810453:	8b 45 08             	mov    0x8(%ebp),%eax
  810456:	05 00 00 00 30       	add    $0x30000000,%eax
  81045b:	c1 e8 0c             	shr    $0xc,%eax
}
  81045e:	5d                   	pop    %ebp
  81045f:	c3                   	ret    

00810460 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  810460:	55                   	push   %ebp
  810461:	89 e5                	mov    %esp,%ebp
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  810463:	8b 45 08             	mov    0x8(%ebp),%eax
  810466:	05 00 00 00 30       	add    $0x30000000,%eax
}

char*
fd2data(struct Fd *fd)
{
	return INDEX2DATA(fd2num(fd));
  81046b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  810470:	2d 00 00 fe 2f       	sub    $0x2ffe0000,%eax
}
  810475:	5d                   	pop    %ebp
  810476:	c3                   	ret    

00810477 <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  810477:	55                   	push   %ebp
  810478:	89 e5                	mov    %esp,%ebp
  81047a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81047d:	b8 00 00 00 d0       	mov    $0xd0000000,%eax
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
  810482:	89 c2                	mov    %eax,%edx
  810484:	c1 ea 16             	shr    $0x16,%edx
  810487:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  81048e:	f6 c2 01             	test   $0x1,%dl
  810491:	74 11                	je     8104a4 <fd_alloc+0x2d>
  810493:	89 c2                	mov    %eax,%edx
  810495:	c1 ea 0c             	shr    $0xc,%edx
  810498:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  81049f:	f6 c2 01             	test   $0x1,%dl
  8104a2:	75 09                	jne    8104ad <fd_alloc+0x36>
			*fd_store = fd;
  8104a4:	89 01                	mov    %eax,(%ecx)
			return 0;
  8104a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8104ab:	eb 17                	jmp    8104c4 <fd_alloc+0x4d>
  8104ad:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  8104b2:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  8104b7:	75 c9                	jne    810482 <fd_alloc+0xb>
		if ((uvpd[PDX(fd)] & PTE_P) == 0 || (uvpt[PGNUM(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  8104b9:	c7 01 00 00 00 00    	movl   $0x0,(%ecx)
	return -E_MAX_OPEN;
  8104bf:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
}
  8104c4:	5d                   	pop    %ebp
  8104c5:	c3                   	ret    

008104c6 <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  8104c6:	55                   	push   %ebp
  8104c7:	89 e5                	mov    %esp,%ebp
  8104c9:	8b 45 08             	mov    0x8(%ebp),%eax
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  8104cc:	83 f8 1f             	cmp    $0x1f,%eax
  8104cf:	77 36                	ja     810507 <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  8104d1:	c1 e0 0c             	shl    $0xc,%eax
  8104d4:	2d 00 00 00 30       	sub    $0x30000000,%eax
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
  8104d9:	89 c2                	mov    %eax,%edx
  8104db:	c1 ea 16             	shr    $0x16,%edx
  8104de:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8104e5:	f6 c2 01             	test   $0x1,%dl
  8104e8:	74 24                	je     81050e <fd_lookup+0x48>
  8104ea:	89 c2                	mov    %eax,%edx
  8104ec:	c1 ea 0c             	shr    $0xc,%edx
  8104ef:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8104f6:	f6 c2 01             	test   $0x1,%dl
  8104f9:	74 1a                	je     810515 <fd_lookup+0x4f>
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	*fd_store = fd;
  8104fb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8104fe:	89 02                	mov    %eax,(%edx)
	return 0;
  810500:	b8 00 00 00 00       	mov    $0x0,%eax
  810505:	eb 13                	jmp    81051a <fd_lookup+0x54>
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
		if (debug)
			cprintf("[%08x] bad fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  810507:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  81050c:	eb 0c                	jmp    81051a <fd_lookup+0x54>
	}
	fd = INDEX2FD(fdnum);
	if (!(uvpd[PDX(fd)] & PTE_P) || !(uvpt[PGNUM(fd)] & PTE_P)) {
		if (debug)
			cprintf("[%08x] closed fd %d\n", thisenv->env_id, fdnum);
		return -E_INVAL;
  81050e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810513:	eb 05                	jmp    81051a <fd_lookup+0x54>
  810515:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	}
	*fd_store = fd;
	return 0;
}
  81051a:	5d                   	pop    %ebp
  81051b:	c3                   	ret    

0081051c <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  81051c:	55                   	push   %ebp
  81051d:	89 e5                	mov    %esp,%ebp
  81051f:	83 ec 18             	sub    $0x18,%esp
  810522:	8b 4d 08             	mov    0x8(%ebp),%ecx
	int i;
	for (i = 0; devtab[i]; i++)
  810525:	ba 00 00 00 00       	mov    $0x0,%edx
  81052a:	eb 13                	jmp    81053f <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
  81052c:	39 08                	cmp    %ecx,(%eax)
  81052e:	75 0c                	jne    81053c <dev_lookup+0x20>
			*dev = devtab[i];
  810530:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810533:	89 01                	mov    %eax,(%ecx)
			return 0;
  810535:	b8 00 00 00 00       	mov    $0x0,%eax
  81053a:	eb 38                	jmp    810574 <dev_lookup+0x58>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  81053c:	83 c2 01             	add    $0x1,%edx
  81053f:	8b 04 95 b8 48 81 00 	mov    0x8148b8(,%edx,4),%eax
  810546:	85 c0                	test   %eax,%eax
  810548:	75 e2                	jne    81052c <dev_lookup+0x10>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  81054a:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81054f:	8b 40 48             	mov    0x48(%eax),%eax
  810552:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  810556:	89 44 24 04          	mov    %eax,0x4(%esp)
  81055a:	c7 04 24 3c 48 81 00 	movl   $0x81483c,(%esp)
  810561:	e8 2d ec ff ff       	call   80f193 <cprintf>
	*dev = 0;
  810566:	8b 45 0c             	mov    0xc(%ebp),%eax
  810569:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	return -E_INVAL;
  81056f:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  810574:	c9                   	leave  
  810575:	c3                   	ret    

00810576 <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  810576:	55                   	push   %ebp
  810577:	89 e5                	mov    %esp,%ebp
  810579:	56                   	push   %esi
  81057a:	53                   	push   %ebx
  81057b:	83 ec 20             	sub    $0x20,%esp
  81057e:	8b 75 08             	mov    0x8(%ebp),%esi
  810581:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810584:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810587:	89 44 24 04          	mov    %eax,0x4(%esp)
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  81058b:	8d 86 00 00 00 30    	lea    0x30000000(%esi),%eax
  810591:	c1 e8 0c             	shr    $0xc,%eax
fd_close(struct Fd *fd, bool must_exist)
{
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  810594:	89 04 24             	mov    %eax,(%esp)
  810597:	e8 2a ff ff ff       	call   8104c6 <fd_lookup>
  81059c:	85 c0                	test   %eax,%eax
  81059e:	78 05                	js     8105a5 <fd_close+0x2f>
	    || fd != fd2)
  8105a0:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  8105a3:	74 0c                	je     8105b1 <fd_close+0x3b>
		return (must_exist ? r : 0);
  8105a5:	84 db                	test   %bl,%bl
  8105a7:	ba 00 00 00 00       	mov    $0x0,%edx
  8105ac:	0f 44 c2             	cmove  %edx,%eax
  8105af:	eb 3f                	jmp    8105f0 <fd_close+0x7a>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  8105b1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8105b4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105b8:	8b 06                	mov    (%esi),%eax
  8105ba:	89 04 24             	mov    %eax,(%esp)
  8105bd:	e8 5a ff ff ff       	call   81051c <dev_lookup>
  8105c2:	89 c3                	mov    %eax,%ebx
  8105c4:	85 c0                	test   %eax,%eax
  8105c6:	78 16                	js     8105de <fd_close+0x68>
		if (dev->dev_close)
  8105c8:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8105cb:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  8105ce:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
	    || fd != fd2)
		return (must_exist ? r : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  8105d3:	85 c0                	test   %eax,%eax
  8105d5:	74 07                	je     8105de <fd_close+0x68>
			r = (*dev->dev_close)(fd);
  8105d7:	89 34 24             	mov    %esi,(%esp)
  8105da:	ff d0                	call   *%eax
  8105dc:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  8105de:	89 74 24 04          	mov    %esi,0x4(%esp)
  8105e2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8105e9:	e8 8c f6 ff ff       	call   80fc7a <sys_page_unmap>
	return r;
  8105ee:	89 d8                	mov    %ebx,%eax
}
  8105f0:	83 c4 20             	add    $0x20,%esp
  8105f3:	5b                   	pop    %ebx
  8105f4:	5e                   	pop    %esi
  8105f5:	5d                   	pop    %ebp
  8105f6:	c3                   	ret    

008105f7 <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  8105f7:	55                   	push   %ebp
  8105f8:	89 e5                	mov    %esp,%ebp
  8105fa:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8105fd:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810600:	89 44 24 04          	mov    %eax,0x4(%esp)
  810604:	8b 45 08             	mov    0x8(%ebp),%eax
  810607:	89 04 24             	mov    %eax,(%esp)
  81060a:	e8 b7 fe ff ff       	call   8104c6 <fd_lookup>
  81060f:	89 c2                	mov    %eax,%edx
  810611:	85 d2                	test   %edx,%edx
  810613:	78 13                	js     810628 <close+0x31>
		return r;
	else
		return fd_close(fd, 1);
  810615:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  81061c:	00 
  81061d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810620:	89 04 24             	mov    %eax,(%esp)
  810623:	e8 4e ff ff ff       	call   810576 <fd_close>
}
  810628:	c9                   	leave  
  810629:	c3                   	ret    

0081062a <close_all>:

void
close_all(void)
{
  81062a:	55                   	push   %ebp
  81062b:	89 e5                	mov    %esp,%ebp
  81062d:	53                   	push   %ebx
  81062e:	83 ec 14             	sub    $0x14,%esp
	int i;
	for (i = 0; i < MAXFD; i++)
  810631:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  810636:	89 1c 24             	mov    %ebx,(%esp)
  810639:	e8 b9 ff ff ff       	call   8105f7 <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  81063e:	83 c3 01             	add    $0x1,%ebx
  810641:	83 fb 20             	cmp    $0x20,%ebx
  810644:	75 f0                	jne    810636 <close_all+0xc>
		close(i);
}
  810646:	83 c4 14             	add    $0x14,%esp
  810649:	5b                   	pop    %ebx
  81064a:	5d                   	pop    %ebp
  81064b:	c3                   	ret    

0081064c <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  81064c:	55                   	push   %ebp
  81064d:	89 e5                	mov    %esp,%ebp
  81064f:	57                   	push   %edi
  810650:	56                   	push   %esi
  810651:	53                   	push   %ebx
  810652:	83 ec 3c             	sub    $0x3c,%esp
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  810655:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810658:	89 44 24 04          	mov    %eax,0x4(%esp)
  81065c:	8b 45 08             	mov    0x8(%ebp),%eax
  81065f:	89 04 24             	mov    %eax,(%esp)
  810662:	e8 5f fe ff ff       	call   8104c6 <fd_lookup>
  810667:	89 c2                	mov    %eax,%edx
  810669:	85 d2                	test   %edx,%edx
  81066b:	0f 88 e1 00 00 00    	js     810752 <dup+0x106>
		return r;
	close(newfdnum);
  810671:	8b 45 0c             	mov    0xc(%ebp),%eax
  810674:	89 04 24             	mov    %eax,(%esp)
  810677:	e8 7b ff ff ff       	call   8105f7 <close>

	newfd = INDEX2FD(newfdnum);
  81067c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  81067f:	c1 e3 0c             	shl    $0xc,%ebx
  810682:	81 eb 00 00 00 30    	sub    $0x30000000,%ebx
	ova = fd2data(oldfd);
  810688:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81068b:	89 04 24             	mov    %eax,(%esp)
  81068e:	e8 cd fd ff ff       	call   810460 <fd2data>
  810693:	89 c6                	mov    %eax,%esi
	nva = fd2data(newfd);
  810695:	89 1c 24             	mov    %ebx,(%esp)
  810698:	e8 c3 fd ff ff       	call   810460 <fd2data>
  81069d:	89 c7                	mov    %eax,%edi

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
  81069f:	89 f0                	mov    %esi,%eax
  8106a1:	c1 e8 16             	shr    $0x16,%eax
  8106a4:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  8106ab:	a8 01                	test   $0x1,%al
  8106ad:	74 43                	je     8106f2 <dup+0xa6>
  8106af:	89 f0                	mov    %esi,%eax
  8106b1:	c1 e8 0c             	shr    $0xc,%eax
  8106b4:	8b 14 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%edx
  8106bb:	f6 c2 01             	test   $0x1,%dl
  8106be:	74 32                	je     8106f2 <dup+0xa6>
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  8106c0:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8106c7:	25 07 0e 00 00       	and    $0xe07,%eax
  8106cc:	89 44 24 10          	mov    %eax,0x10(%esp)
  8106d0:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8106d4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8106db:	00 
  8106dc:	89 74 24 04          	mov    %esi,0x4(%esp)
  8106e0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8106e7:	e8 3b f5 ff ff       	call   80fc27 <sys_page_map>
  8106ec:	89 c6                	mov    %eax,%esi
  8106ee:	85 c0                	test   %eax,%eax
  8106f0:	78 3e                	js     810730 <dup+0xe4>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  8106f2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8106f5:	89 c2                	mov    %eax,%edx
  8106f7:	c1 ea 0c             	shr    $0xc,%edx
  8106fa:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  810701:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  810707:	89 54 24 10          	mov    %edx,0x10(%esp)
  81070b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  81070f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810716:	00 
  810717:	89 44 24 04          	mov    %eax,0x4(%esp)
  81071b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810722:	e8 00 f5 ff ff       	call   80fc27 <sys_page_map>
  810727:	89 c6                	mov    %eax,%esi
		goto err;

	return newfdnum;
  810729:	8b 45 0c             	mov    0xc(%ebp),%eax
	nva = fd2data(newfd);

	if ((uvpd[PDX(ova)] & PTE_P) && (uvpt[PGNUM(ova)] & PTE_P))
		if ((r = sys_page_map(0, ova, 0, nva, uvpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, uvpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  81072c:	85 f6                	test   %esi,%esi
  81072e:	79 22                	jns    810752 <dup+0x106>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  810730:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810734:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81073b:	e8 3a f5 ff ff       	call   80fc7a <sys_page_unmap>
	sys_page_unmap(0, nva);
  810740:	89 7c 24 04          	mov    %edi,0x4(%esp)
  810744:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81074b:	e8 2a f5 ff ff       	call   80fc7a <sys_page_unmap>
	return r;
  810750:	89 f0                	mov    %esi,%eax
}
  810752:	83 c4 3c             	add    $0x3c,%esp
  810755:	5b                   	pop    %ebx
  810756:	5e                   	pop    %esi
  810757:	5f                   	pop    %edi
  810758:	5d                   	pop    %ebp
  810759:	c3                   	ret    

0081075a <read>:

ssize_t
read(int fdnum, void *buf, size_t n)
{
  81075a:	55                   	push   %ebp
  81075b:	89 e5                	mov    %esp,%ebp
  81075d:	53                   	push   %ebx
  81075e:	83 ec 24             	sub    $0x24,%esp
  810761:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810764:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810767:	89 44 24 04          	mov    %eax,0x4(%esp)
  81076b:	89 1c 24             	mov    %ebx,(%esp)
  81076e:	e8 53 fd ff ff       	call   8104c6 <fd_lookup>
  810773:	89 c2                	mov    %eax,%edx
  810775:	85 d2                	test   %edx,%edx
  810777:	78 6d                	js     8107e6 <read+0x8c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810779:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81077c:	89 44 24 04          	mov    %eax,0x4(%esp)
  810780:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810783:	8b 00                	mov    (%eax),%eax
  810785:	89 04 24             	mov    %eax,(%esp)
  810788:	e8 8f fd ff ff       	call   81051c <dev_lookup>
  81078d:	85 c0                	test   %eax,%eax
  81078f:	78 55                	js     8107e6 <read+0x8c>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  810791:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810794:	8b 50 08             	mov    0x8(%eax),%edx
  810797:	83 e2 03             	and    $0x3,%edx
  81079a:	83 fa 01             	cmp    $0x1,%edx
  81079d:	75 23                	jne    8107c2 <read+0x68>
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  81079f:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  8107a4:	8b 40 48             	mov    0x48(%eax),%eax
  8107a7:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8107ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8107af:	c7 04 24 7d 48 81 00 	movl   $0x81487d,(%esp)
  8107b6:	e8 d8 e9 ff ff       	call   80f193 <cprintf>
		return -E_INVAL;
  8107bb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  8107c0:	eb 24                	jmp    8107e6 <read+0x8c>
	}
	if (!dev->dev_read)
  8107c2:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8107c5:	8b 52 08             	mov    0x8(%edx),%edx
  8107c8:	85 d2                	test   %edx,%edx
  8107ca:	74 15                	je     8107e1 <read+0x87>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  8107cc:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8107cf:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8107d3:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8107d6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8107da:	89 04 24             	mov    %eax,(%esp)
  8107dd:	ff d2                	call   *%edx
  8107df:	eb 05                	jmp    8107e6 <read+0x8c>
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
		return -E_NOT_SUPP;
  8107e1:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_read)(fd, buf, n);
}
  8107e6:	83 c4 24             	add    $0x24,%esp
  8107e9:	5b                   	pop    %ebx
  8107ea:	5d                   	pop    %ebp
  8107eb:	c3                   	ret    

008107ec <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  8107ec:	55                   	push   %ebp
  8107ed:	89 e5                	mov    %esp,%ebp
  8107ef:	57                   	push   %edi
  8107f0:	56                   	push   %esi
  8107f1:	53                   	push   %ebx
  8107f2:	83 ec 1c             	sub    $0x1c,%esp
  8107f5:	8b 7d 08             	mov    0x8(%ebp),%edi
  8107f8:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8107fb:	bb 00 00 00 00       	mov    $0x0,%ebx
  810800:	eb 23                	jmp    810825 <readn+0x39>
		m = read(fdnum, (char*)buf + tot, n - tot);
  810802:	89 f0                	mov    %esi,%eax
  810804:	29 d8                	sub    %ebx,%eax
  810806:	89 44 24 08          	mov    %eax,0x8(%esp)
  81080a:	89 d8                	mov    %ebx,%eax
  81080c:	03 45 0c             	add    0xc(%ebp),%eax
  81080f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810813:	89 3c 24             	mov    %edi,(%esp)
  810816:	e8 3f ff ff ff       	call   81075a <read>
		if (m < 0)
  81081b:	85 c0                	test   %eax,%eax
  81081d:	78 10                	js     81082f <readn+0x43>
			return m;
		if (m == 0)
  81081f:	85 c0                	test   %eax,%eax
  810821:	74 0a                	je     81082d <readn+0x41>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  810823:	01 c3                	add    %eax,%ebx
  810825:	39 f3                	cmp    %esi,%ebx
  810827:	72 d9                	jb     810802 <readn+0x16>
  810829:	89 d8                	mov    %ebx,%eax
  81082b:	eb 02                	jmp    81082f <readn+0x43>
  81082d:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  81082f:	83 c4 1c             	add    $0x1c,%esp
  810832:	5b                   	pop    %ebx
  810833:	5e                   	pop    %esi
  810834:	5f                   	pop    %edi
  810835:	5d                   	pop    %ebp
  810836:	c3                   	ret    

00810837 <write>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  810837:	55                   	push   %ebp
  810838:	89 e5                	mov    %esp,%ebp
  81083a:	53                   	push   %ebx
  81083b:	83 ec 24             	sub    $0x24,%esp
  81083e:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810841:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810844:	89 44 24 04          	mov    %eax,0x4(%esp)
  810848:	89 1c 24             	mov    %ebx,(%esp)
  81084b:	e8 76 fc ff ff       	call   8104c6 <fd_lookup>
  810850:	89 c2                	mov    %eax,%edx
  810852:	85 d2                	test   %edx,%edx
  810854:	78 68                	js     8108be <write+0x87>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810856:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810859:	89 44 24 04          	mov    %eax,0x4(%esp)
  81085d:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810860:	8b 00                	mov    (%eax),%eax
  810862:	89 04 24             	mov    %eax,(%esp)
  810865:	e8 b2 fc ff ff       	call   81051c <dev_lookup>
  81086a:	85 c0                	test   %eax,%eax
  81086c:	78 50                	js     8108be <write+0x87>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  81086e:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810871:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  810875:	75 23                	jne    81089a <write+0x63>
		cprintf("[%08x] write %d -- bad mode\n", thisenv->env_id, fdnum);
  810877:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81087c:	8b 40 48             	mov    0x48(%eax),%eax
  81087f:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  810883:	89 44 24 04          	mov    %eax,0x4(%esp)
  810887:	c7 04 24 99 48 81 00 	movl   $0x814899,(%esp)
  81088e:	e8 00 e9 ff ff       	call   80f193 <cprintf>
		return -E_INVAL;
  810893:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810898:	eb 24                	jmp    8108be <write+0x87>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  81089a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81089d:	8b 52 0c             	mov    0xc(%edx),%edx
  8108a0:	85 d2                	test   %edx,%edx
  8108a2:	74 15                	je     8108b9 <write+0x82>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  8108a4:	8b 4d 10             	mov    0x10(%ebp),%ecx
  8108a7:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8108ab:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8108ae:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8108b2:	89 04 24             	mov    %eax,(%esp)
  8108b5:	ff d2                	call   *%edx
  8108b7:	eb 05                	jmp    8108be <write+0x87>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
		return -E_NOT_SUPP;
  8108b9:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_write)(fd, buf, n);
}
  8108be:	83 c4 24             	add    $0x24,%esp
  8108c1:	5b                   	pop    %ebx
  8108c2:	5d                   	pop    %ebp
  8108c3:	c3                   	ret    

008108c4 <seek>:

int
seek(int fdnum, off_t offset)
{
  8108c4:	55                   	push   %ebp
  8108c5:	89 e5                	mov    %esp,%ebp
  8108c7:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  8108ca:	8d 45 fc             	lea    -0x4(%ebp),%eax
  8108cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8108d1:	8b 45 08             	mov    0x8(%ebp),%eax
  8108d4:	89 04 24             	mov    %eax,(%esp)
  8108d7:	e8 ea fb ff ff       	call   8104c6 <fd_lookup>
  8108dc:	85 c0                	test   %eax,%eax
  8108de:	78 0e                	js     8108ee <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  8108e0:	8b 45 fc             	mov    -0x4(%ebp),%eax
  8108e3:	8b 55 0c             	mov    0xc(%ebp),%edx
  8108e6:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  8108e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8108ee:	c9                   	leave  
  8108ef:	c3                   	ret    

008108f0 <ftruncate>:

int
ftruncate(int fdnum, off_t newsize)
{
  8108f0:	55                   	push   %ebp
  8108f1:	89 e5                	mov    %esp,%ebp
  8108f3:	53                   	push   %ebx
  8108f4:	83 ec 24             	sub    $0x24,%esp
  8108f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8108fa:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8108fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  810901:	89 1c 24             	mov    %ebx,(%esp)
  810904:	e8 bd fb ff ff       	call   8104c6 <fd_lookup>
  810909:	89 c2                	mov    %eax,%edx
  81090b:	85 d2                	test   %edx,%edx
  81090d:	78 61                	js     810970 <ftruncate+0x80>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  81090f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810912:	89 44 24 04          	mov    %eax,0x4(%esp)
  810916:	8b 45 f0             	mov    -0x10(%ebp),%eax
  810919:	8b 00                	mov    (%eax),%eax
  81091b:	89 04 24             	mov    %eax,(%esp)
  81091e:	e8 f9 fb ff ff       	call   81051c <dev_lookup>
  810923:	85 c0                	test   %eax,%eax
  810925:	78 49                	js     810970 <ftruncate+0x80>
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  810927:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81092a:	f6 40 08 03          	testb  $0x3,0x8(%eax)
  81092e:	75 23                	jne    810953 <ftruncate+0x63>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
  810930:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  810935:	8b 40 48             	mov    0x48(%eax),%eax
  810938:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  81093c:	89 44 24 04          	mov    %eax,0x4(%esp)
  810940:	c7 04 24 5c 48 81 00 	movl   $0x81485c,(%esp)
  810947:	e8 47 e8 ff ff       	call   80f193 <cprintf>
			thisenv->env_id, fdnum);
		return -E_INVAL;
  81094c:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  810951:	eb 1d                	jmp    810970 <ftruncate+0x80>
	}
	if (!dev->dev_trunc)
  810953:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810956:	8b 52 18             	mov    0x18(%edx),%edx
  810959:	85 d2                	test   %edx,%edx
  81095b:	74 0e                	je     81096b <ftruncate+0x7b>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  81095d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  810960:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810964:	89 04 24             	mov    %eax,(%esp)
  810967:	ff d2                	call   *%edx
  810969:	eb 05                	jmp    810970 <ftruncate+0x80>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
		return -E_NOT_SUPP;
  81096b:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return (*dev->dev_trunc)(fd, newsize);
}
  810970:	83 c4 24             	add    $0x24,%esp
  810973:	5b                   	pop    %ebx
  810974:	5d                   	pop    %ebp
  810975:	c3                   	ret    

00810976 <fstat>:

int
fstat(int fdnum, struct Stat *stat)
{
  810976:	55                   	push   %ebp
  810977:	89 e5                	mov    %esp,%ebp
  810979:	53                   	push   %ebx
  81097a:	83 ec 24             	sub    $0x24,%esp
  81097d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  810980:	8d 45 f0             	lea    -0x10(%ebp),%eax
  810983:	89 44 24 04          	mov    %eax,0x4(%esp)
  810987:	8b 45 08             	mov    0x8(%ebp),%eax
  81098a:	89 04 24             	mov    %eax,(%esp)
  81098d:	e8 34 fb ff ff       	call   8104c6 <fd_lookup>
  810992:	89 c2                	mov    %eax,%edx
  810994:	85 d2                	test   %edx,%edx
  810996:	78 52                	js     8109ea <fstat+0x74>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  810998:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81099b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81099f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8109a2:	8b 00                	mov    (%eax),%eax
  8109a4:	89 04 24             	mov    %eax,(%esp)
  8109a7:	e8 70 fb ff ff       	call   81051c <dev_lookup>
  8109ac:	85 c0                	test   %eax,%eax
  8109ae:	78 3a                	js     8109ea <fstat+0x74>
		return r;
	if (!dev->dev_stat)
  8109b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8109b3:	83 78 14 00          	cmpl   $0x0,0x14(%eax)
  8109b7:	74 2c                	je     8109e5 <fstat+0x6f>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  8109b9:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  8109bc:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8109c3:	00 00 00 
	stat->st_isdir = 0;
  8109c6:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8109cd:	00 00 00 
	stat->st_dev = dev;
  8109d0:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8109d6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8109da:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8109dd:	89 14 24             	mov    %edx,(%esp)
  8109e0:	ff 50 14             	call   *0x14(%eax)
  8109e3:	eb 05                	jmp    8109ea <fstat+0x74>

	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
  8109e5:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	stat->st_name[0] = 0;
	stat->st_size = 0;
	stat->st_isdir = 0;
	stat->st_dev = dev;
	return (*dev->dev_stat)(fd, stat);
}
  8109ea:	83 c4 24             	add    $0x24,%esp
  8109ed:	5b                   	pop    %ebx
  8109ee:	5d                   	pop    %ebp
  8109ef:	c3                   	ret    

008109f0 <stat>:

int
stat(const char *path, struct Stat *stat)
{
  8109f0:	55                   	push   %ebp
  8109f1:	89 e5                	mov    %esp,%ebp
  8109f3:	56                   	push   %esi
  8109f4:	53                   	push   %ebx
  8109f5:	83 ec 10             	sub    $0x10,%esp
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8109f8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8109ff:	00 
  810a00:	8b 45 08             	mov    0x8(%ebp),%eax
  810a03:	89 04 24             	mov    %eax,(%esp)
  810a06:	e8 84 02 00 00       	call   810c8f <open>
  810a0b:	89 c3                	mov    %eax,%ebx
  810a0d:	85 db                	test   %ebx,%ebx
  810a0f:	78 1b                	js     810a2c <stat+0x3c>
		return fd;
	r = fstat(fd, stat);
  810a11:	8b 45 0c             	mov    0xc(%ebp),%eax
  810a14:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a18:	89 1c 24             	mov    %ebx,(%esp)
  810a1b:	e8 56 ff ff ff       	call   810976 <fstat>
  810a20:	89 c6                	mov    %eax,%esi
	close(fd);
  810a22:	89 1c 24             	mov    %ebx,(%esp)
  810a25:	e8 cd fb ff ff       	call   8105f7 <close>
	return r;
  810a2a:	89 f0                	mov    %esi,%eax
}
  810a2c:	83 c4 10             	add    $0x10,%esp
  810a2f:	5b                   	pop    %ebx
  810a30:	5e                   	pop    %esi
  810a31:	5d                   	pop    %ebp
  810a32:	c3                   	ret    

00810a33 <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  810a33:	55                   	push   %ebp
  810a34:	89 e5                	mov    %esp,%ebp
  810a36:	56                   	push   %esi
  810a37:	53                   	push   %ebx
  810a38:	83 ec 10             	sub    $0x10,%esp
  810a3b:	89 c6                	mov    %eax,%esi
  810a3d:	89 d3                	mov    %edx,%ebx
	static envid_t fsenv;
	if (fsenv == 0)
  810a3f:	83 3d ec c1 b3 00 00 	cmpl   $0x0,0xb3c1ec
  810a46:	75 11                	jne    810a59 <fsipc+0x26>
		fsenv = ipc_find_env(ENV_TYPE_FS);
  810a48:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  810a4f:	e8 c1 f9 ff ff       	call   810415 <ipc_find_env>
  810a54:	a3 ec c1 b3 00       	mov    %eax,0xb3c1ec
	static_assert(sizeof(fsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", thisenv->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(fsenv, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  810a59:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810a60:	00 
  810a61:	c7 44 24 08 00 d0 b3 	movl   $0xb3d000,0x8(%esp)
  810a68:	00 
  810a69:	89 74 24 04          	mov    %esi,0x4(%esp)
  810a6d:	a1 ec c1 b3 00       	mov    0xb3c1ec,%eax
  810a72:	89 04 24             	mov    %eax,(%esp)
  810a75:	e8 0e f9 ff ff       	call   810388 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  810a7a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810a81:	00 
  810a82:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810a86:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810a8d:	e8 8e f8 ff ff       	call   810320 <ipc_recv>
}
  810a92:	83 c4 10             	add    $0x10,%esp
  810a95:	5b                   	pop    %ebx
  810a96:	5e                   	pop    %esi
  810a97:	5d                   	pop    %ebp
  810a98:	c3                   	ret    

00810a99 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  810a99:	55                   	push   %ebp
  810a9a:	89 e5                	mov    %esp,%ebp
  810a9c:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  810a9f:	8b 45 08             	mov    0x8(%ebp),%eax
  810aa2:	8b 40 0c             	mov    0xc(%eax),%eax
  810aa5:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.set_size.req_size = newsize;
  810aaa:	8b 45 0c             	mov    0xc(%ebp),%eax
  810aad:	a3 04 d0 b3 00       	mov    %eax,0xb3d004
	return fsipc(FSREQ_SET_SIZE, NULL);
  810ab2:	ba 00 00 00 00       	mov    $0x0,%edx
  810ab7:	b8 02 00 00 00       	mov    $0x2,%eax
  810abc:	e8 72 ff ff ff       	call   810a33 <fsipc>
}
  810ac1:	c9                   	leave  
  810ac2:	c3                   	ret    

00810ac3 <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  810ac3:	55                   	push   %ebp
  810ac4:	89 e5                	mov    %esp,%ebp
  810ac6:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  810ac9:	8b 45 08             	mov    0x8(%ebp),%eax
  810acc:	8b 40 0c             	mov    0xc(%eax),%eax
  810acf:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	return fsipc(FSREQ_FLUSH, NULL);
  810ad4:	ba 00 00 00 00       	mov    $0x0,%edx
  810ad9:	b8 06 00 00 00       	mov    $0x6,%eax
  810ade:	e8 50 ff ff ff       	call   810a33 <fsipc>
}
  810ae3:	c9                   	leave  
  810ae4:	c3                   	ret    

00810ae5 <devfile_stat>:
	return r;
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  810ae5:	55                   	push   %ebp
  810ae6:	89 e5                	mov    %esp,%ebp
  810ae8:	53                   	push   %ebx
  810ae9:	83 ec 14             	sub    $0x14,%esp
  810aec:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  810aef:	8b 45 08             	mov    0x8(%ebp),%eax
  810af2:	8b 40 0c             	mov    0xc(%eax),%eax
  810af5:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  810afa:	ba 00 00 00 00       	mov    $0x0,%edx
  810aff:	b8 05 00 00 00       	mov    $0x5,%eax
  810b04:	e8 2a ff ff ff       	call   810a33 <fsipc>
  810b09:	89 c2                	mov    %eax,%edx
  810b0b:	85 d2                	test   %edx,%edx
  810b0d:	78 2b                	js     810b3a <devfile_stat+0x55>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  810b0f:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  810b16:	00 
  810b17:	89 1c 24             	mov    %ebx,(%esp)
  810b1a:	e8 98 ec ff ff       	call   80f7b7 <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  810b1f:	a1 80 d0 b3 00       	mov    0xb3d080,%eax
  810b24:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  810b2a:	a1 84 d0 b3 00       	mov    0xb3d084,%eax
  810b2f:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
	return 0;
  810b35:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810b3a:	83 c4 14             	add    $0x14,%esp
  810b3d:	5b                   	pop    %ebx
  810b3e:	5d                   	pop    %ebp
  810b3f:	c3                   	ret    

00810b40 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  810b40:	55                   	push   %ebp
  810b41:	89 e5                	mov    %esp,%ebp
  810b43:	53                   	push   %ebx
  810b44:	83 ec 14             	sub    $0x14,%esp
  810b47:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// bytes than requested.
	// LAB 5: Your code here
	int r;

	const ssize_t wbuf_size = sizeof(fsipcbuf.write.req_buf);
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  810b4a:	8b 45 08             	mov    0x8(%ebp),%eax
  810b4d:	8b 40 0c             	mov    0xc(%eax),%eax
  810b50:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.write.req_n = n > wbuf_size? wbuf_size: n;
  810b55:	81 fb f8 0f 00 00    	cmp    $0xff8,%ebx
  810b5b:	b8 f8 0f 00 00       	mov    $0xff8,%eax
  810b60:	0f 46 c3             	cmovbe %ebx,%eax
  810b63:	a3 04 d0 b3 00       	mov    %eax,0xb3d004

	memmove(fsipcbuf.write.req_buf, buf, fsipcbuf.write.req_n);
  810b68:	89 44 24 08          	mov    %eax,0x8(%esp)
  810b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
  810b6f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b73:	c7 04 24 08 d0 b3 00 	movl   $0xb3d008,(%esp)
  810b7a:	e8 d5 ed ff ff       	call   80f954 <memmove>

	if ((r = fsipc(FSREQ_WRITE, NULL)) < 0)
  810b7f:	ba 00 00 00 00       	mov    $0x0,%edx
  810b84:	b8 04 00 00 00       	mov    $0x4,%eax
  810b89:	e8 a5 fe ff ff       	call   810a33 <fsipc>
  810b8e:	85 c0                	test   %eax,%eax
  810b90:	78 53                	js     810be5 <devfile_write+0xa5>
		return r;

	assert(r <= n);
  810b92:	39 c3                	cmp    %eax,%ebx
  810b94:	73 24                	jae    810bba <devfile_write+0x7a>
  810b96:	c7 44 24 0c cc 48 81 	movl   $0x8148cc,0xc(%esp)
  810b9d:	00 
  810b9e:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  810ba5:	00 
  810ba6:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  810bad:	00 
  810bae:	c7 04 24 d3 48 81 00 	movl   $0x8148d3,(%esp)
  810bb5:	e8 e0 e4 ff ff       	call   80f09a <_panic>
	assert(r <= PGSIZE);
  810bba:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810bbf:	7e 24                	jle    810be5 <devfile_write+0xa5>
  810bc1:	c7 44 24 0c de 48 81 	movl   $0x8148de,0xc(%esp)
  810bc8:	00 
  810bc9:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  810bd0:	00 
  810bd1:	c7 44 24 04 9c 00 00 	movl   $0x9c,0x4(%esp)
  810bd8:	00 
  810bd9:	c7 04 24 d3 48 81 00 	movl   $0x8148d3,(%esp)
  810be0:	e8 b5 e4 ff ff       	call   80f09a <_panic>
	return r;
}
  810be5:	83 c4 14             	add    $0x14,%esp
  810be8:	5b                   	pop    %ebx
  810be9:	5d                   	pop    %ebp
  810bea:	c3                   	ret    

00810beb <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  810beb:	55                   	push   %ebp
  810bec:	89 e5                	mov    %esp,%ebp
  810bee:	56                   	push   %esi
  810bef:	53                   	push   %ebx
  810bf0:	83 ec 10             	sub    $0x10,%esp
  810bf3:	8b 75 10             	mov    0x10(%ebp),%esi
	// filling fsipcbuf.read with the request arguments.  The
	// bytes read will be written back to fsipcbuf by the file
	// system server.
	int r;

	fsipcbuf.read.req_fileid = fd->fd_file.id;
  810bf6:	8b 45 08             	mov    0x8(%ebp),%eax
  810bf9:	8b 40 0c             	mov    0xc(%eax),%eax
  810bfc:	a3 00 d0 b3 00       	mov    %eax,0xb3d000
	fsipcbuf.read.req_n = n;
  810c01:	89 35 04 d0 b3 00    	mov    %esi,0xb3d004
	if ((r = fsipc(FSREQ_READ, NULL)) < 0)
  810c07:	ba 00 00 00 00       	mov    $0x0,%edx
  810c0c:	b8 03 00 00 00       	mov    $0x3,%eax
  810c11:	e8 1d fe ff ff       	call   810a33 <fsipc>
  810c16:	89 c3                	mov    %eax,%ebx
  810c18:	85 c0                	test   %eax,%eax
  810c1a:	78 6a                	js     810c86 <devfile_read+0x9b>
		return r;
	assert(r <= n);
  810c1c:	39 c6                	cmp    %eax,%esi
  810c1e:	73 24                	jae    810c44 <devfile_read+0x59>
  810c20:	c7 44 24 0c cc 48 81 	movl   $0x8148cc,0xc(%esp)
  810c27:	00 
  810c28:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  810c2f:	00 
  810c30:	c7 44 24 04 7c 00 00 	movl   $0x7c,0x4(%esp)
  810c37:	00 
  810c38:	c7 04 24 d3 48 81 00 	movl   $0x8148d3,(%esp)
  810c3f:	e8 56 e4 ff ff       	call   80f09a <_panic>
	assert(r <= PGSIZE);
  810c44:	3d 00 10 00 00       	cmp    $0x1000,%eax
  810c49:	7e 24                	jle    810c6f <devfile_read+0x84>
  810c4b:	c7 44 24 0c de 48 81 	movl   $0x8148de,0xc(%esp)
  810c52:	00 
  810c53:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  810c5a:	00 
  810c5b:	c7 44 24 04 7d 00 00 	movl   $0x7d,0x4(%esp)
  810c62:	00 
  810c63:	c7 04 24 d3 48 81 00 	movl   $0x8148d3,(%esp)
  810c6a:	e8 2b e4 ff ff       	call   80f09a <_panic>
	memmove(buf, fsipcbuf.readRet.ret_buf, r);
  810c6f:	89 44 24 08          	mov    %eax,0x8(%esp)
  810c73:	c7 44 24 04 00 d0 b3 	movl   $0xb3d000,0x4(%esp)
  810c7a:	00 
  810c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
  810c7e:	89 04 24             	mov    %eax,(%esp)
  810c81:	e8 ce ec ff ff       	call   80f954 <memmove>
	return r;
}
  810c86:	89 d8                	mov    %ebx,%eax
  810c88:	83 c4 10             	add    $0x10,%esp
  810c8b:	5b                   	pop    %ebx
  810c8c:	5e                   	pop    %esi
  810c8d:	5d                   	pop    %ebp
  810c8e:	c3                   	ret    

00810c8f <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  810c8f:	55                   	push   %ebp
  810c90:	89 e5                	mov    %esp,%ebp
  810c92:	53                   	push   %ebx
  810c93:	83 ec 24             	sub    $0x24,%esp
  810c96:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// file descriptor.

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
  810c99:	89 1c 24             	mov    %ebx,(%esp)
  810c9c:	e8 df ea ff ff       	call   80f780 <strlen>
  810ca1:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  810ca6:	7f 60                	jg     810d08 <open+0x79>
		return -E_BAD_PATH;

	if ((r = fd_alloc(&fd)) < 0)
  810ca8:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810cab:	89 04 24             	mov    %eax,(%esp)
  810cae:	e8 c4 f7 ff ff       	call   810477 <fd_alloc>
  810cb3:	89 c2                	mov    %eax,%edx
  810cb5:	85 d2                	test   %edx,%edx
  810cb7:	78 54                	js     810d0d <open+0x7e>
		return r;

	strcpy(fsipcbuf.open.req_path, path);
  810cb9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810cbd:	c7 04 24 00 d0 b3 00 	movl   $0xb3d000,(%esp)
  810cc4:	e8 ee ea ff ff       	call   80f7b7 <strcpy>
	fsipcbuf.open.req_omode = mode;
  810cc9:	8b 45 0c             	mov    0xc(%ebp),%eax
  810ccc:	a3 00 d4 b3 00       	mov    %eax,0xb3d400

	if ((r = fsipc(FSREQ_OPEN, fd)) < 0) {
  810cd1:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810cd4:	b8 01 00 00 00       	mov    $0x1,%eax
  810cd9:	e8 55 fd ff ff       	call   810a33 <fsipc>
  810cde:	89 c3                	mov    %eax,%ebx
  810ce0:	85 c0                	test   %eax,%eax
  810ce2:	79 17                	jns    810cfb <open+0x6c>
		fd_close(fd, 0);
  810ce4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810ceb:	00 
  810cec:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810cef:	89 04 24             	mov    %eax,(%esp)
  810cf2:	e8 7f f8 ff ff       	call   810576 <fd_close>
		return r;
  810cf7:	89 d8                	mov    %ebx,%eax
  810cf9:	eb 12                	jmp    810d0d <open+0x7e>
	}

	return fd2num(fd);
  810cfb:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810cfe:	89 04 24             	mov    %eax,(%esp)
  810d01:	e8 4a f7 ff ff       	call   810450 <fd2num>
  810d06:	eb 05                	jmp    810d0d <open+0x7e>

	int r;
	struct Fd *fd;

	if (strlen(path) >= MAXPATHLEN)
		return -E_BAD_PATH;
  810d08:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
		fd_close(fd, 0);
		return r;
	}

	return fd2num(fd);
}
  810d0d:	83 c4 24             	add    $0x24,%esp
  810d10:	5b                   	pop    %ebx
  810d11:	5d                   	pop    %ebp
  810d12:	c3                   	ret    

00810d13 <sync>:


// Synchronize disk with buffer cache
int
sync(void)
{
  810d13:	55                   	push   %ebp
  810d14:	89 e5                	mov    %esp,%ebp
  810d16:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  810d19:	ba 00 00 00 00       	mov    $0x0,%edx
  810d1e:	b8 08 00 00 00       	mov    $0x8,%eax
  810d23:	e8 0b fd ff ff       	call   810a33 <fsipc>
}
  810d28:	c9                   	leave  
  810d29:	c3                   	ret    
  810d2a:	66 90                	xchg   %ax,%ax
  810d2c:	66 90                	xchg   %ax,%ax
  810d2e:	66 90                	xchg   %ax,%ax

00810d30 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  810d30:	55                   	push   %ebp
  810d31:	89 e5                	mov    %esp,%ebp
  810d33:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  810d36:	c7 44 24 04 ea 48 81 	movl   $0x8148ea,0x4(%esp)
  810d3d:	00 
  810d3e:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d41:	89 04 24             	mov    %eax,(%esp)
  810d44:	e8 6e ea ff ff       	call   80f7b7 <strcpy>
	return 0;
}
  810d49:	b8 00 00 00 00       	mov    $0x0,%eax
  810d4e:	c9                   	leave  
  810d4f:	c3                   	ret    

00810d50 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  810d50:	55                   	push   %ebp
  810d51:	89 e5                	mov    %esp,%ebp
  810d53:	53                   	push   %ebx
  810d54:	83 ec 14             	sub    $0x14,%esp
  810d57:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  810d5a:	89 1c 24             	mov    %ebx,(%esp)
  810d5d:	e8 49 0d 00 00       	call   811aab <pageref>
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  810d62:	ba 00 00 00 00       	mov    $0x0,%edx
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  810d67:	83 f8 01             	cmp    $0x1,%eax
  810d6a:	75 0d                	jne    810d79 <devsock_close+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  810d6c:	8b 43 0c             	mov    0xc(%ebx),%eax
  810d6f:	89 04 24             	mov    %eax,(%esp)
  810d72:	e8 29 03 00 00       	call   8110a0 <nsipc_close>
  810d77:	89 c2                	mov    %eax,%edx
	else
		return 0;
}
  810d79:	89 d0                	mov    %edx,%eax
  810d7b:	83 c4 14             	add    $0x14,%esp
  810d7e:	5b                   	pop    %ebx
  810d7f:	5d                   	pop    %ebp
  810d80:	c3                   	ret    

00810d81 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  810d81:	55                   	push   %ebp
  810d82:	89 e5                	mov    %esp,%ebp
  810d84:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  810d87:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810d8e:	00 
  810d8f:	8b 45 10             	mov    0x10(%ebp),%eax
  810d92:	89 44 24 08          	mov    %eax,0x8(%esp)
  810d96:	8b 45 0c             	mov    0xc(%ebp),%eax
  810d99:	89 44 24 04          	mov    %eax,0x4(%esp)
  810d9d:	8b 45 08             	mov    0x8(%ebp),%eax
  810da0:	8b 40 0c             	mov    0xc(%eax),%eax
  810da3:	89 04 24             	mov    %eax,(%esp)
  810da6:	e8 f0 03 00 00       	call   81119b <nsipc_send>
}
  810dab:	c9                   	leave  
  810dac:	c3                   	ret    

00810dad <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  810dad:	55                   	push   %ebp
  810dae:	89 e5                	mov    %esp,%ebp
  810db0:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  810db3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  810dba:	00 
  810dbb:	8b 45 10             	mov    0x10(%ebp),%eax
  810dbe:	89 44 24 08          	mov    %eax,0x8(%esp)
  810dc2:	8b 45 0c             	mov    0xc(%ebp),%eax
  810dc5:	89 44 24 04          	mov    %eax,0x4(%esp)
  810dc9:	8b 45 08             	mov    0x8(%ebp),%eax
  810dcc:	8b 40 0c             	mov    0xc(%eax),%eax
  810dcf:	89 04 24             	mov    %eax,(%esp)
  810dd2:	e8 44 03 00 00       	call   81111b <nsipc_recv>
}
  810dd7:	c9                   	leave  
  810dd8:	c3                   	ret    

00810dd9 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  810dd9:	55                   	push   %ebp
  810dda:	89 e5                	mov    %esp,%ebp
  810ddc:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  810ddf:	8d 55 f4             	lea    -0xc(%ebp),%edx
  810de2:	89 54 24 04          	mov    %edx,0x4(%esp)
  810de6:	89 04 24             	mov    %eax,(%esp)
  810de9:	e8 d8 f6 ff ff       	call   8104c6 <fd_lookup>
  810dee:	85 c0                	test   %eax,%eax
  810df0:	78 17                	js     810e09 <fd2sockid+0x30>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  810df2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810df5:	8b 0d 08 53 81 00    	mov    0x815308,%ecx
  810dfb:	39 08                	cmp    %ecx,(%eax)
  810dfd:	75 05                	jne    810e04 <fd2sockid+0x2b>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  810dff:	8b 40 0c             	mov    0xc(%eax),%eax
  810e02:	eb 05                	jmp    810e09 <fd2sockid+0x30>
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
		return -E_NOT_SUPP;
  810e04:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	return sfd->fd_sock.sockid;
}
  810e09:	c9                   	leave  
  810e0a:	c3                   	ret    

00810e0b <alloc_sockfd>:

static int
alloc_sockfd(int sockid)
{
  810e0b:	55                   	push   %ebp
  810e0c:	89 e5                	mov    %esp,%ebp
  810e0e:	56                   	push   %esi
  810e0f:	53                   	push   %ebx
  810e10:	83 ec 20             	sub    $0x20,%esp
  810e13:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  810e15:	8d 45 f4             	lea    -0xc(%ebp),%eax
  810e18:	89 04 24             	mov    %eax,(%esp)
  810e1b:	e8 57 f6 ff ff       	call   810477 <fd_alloc>
  810e20:	89 c3                	mov    %eax,%ebx
  810e22:	85 c0                	test   %eax,%eax
  810e24:	78 21                	js     810e47 <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
  810e26:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  810e2d:	00 
  810e2e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e31:	89 44 24 04          	mov    %eax,0x4(%esp)
  810e35:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810e3c:	e8 92 ed ff ff       	call   80fbd3 <sys_page_alloc>
  810e41:	89 c3                	mov    %eax,%ebx
  810e43:	85 c0                	test   %eax,%eax
  810e45:	79 0c                	jns    810e53 <alloc_sockfd+0x48>
		nsipc_close(sockid);
  810e47:	89 34 24             	mov    %esi,(%esp)
  810e4a:	e8 51 02 00 00       	call   8110a0 <nsipc_close>
		return r;
  810e4f:	89 d8                	mov    %ebx,%eax
  810e51:	eb 20                	jmp    810e73 <alloc_sockfd+0x68>
	}

	sfd->fd_dev_id = devsock.dev_id;
  810e53:	8b 15 08 53 81 00    	mov    0x815308,%edx
  810e59:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810e5c:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  810e5e:	8b 55 f4             	mov    -0xc(%ebp),%edx
  810e61:	c7 42 08 02 00 00 00 	movl   $0x2,0x8(%edx)
	sfd->fd_sock.sockid = sockid;
  810e68:	89 72 0c             	mov    %esi,0xc(%edx)
	return fd2num(sfd);
  810e6b:	89 14 24             	mov    %edx,(%esp)
  810e6e:	e8 dd f5 ff ff       	call   810450 <fd2num>
}
  810e73:	83 c4 20             	add    $0x20,%esp
  810e76:	5b                   	pop    %ebx
  810e77:	5e                   	pop    %esi
  810e78:	5d                   	pop    %ebp
  810e79:	c3                   	ret    

00810e7a <accept>:

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810e7a:	55                   	push   %ebp
  810e7b:	89 e5                	mov    %esp,%ebp
  810e7d:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810e80:	8b 45 08             	mov    0x8(%ebp),%eax
  810e83:	e8 51 ff ff ff       	call   810dd9 <fd2sockid>
		return r;
  810e88:	89 c1                	mov    %eax,%ecx

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
  810e8a:	85 c0                	test   %eax,%eax
  810e8c:	78 23                	js     810eb1 <accept+0x37>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810e8e:	8b 55 10             	mov    0x10(%ebp),%edx
  810e91:	89 54 24 08          	mov    %edx,0x8(%esp)
  810e95:	8b 55 0c             	mov    0xc(%ebp),%edx
  810e98:	89 54 24 04          	mov    %edx,0x4(%esp)
  810e9c:	89 04 24             	mov    %eax,(%esp)
  810e9f:	e8 45 01 00 00       	call   810fe9 <nsipc_accept>
		return r;
  810ea4:	89 c1                	mov    %eax,%ecx
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
	int r;
	if ((r = fd2sockid(s)) < 0)
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  810ea6:	85 c0                	test   %eax,%eax
  810ea8:	78 07                	js     810eb1 <accept+0x37>
		return r;
	return alloc_sockfd(r);
  810eaa:	e8 5c ff ff ff       	call   810e0b <alloc_sockfd>
  810eaf:	89 c1                	mov    %eax,%ecx
}
  810eb1:	89 c8                	mov    %ecx,%eax
  810eb3:	c9                   	leave  
  810eb4:	c3                   	ret    

00810eb5 <bind>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  810eb5:	55                   	push   %ebp
  810eb6:	89 e5                	mov    %esp,%ebp
  810eb8:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810ebb:	8b 45 08             	mov    0x8(%ebp),%eax
  810ebe:	e8 16 ff ff ff       	call   810dd9 <fd2sockid>
  810ec3:	89 c2                	mov    %eax,%edx
  810ec5:	85 d2                	test   %edx,%edx
  810ec7:	78 16                	js     810edf <bind+0x2a>
		return r;
	return nsipc_bind(r, name, namelen);
  810ec9:	8b 45 10             	mov    0x10(%ebp),%eax
  810ecc:	89 44 24 08          	mov    %eax,0x8(%esp)
  810ed0:	8b 45 0c             	mov    0xc(%ebp),%eax
  810ed3:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ed7:	89 14 24             	mov    %edx,(%esp)
  810eda:	e8 60 01 00 00       	call   81103f <nsipc_bind>
}
  810edf:	c9                   	leave  
  810ee0:	c3                   	ret    

00810ee1 <shutdown>:

int
shutdown(int s, int how)
{
  810ee1:	55                   	push   %ebp
  810ee2:	89 e5                	mov    %esp,%ebp
  810ee4:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810ee7:	8b 45 08             	mov    0x8(%ebp),%eax
  810eea:	e8 ea fe ff ff       	call   810dd9 <fd2sockid>
  810eef:	89 c2                	mov    %eax,%edx
  810ef1:	85 d2                	test   %edx,%edx
  810ef3:	78 0f                	js     810f04 <shutdown+0x23>
		return r;
	return nsipc_shutdown(r, how);
  810ef5:	8b 45 0c             	mov    0xc(%ebp),%eax
  810ef8:	89 44 24 04          	mov    %eax,0x4(%esp)
  810efc:	89 14 24             	mov    %edx,(%esp)
  810eff:	e8 7a 01 00 00       	call   81107e <nsipc_shutdown>
}
  810f04:	c9                   	leave  
  810f05:	c3                   	ret    

00810f06 <connect>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  810f06:	55                   	push   %ebp
  810f07:	89 e5                	mov    %esp,%ebp
  810f09:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810f0c:	8b 45 08             	mov    0x8(%ebp),%eax
  810f0f:	e8 c5 fe ff ff       	call   810dd9 <fd2sockid>
  810f14:	89 c2                	mov    %eax,%edx
  810f16:	85 d2                	test   %edx,%edx
  810f18:	78 16                	js     810f30 <connect+0x2a>
		return r;
	return nsipc_connect(r, name, namelen);
  810f1a:	8b 45 10             	mov    0x10(%ebp),%eax
  810f1d:	89 44 24 08          	mov    %eax,0x8(%esp)
  810f21:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f24:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f28:	89 14 24             	mov    %edx,(%esp)
  810f2b:	e8 8a 01 00 00       	call   8110ba <nsipc_connect>
}
  810f30:	c9                   	leave  
  810f31:	c3                   	ret    

00810f32 <listen>:

int
listen(int s, int backlog)
{
  810f32:	55                   	push   %ebp
  810f33:	89 e5                	mov    %esp,%ebp
  810f35:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  810f38:	8b 45 08             	mov    0x8(%ebp),%eax
  810f3b:	e8 99 fe ff ff       	call   810dd9 <fd2sockid>
  810f40:	89 c2                	mov    %eax,%edx
  810f42:	85 d2                	test   %edx,%edx
  810f44:	78 0f                	js     810f55 <listen+0x23>
		return r;
	return nsipc_listen(r, backlog);
  810f46:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f49:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f4d:	89 14 24             	mov    %edx,(%esp)
  810f50:	e8 a4 01 00 00       	call   8110f9 <nsipc_listen>
}
  810f55:	c9                   	leave  
  810f56:	c3                   	ret    

00810f57 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  810f57:	55                   	push   %ebp
  810f58:	89 e5                	mov    %esp,%ebp
  810f5a:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  810f5d:	8b 45 10             	mov    0x10(%ebp),%eax
  810f60:	89 44 24 08          	mov    %eax,0x8(%esp)
  810f64:	8b 45 0c             	mov    0xc(%ebp),%eax
  810f67:	89 44 24 04          	mov    %eax,0x4(%esp)
  810f6b:	8b 45 08             	mov    0x8(%ebp),%eax
  810f6e:	89 04 24             	mov    %eax,(%esp)
  810f71:	e8 98 02 00 00       	call   81120e <nsipc_socket>
  810f76:	89 c2                	mov    %eax,%edx
  810f78:	85 d2                	test   %edx,%edx
  810f7a:	78 05                	js     810f81 <socket+0x2a>
		return r;
	return alloc_sockfd(r);
  810f7c:	e8 8a fe ff ff       	call   810e0b <alloc_sockfd>
}
  810f81:	c9                   	leave  
  810f82:	c3                   	ret    

00810f83 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  810f83:	55                   	push   %ebp
  810f84:	89 e5                	mov    %esp,%ebp
  810f86:	53                   	push   %ebx
  810f87:	83 ec 14             	sub    $0x14,%esp
  810f8a:	89 c3                	mov    %eax,%ebx
	static envid_t nsenv;
	if (nsenv == 0)
  810f8c:	83 3d f0 c1 b3 00 00 	cmpl   $0x0,0xb3c1f0
  810f93:	75 11                	jne    810fa6 <nsipc+0x23>
		nsenv = ipc_find_env(ENV_TYPE_NS);
  810f95:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  810f9c:	e8 74 f4 ff ff       	call   810415 <ipc_find_env>
  810fa1:	a3 f0 c1 b3 00       	mov    %eax,0xb3c1f0
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  810fa6:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810fad:	00 
  810fae:	c7 44 24 08 00 e0 b3 	movl   $0xb3e000,0x8(%esp)
  810fb5:	00 
  810fb6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810fba:	a1 f0 c1 b3 00       	mov    0xb3c1f0,%eax
  810fbf:	89 04 24             	mov    %eax,(%esp)
  810fc2:	e8 c1 f3 ff ff       	call   810388 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  810fc7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810fce:	00 
  810fcf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810fd6:	00 
  810fd7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810fde:	e8 3d f3 ff ff       	call   810320 <ipc_recv>
}
  810fe3:	83 c4 14             	add    $0x14,%esp
  810fe6:	5b                   	pop    %ebx
  810fe7:	5d                   	pop    %ebp
  810fe8:	c3                   	ret    

00810fe9 <nsipc_accept>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  810fe9:	55                   	push   %ebp
  810fea:	89 e5                	mov    %esp,%ebp
  810fec:	56                   	push   %esi
  810fed:	53                   	push   %ebx
  810fee:	83 ec 10             	sub    $0x10,%esp
  810ff1:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.accept.req_s = s;
  810ff4:	8b 45 08             	mov    0x8(%ebp),%eax
  810ff7:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.accept.req_addrlen = *addrlen;
  810ffc:	8b 06                	mov    (%esi),%eax
  810ffe:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  811003:	b8 01 00 00 00       	mov    $0x1,%eax
  811008:	e8 76 ff ff ff       	call   810f83 <nsipc>
  81100d:	89 c3                	mov    %eax,%ebx
  81100f:	85 c0                	test   %eax,%eax
  811011:	78 23                	js     811036 <nsipc_accept+0x4d>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  811013:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  811018:	89 44 24 08          	mov    %eax,0x8(%esp)
  81101c:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  811023:	00 
  811024:	8b 45 0c             	mov    0xc(%ebp),%eax
  811027:	89 04 24             	mov    %eax,(%esp)
  81102a:	e8 25 e9 ff ff       	call   80f954 <memmove>
		*addrlen = ret->ret_addrlen;
  81102f:	a1 10 e0 b3 00       	mov    0xb3e010,%eax
  811034:	89 06                	mov    %eax,(%esi)
	}
	return r;
}
  811036:	89 d8                	mov    %ebx,%eax
  811038:	83 c4 10             	add    $0x10,%esp
  81103b:	5b                   	pop    %ebx
  81103c:	5e                   	pop    %esi
  81103d:	5d                   	pop    %ebp
  81103e:	c3                   	ret    

0081103f <nsipc_bind>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  81103f:	55                   	push   %ebp
  811040:	89 e5                	mov    %esp,%ebp
  811042:	53                   	push   %ebx
  811043:	83 ec 14             	sub    $0x14,%esp
  811046:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  811049:	8b 45 08             	mov    0x8(%ebp),%eax
  81104c:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  811051:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  811055:	8b 45 0c             	mov    0xc(%ebp),%eax
  811058:	89 44 24 04          	mov    %eax,0x4(%esp)
  81105c:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  811063:	e8 ec e8 ff ff       	call   80f954 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  811068:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_BIND);
  81106e:	b8 02 00 00 00       	mov    $0x2,%eax
  811073:	e8 0b ff ff ff       	call   810f83 <nsipc>
}
  811078:	83 c4 14             	add    $0x14,%esp
  81107b:	5b                   	pop    %ebx
  81107c:	5d                   	pop    %ebp
  81107d:	c3                   	ret    

0081107e <nsipc_shutdown>:

int
nsipc_shutdown(int s, int how)
{
  81107e:	55                   	push   %ebp
  81107f:	89 e5                	mov    %esp,%ebp
  811081:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  811084:	8b 45 08             	mov    0x8(%ebp),%eax
  811087:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.shutdown.req_how = how;
  81108c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81108f:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_SHUTDOWN);
  811094:	b8 03 00 00 00       	mov    $0x3,%eax
  811099:	e8 e5 fe ff ff       	call   810f83 <nsipc>
}
  81109e:	c9                   	leave  
  81109f:	c3                   	ret    

008110a0 <nsipc_close>:

int
nsipc_close(int s)
{
  8110a0:	55                   	push   %ebp
  8110a1:	89 e5                	mov    %esp,%ebp
  8110a3:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  8110a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8110a9:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	return nsipc(NSREQ_CLOSE);
  8110ae:	b8 04 00 00 00       	mov    $0x4,%eax
  8110b3:	e8 cb fe ff ff       	call   810f83 <nsipc>
}
  8110b8:	c9                   	leave  
  8110b9:	c3                   	ret    

008110ba <nsipc_connect>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8110ba:	55                   	push   %ebp
  8110bb:	89 e5                	mov    %esp,%ebp
  8110bd:	53                   	push   %ebx
  8110be:	83 ec 14             	sub    $0x14,%esp
  8110c1:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  8110c4:	8b 45 08             	mov    0x8(%ebp),%eax
  8110c7:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  8110cc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8110d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8110d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8110d7:	c7 04 24 04 e0 b3 00 	movl   $0xb3e004,(%esp)
  8110de:	e8 71 e8 ff ff       	call   80f954 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  8110e3:	89 1d 14 e0 b3 00    	mov    %ebx,0xb3e014
	return nsipc(NSREQ_CONNECT);
  8110e9:	b8 05 00 00 00       	mov    $0x5,%eax
  8110ee:	e8 90 fe ff ff       	call   810f83 <nsipc>
}
  8110f3:	83 c4 14             	add    $0x14,%esp
  8110f6:	5b                   	pop    %ebx
  8110f7:	5d                   	pop    %ebp
  8110f8:	c3                   	ret    

008110f9 <nsipc_listen>:

int
nsipc_listen(int s, int backlog)
{
  8110f9:	55                   	push   %ebp
  8110fa:	89 e5                	mov    %esp,%ebp
  8110fc:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  8110ff:	8b 45 08             	mov    0x8(%ebp),%eax
  811102:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.listen.req_backlog = backlog;
  811107:	8b 45 0c             	mov    0xc(%ebp),%eax
  81110a:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	return nsipc(NSREQ_LISTEN);
  81110f:	b8 06 00 00 00       	mov    $0x6,%eax
  811114:	e8 6a fe ff ff       	call   810f83 <nsipc>
}
  811119:	c9                   	leave  
  81111a:	c3                   	ret    

0081111b <nsipc_recv>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  81111b:	55                   	push   %ebp
  81111c:	89 e5                	mov    %esp,%ebp
  81111e:	56                   	push   %esi
  81111f:	53                   	push   %ebx
  811120:	83 ec 10             	sub    $0x10,%esp
  811123:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  811126:	8b 45 08             	mov    0x8(%ebp),%eax
  811129:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.recv.req_len = len;
  81112e:	89 35 04 e0 b3 00    	mov    %esi,0xb3e004
	nsipcbuf.recv.req_flags = flags;
  811134:	8b 45 14             	mov    0x14(%ebp),%eax
  811137:	a3 08 e0 b3 00       	mov    %eax,0xb3e008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  81113c:	b8 07 00 00 00       	mov    $0x7,%eax
  811141:	e8 3d fe ff ff       	call   810f83 <nsipc>
  811146:	89 c3                	mov    %eax,%ebx
  811148:	85 c0                	test   %eax,%eax
  81114a:	78 46                	js     811192 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  81114c:	39 f0                	cmp    %esi,%eax
  81114e:	7f 07                	jg     811157 <nsipc_recv+0x3c>
  811150:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  811155:	7e 24                	jle    81117b <nsipc_recv+0x60>
  811157:	c7 44 24 0c f6 48 81 	movl   $0x8148f6,0xc(%esp)
  81115e:	00 
  81115f:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  811166:	00 
  811167:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  81116e:	00 
  81116f:	c7 04 24 0b 49 81 00 	movl   $0x81490b,(%esp)
  811176:	e8 1f df ff ff       	call   80f09a <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  81117b:	89 44 24 08          	mov    %eax,0x8(%esp)
  81117f:	c7 44 24 04 00 e0 b3 	movl   $0xb3e000,0x4(%esp)
  811186:	00 
  811187:	8b 45 0c             	mov    0xc(%ebp),%eax
  81118a:	89 04 24             	mov    %eax,(%esp)
  81118d:	e8 c2 e7 ff ff       	call   80f954 <memmove>
	}

	return r;
}
  811192:	89 d8                	mov    %ebx,%eax
  811194:	83 c4 10             	add    $0x10,%esp
  811197:	5b                   	pop    %ebx
  811198:	5e                   	pop    %esi
  811199:	5d                   	pop    %ebp
  81119a:	c3                   	ret    

0081119b <nsipc_send>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  81119b:	55                   	push   %ebp
  81119c:	89 e5                	mov    %esp,%ebp
  81119e:	53                   	push   %ebx
  81119f:	83 ec 14             	sub    $0x14,%esp
  8111a2:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  8111a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8111a8:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	assert(size < 1600);
  8111ad:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  8111b3:	7e 24                	jle    8111d9 <nsipc_send+0x3e>
  8111b5:	c7 44 24 0c 17 49 81 	movl   $0x814917,0xc(%esp)
  8111bc:	00 
  8111bd:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  8111c4:	00 
  8111c5:	c7 44 24 04 6d 00 00 	movl   $0x6d,0x4(%esp)
  8111cc:	00 
  8111cd:	c7 04 24 0b 49 81 00 	movl   $0x81490b,(%esp)
  8111d4:	e8 c1 de ff ff       	call   80f09a <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  8111d9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8111dd:	8b 45 0c             	mov    0xc(%ebp),%eax
  8111e0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8111e4:	c7 04 24 0c e0 b3 00 	movl   $0xb3e00c,(%esp)
  8111eb:	e8 64 e7 ff ff       	call   80f954 <memmove>
	nsipcbuf.send.req_size = size;
  8111f0:	89 1d 04 e0 b3 00    	mov    %ebx,0xb3e004
	nsipcbuf.send.req_flags = flags;
  8111f6:	8b 45 14             	mov    0x14(%ebp),%eax
  8111f9:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SEND);
  8111fe:	b8 08 00 00 00       	mov    $0x8,%eax
  811203:	e8 7b fd ff ff       	call   810f83 <nsipc>
}
  811208:	83 c4 14             	add    $0x14,%esp
  81120b:	5b                   	pop    %ebx
  81120c:	5d                   	pop    %ebp
  81120d:	c3                   	ret    

0081120e <nsipc_socket>:

int
nsipc_socket(int domain, int type, int protocol)
{
  81120e:	55                   	push   %ebp
  81120f:	89 e5                	mov    %esp,%ebp
  811211:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  811214:	8b 45 08             	mov    0x8(%ebp),%eax
  811217:	a3 00 e0 b3 00       	mov    %eax,0xb3e000
	nsipcbuf.socket.req_type = type;
  81121c:	8b 45 0c             	mov    0xc(%ebp),%eax
  81121f:	a3 04 e0 b3 00       	mov    %eax,0xb3e004
	nsipcbuf.socket.req_protocol = protocol;
  811224:	8b 45 10             	mov    0x10(%ebp),%eax
  811227:	a3 08 e0 b3 00       	mov    %eax,0xb3e008
	return nsipc(NSREQ_SOCKET);
  81122c:	b8 09 00 00 00       	mov    $0x9,%eax
  811231:	e8 4d fd ff ff       	call   810f83 <nsipc>
}
  811236:	c9                   	leave  
  811237:	c3                   	ret    
  811238:	66 90                	xchg   %ax,%ax
  81123a:	66 90                	xchg   %ax,%ax
  81123c:	66 90                	xchg   %ax,%ax
  81123e:	66 90                	xchg   %ax,%ax

00811240 <free>:
	return v;
}

void
free(void *v)
{
  811240:	55                   	push   %ebp
  811241:	89 e5                	mov    %esp,%ebp
  811243:	53                   	push   %ebx
  811244:	83 ec 14             	sub    $0x14,%esp
  811247:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  81124a:	85 db                	test   %ebx,%ebx
  81124c:	0f 84 ba 00 00 00    	je     81130c <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  811252:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  811258:	76 08                	jbe    811262 <free+0x22>
  81125a:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  811260:	76 24                	jbe    811286 <free+0x46>
  811262:	c7 44 24 0c 24 49 81 	movl   $0x814924,0xc(%esp)
  811269:	00 
  81126a:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  811271:	00 
  811272:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  811279:	00 
  81127a:	c7 04 24 52 49 81 00 	movl   $0x814952,(%esp)
  811281:	e8 14 de ff ff       	call   80f09a <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  811286:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  81128c:	eb 4a                	jmp    8112d8 <free+0x98>
		sys_page_unmap(0, c);
  81128e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811292:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811299:	e8 dc e9 ff ff       	call   80fc7a <sys_page_unmap>
		c += PGSIZE;
  81129e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  8112a4:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  8112aa:	76 08                	jbe    8112b4 <free+0x74>
  8112ac:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  8112b2:	76 24                	jbe    8112d8 <free+0x98>
  8112b4:	c7 44 24 0c 5f 49 81 	movl   $0x81495f,0xc(%esp)
  8112bb:	00 
  8112bc:	c7 44 24 08 df 35 81 	movl   $0x8135df,0x8(%esp)
  8112c3:	00 
  8112c4:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  8112cb:	00 
  8112cc:	c7 04 24 52 49 81 00 	movl   $0x814952,(%esp)
  8112d3:	e8 c2 dd ff ff       	call   80f09a <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (uvpt[PGNUM(c)] & PTE_CONTINUED) {
  8112d8:	89 d8                	mov    %ebx,%eax
  8112da:	c1 e8 0c             	shr    $0xc,%eax
  8112dd:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
  8112e4:	f6 c4 02             	test   $0x2,%ah
  8112e7:	75 a5                	jne    81128e <free+0x4e>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  8112e9:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  8112ef:	83 e8 01             	sub    $0x1,%eax
  8112f2:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  8112f8:	85 c0                	test   %eax,%eax
  8112fa:	75 10                	jne    81130c <free+0xcc>
		sys_page_unmap(0, c);
  8112fc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811300:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811307:	e8 6e e9 ff ff       	call   80fc7a <sys_page_unmap>
}
  81130c:	83 c4 14             	add    $0x14,%esp
  81130f:	5b                   	pop    %ebx
  811310:	5d                   	pop    %ebp
  811311:	c3                   	ret    

00811312 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  811312:	55                   	push   %ebp
  811313:	89 e5                	mov    %esp,%ebp
  811315:	57                   	push   %edi
  811316:	56                   	push   %esi
  811317:	53                   	push   %ebx
  811318:	83 ec 2c             	sub    $0x2c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  81131b:	83 3d f4 c1 b3 00 00 	cmpl   $0x0,0xb3c1f4
  811322:	75 0a                	jne    81132e <malloc+0x1c>
		mptr = mbegin;
  811324:	c7 05 f4 c1 b3 00 00 	movl   $0x8000000,0xb3c1f4
  81132b:	00 00 08 

	n = ROUNDUP(n, 4);
  81132e:	8b 45 08             	mov    0x8(%ebp),%eax
  811331:	83 c0 03             	add    $0x3,%eax
  811334:	83 e0 fc             	and    $0xfffffffc,%eax
  811337:	89 45 e0             	mov    %eax,-0x20(%ebp)

	if (n >= MAXMALLOC)
  81133a:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  81133f:	0f 87 64 01 00 00    	ja     8114a9 <malloc+0x197>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  811345:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  81134a:	a9 ff 0f 00 00       	test   $0xfff,%eax
  81134f:	75 15                	jne    811366 <malloc+0x54>
  811351:	8b 35 f4 c1 b3 00    	mov    0xb3c1f4,%esi
	return 1;
}

void*
malloc(size_t n)
{
  811357:	c7 45 dc 02 00 00 00 	movl   $0x2,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  81135e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  811361:	8d 78 04             	lea    0x4(%eax),%edi
  811364:	eb 50                	jmp    8113b6 <malloc+0xa4>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  811366:	89 c1                	mov    %eax,%ecx
  811368:	c1 e9 0c             	shr    $0xc,%ecx
  81136b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  81136e:	8d 54 18 03          	lea    0x3(%eax,%ebx,1),%edx
  811372:	c1 ea 0c             	shr    $0xc,%edx
  811375:	39 d1                	cmp    %edx,%ecx
  811377:	75 1f                	jne    811398 <malloc+0x86>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  811379:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  81137f:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  811385:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  811389:	89 da                	mov    %ebx,%edx
  81138b:	01 c2                	add    %eax,%edx
  81138d:	89 15 f4 c1 b3 00    	mov    %edx,0xb3c1f4
			return v;
  811393:	e9 2f 01 00 00       	jmp    8114c7 <malloc+0x1b5>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  811398:	89 04 24             	mov    %eax,(%esp)
  81139b:	e8 a0 fe ff ff       	call   811240 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8113a0:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
  8113a5:	05 00 10 00 00       	add    $0x1000,%eax
  8113aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  8113af:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
  8113b4:	eb 9b                	jmp    811351 <malloc+0x3f>
  8113b6:	89 75 e4             	mov    %esi,-0x1c(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  8113b9:	89 fb                	mov    %edi,%ebx
  8113bb:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8113be:	89 f0                	mov    %esi,%eax
  8113c0:	eb 36                	jmp    8113f8 <malloc+0xe6>
		if (va >= (uintptr_t) mend
  8113c2:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  8113c7:	0f 87 e3 00 00 00    	ja     8114b0 <malloc+0x19e>
		    || ((uvpd[PDX(va)] & PTE_P) && (uvpt[PGNUM(va)] & PTE_P)))
  8113cd:	89 c2                	mov    %eax,%edx
  8113cf:	c1 ea 16             	shr    $0x16,%edx
  8113d2:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  8113d9:	f6 c2 01             	test   $0x1,%dl
  8113dc:	74 15                	je     8113f3 <malloc+0xe1>
  8113de:	89 c2                	mov    %eax,%edx
  8113e0:	c1 ea 0c             	shr    $0xc,%edx
  8113e3:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8113ea:	f6 c2 01             	test   $0x1,%dl
  8113ed:	0f 85 bd 00 00 00    	jne    8114b0 <malloc+0x19e>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  8113f3:	05 00 10 00 00       	add    $0x1000,%eax
  8113f8:	39 c1                	cmp    %eax,%ecx
  8113fa:	77 c6                	ja     8113c2 <malloc+0xb0>
  8113fc:	eb 7e                	jmp    81147c <malloc+0x16a>
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
			if (++nwrap == 2)
  8113fe:	83 6d dc 01          	subl   $0x1,-0x24(%ebp)
  811402:	74 07                	je     81140b <malloc+0xf9>
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  811404:	be 00 00 00 08       	mov    $0x8000000,%esi
  811409:	eb ab                	jmp    8113b6 <malloc+0xa4>
  81140b:	c7 05 f4 c1 b3 00 00 	movl   $0x8000000,0xb3c1f4
  811412:	00 00 08 
			if (++nwrap == 2)
				return 0;	/* out of address space */
  811415:	b8 00 00 00 00       	mov    $0x0,%eax
  81141a:	e9 a8 00 00 00       	jmp    8114c7 <malloc+0x1b5>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  81141f:	8d be 00 10 00 00    	lea    0x1000(%esi),%edi
  811425:	39 df                	cmp    %ebx,%edi
  811427:	19 c0                	sbb    %eax,%eax
  811429:	25 00 02 00 00       	and    $0x200,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  81142e:	83 c8 07             	or     $0x7,%eax
  811431:	89 44 24 08          	mov    %eax,0x8(%esp)
  811435:	03 15 f4 c1 b3 00    	add    0xb3c1f4,%edx
  81143b:	89 54 24 04          	mov    %edx,0x4(%esp)
  81143f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811446:	e8 88 e7 ff ff       	call   80fbd3 <sys_page_alloc>
  81144b:	85 c0                	test   %eax,%eax
  81144d:	78 22                	js     811471 <malloc+0x15f>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  81144f:	89 fe                	mov    %edi,%esi
  811451:	eb 36                	jmp    811489 <malloc+0x177>
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  811453:	89 f0                	mov    %esi,%eax
  811455:	03 05 f4 c1 b3 00    	add    0xb3c1f4,%eax
  81145b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81145f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811466:	e8 0f e8 ff ff       	call   80fc7a <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  81146b:	81 ee 00 10 00 00    	sub    $0x1000,%esi
  811471:	85 f6                	test   %esi,%esi
  811473:	79 de                	jns    811453 <malloc+0x141>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
  811475:	b8 00 00 00 00       	mov    $0x0,%eax
  81147a:	eb 4b                	jmp    8114c7 <malloc+0x1b5>
  81147c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81147f:	a3 f4 c1 b3 00       	mov    %eax,0xb3c1f4
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  811484:	be 00 00 00 00       	mov    $0x0,%esi
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  811489:	89 f2                	mov    %esi,%edx
  81148b:	39 de                	cmp    %ebx,%esi
  81148d:	72 90                	jb     81141f <malloc+0x10d>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  81148f:	a1 f4 c1 b3 00       	mov    0xb3c1f4,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  811494:	c7 44 30 fc 02 00 00 	movl   $0x2,-0x4(%eax,%esi,1)
  81149b:	00 
	v = mptr;
	mptr += n;
  81149c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  81149f:	01 c2                	add    %eax,%edx
  8114a1:	89 15 f4 c1 b3 00    	mov    %edx,0xb3c1f4
	return v;
  8114a7:	eb 1e                	jmp    8114c7 <malloc+0x1b5>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  8114a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8114ae:	eb 17                	jmp    8114c7 <malloc+0x1b5>
  8114b0:	81 c6 00 10 00 00    	add    $0x1000,%esi
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  8114b6:	81 fe 00 00 00 10    	cmp    $0x10000000,%esi
  8114bc:	0f 84 3c ff ff ff    	je     8113fe <malloc+0xec>
  8114c2:	e9 ef fe ff ff       	jmp    8113b6 <malloc+0xa4>
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  8114c7:	83 c4 2c             	add    $0x2c,%esp
  8114ca:	5b                   	pop    %ebx
  8114cb:	5e                   	pop    %esi
  8114cc:	5f                   	pop    %edi
  8114cd:	5d                   	pop    %ebp
  8114ce:	c3                   	ret    

008114cf <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  8114cf:	55                   	push   %ebp
  8114d0:	89 e5                	mov    %esp,%ebp
  8114d2:	56                   	push   %esi
  8114d3:	53                   	push   %ebx
  8114d4:	83 ec 10             	sub    $0x10,%esp
  8114d7:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  8114da:	8b 45 08             	mov    0x8(%ebp),%eax
  8114dd:	89 04 24             	mov    %eax,(%esp)
  8114e0:	e8 7b ef ff ff       	call   810460 <fd2data>
  8114e5:	89 c6                	mov    %eax,%esi
	strcpy(stat->st_name, "<pipe>");
  8114e7:	c7 44 24 04 77 49 81 	movl   $0x814977,0x4(%esp)
  8114ee:	00 
  8114ef:	89 1c 24             	mov    %ebx,(%esp)
  8114f2:	e8 c0 e2 ff ff       	call   80f7b7 <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  8114f7:	8b 46 04             	mov    0x4(%esi),%eax
  8114fa:	2b 06                	sub    (%esi),%eax
  8114fc:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	stat->st_isdir = 0;
  811502:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  811509:	00 00 00 
	stat->st_dev = &devpipe;
  81150c:	c7 83 88 00 00 00 24 	movl   $0x815324,0x88(%ebx)
  811513:	53 81 00 
	return 0;
}
  811516:	b8 00 00 00 00       	mov    $0x0,%eax
  81151b:	83 c4 10             	add    $0x10,%esp
  81151e:	5b                   	pop    %ebx
  81151f:	5e                   	pop    %esi
  811520:	5d                   	pop    %ebp
  811521:	c3                   	ret    

00811522 <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  811522:	55                   	push   %ebp
  811523:	89 e5                	mov    %esp,%ebp
  811525:	53                   	push   %ebx
  811526:	83 ec 14             	sub    $0x14,%esp
  811529:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  81152c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811530:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811537:	e8 3e e7 ff ff       	call   80fc7a <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  81153c:	89 1c 24             	mov    %ebx,(%esp)
  81153f:	e8 1c ef ff ff       	call   810460 <fd2data>
  811544:	89 44 24 04          	mov    %eax,0x4(%esp)
  811548:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81154f:	e8 26 e7 ff ff       	call   80fc7a <sys_page_unmap>
}
  811554:	83 c4 14             	add    $0x14,%esp
  811557:	5b                   	pop    %ebx
  811558:	5d                   	pop    %ebp
  811559:	c3                   	ret    

0081155a <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  81155a:	55                   	push   %ebp
  81155b:	89 e5                	mov    %esp,%ebp
  81155d:	57                   	push   %edi
  81155e:	56                   	push   %esi
  81155f:	53                   	push   %ebx
  811560:	83 ec 2c             	sub    $0x2c,%esp
  811563:	89 c6                	mov    %eax,%esi
  811565:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = thisenv->env_runs;
  811568:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  81156d:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  811570:	89 34 24             	mov    %esi,(%esp)
  811573:	e8 33 05 00 00       	call   811aab <pageref>
  811578:	89 c7                	mov    %eax,%edi
  81157a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81157d:	89 04 24             	mov    %eax,(%esp)
  811580:	e8 26 05 00 00       	call   811aab <pageref>
  811585:	39 c7                	cmp    %eax,%edi
  811587:	0f 94 c2             	sete   %dl
  81158a:	0f b6 c2             	movzbl %dl,%eax
		nn = thisenv->env_runs;
  81158d:	8b 0d 7c c2 b3 00    	mov    0xb3c27c,%ecx
  811593:	8b 79 58             	mov    0x58(%ecx),%edi
		if (n == nn)
  811596:	39 fb                	cmp    %edi,%ebx
  811598:	74 21                	je     8115bb <_pipeisclosed+0x61>
			return ret;
		if (n != nn && ret == 1)
  81159a:	84 d2                	test   %dl,%dl
  81159c:	74 ca                	je     811568 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, thisenv->env_runs, ret);
  81159e:	8b 51 58             	mov    0x58(%ecx),%edx
  8115a1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8115a5:	89 54 24 08          	mov    %edx,0x8(%esp)
  8115a9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8115ad:	c7 04 24 7e 49 81 00 	movl   $0x81497e,(%esp)
  8115b4:	e8 da db ff ff       	call   80f193 <cprintf>
  8115b9:	eb ad                	jmp    811568 <_pipeisclosed+0xe>
	}
}
  8115bb:	83 c4 2c             	add    $0x2c,%esp
  8115be:	5b                   	pop    %ebx
  8115bf:	5e                   	pop    %esi
  8115c0:	5f                   	pop    %edi
  8115c1:	5d                   	pop    %ebp
  8115c2:	c3                   	ret    

008115c3 <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  8115c3:	55                   	push   %ebp
  8115c4:	89 e5                	mov    %esp,%ebp
  8115c6:	57                   	push   %edi
  8115c7:	56                   	push   %esi
  8115c8:	53                   	push   %ebx
  8115c9:	83 ec 1c             	sub    $0x1c,%esp
  8115cc:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  8115cf:	89 34 24             	mov    %esi,(%esp)
  8115d2:	e8 89 ee ff ff       	call   810460 <fd2data>
  8115d7:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8115d9:	bf 00 00 00 00       	mov    $0x0,%edi
  8115de:	eb 45                	jmp    811625 <devpipe_write+0x62>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  8115e0:	89 da                	mov    %ebx,%edx
  8115e2:	89 f0                	mov    %esi,%eax
  8115e4:	e8 71 ff ff ff       	call   81155a <_pipeisclosed>
  8115e9:	85 c0                	test   %eax,%eax
  8115eb:	75 41                	jne    81162e <devpipe_write+0x6b>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  8115ed:	e8 c2 e5 ff ff       	call   80fbb4 <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  8115f2:	8b 43 04             	mov    0x4(%ebx),%eax
  8115f5:	8b 0b                	mov    (%ebx),%ecx
  8115f7:	8d 51 20             	lea    0x20(%ecx),%edx
  8115fa:	39 d0                	cmp    %edx,%eax
  8115fc:	73 e2                	jae    8115e0 <devpipe_write+0x1d>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  8115fe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  811601:	0f b6 0c 39          	movzbl (%ecx,%edi,1),%ecx
  811605:	88 4d e7             	mov    %cl,-0x19(%ebp)
  811608:	99                   	cltd   
  811609:	c1 ea 1b             	shr    $0x1b,%edx
  81160c:	8d 0c 10             	lea    (%eax,%edx,1),%ecx
  81160f:	83 e1 1f             	and    $0x1f,%ecx
  811612:	29 d1                	sub    %edx,%ecx
  811614:	0f b6 55 e7          	movzbl -0x19(%ebp),%edx
  811618:	88 54 0b 08          	mov    %dl,0x8(%ebx,%ecx,1)
		p->p_wpos++;
  81161c:	83 c0 01             	add    $0x1,%eax
  81161f:	89 43 04             	mov    %eax,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811622:	83 c7 01             	add    $0x1,%edi
  811625:	3b 7d 10             	cmp    0x10(%ebp),%edi
  811628:	75 c8                	jne    8115f2 <devpipe_write+0x2f>
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
  81162a:	89 f8                	mov    %edi,%eax
  81162c:	eb 05                	jmp    811633 <devpipe_write+0x70>
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81162e:	b8 00 00 00 00       	mov    $0x0,%eax
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}

	return i;
}
  811633:	83 c4 1c             	add    $0x1c,%esp
  811636:	5b                   	pop    %ebx
  811637:	5e                   	pop    %esi
  811638:	5f                   	pop    %edi
  811639:	5d                   	pop    %ebp
  81163a:	c3                   	ret    

0081163b <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  81163b:	55                   	push   %ebp
  81163c:	89 e5                	mov    %esp,%ebp
  81163e:	57                   	push   %edi
  81163f:	56                   	push   %esi
  811640:	53                   	push   %ebx
  811641:	83 ec 1c             	sub    $0x1c,%esp
  811644:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  811647:	89 3c 24             	mov    %edi,(%esp)
  81164a:	e8 11 ee ff ff       	call   810460 <fd2data>
  81164f:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811651:	be 00 00 00 00       	mov    $0x0,%esi
  811656:	eb 3d                	jmp    811695 <devpipe_read+0x5a>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  811658:	85 f6                	test   %esi,%esi
  81165a:	74 04                	je     811660 <devpipe_read+0x25>
				return i;
  81165c:	89 f0                	mov    %esi,%eax
  81165e:	eb 43                	jmp    8116a3 <devpipe_read+0x68>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  811660:	89 da                	mov    %ebx,%edx
  811662:	89 f8                	mov    %edi,%eax
  811664:	e8 f1 fe ff ff       	call   81155a <_pipeisclosed>
  811669:	85 c0                	test   %eax,%eax
  81166b:	75 31                	jne    81169e <devpipe_read+0x63>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  81166d:	e8 42 e5 ff ff       	call   80fbb4 <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  811672:	8b 03                	mov    (%ebx),%eax
  811674:	3b 43 04             	cmp    0x4(%ebx),%eax
  811677:	74 df                	je     811658 <devpipe_read+0x1d>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  811679:	99                   	cltd   
  81167a:	c1 ea 1b             	shr    $0x1b,%edx
  81167d:	01 d0                	add    %edx,%eax
  81167f:	83 e0 1f             	and    $0x1f,%eax
  811682:	29 d0                	sub    %edx,%eax
  811684:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  811689:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  81168c:	88 04 31             	mov    %al,(%ecx,%esi,1)
		p->p_rpos++;
  81168f:	83 03 01             	addl   $0x1,(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			thisenv->env_id, uvpt[PGNUM(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  811692:	83 c6 01             	add    $0x1,%esi
  811695:	3b 75 10             	cmp    0x10(%ebp),%esi
  811698:	75 d8                	jne    811672 <devpipe_read+0x37>
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  81169a:	89 f0                	mov    %esi,%eax
  81169c:	eb 05                	jmp    8116a3 <devpipe_read+0x68>
			// if we got any data, return it
			if (i > 0)
				return i;
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
				return 0;
  81169e:	b8 00 00 00 00       	mov    $0x0,%eax
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
}
  8116a3:	83 c4 1c             	add    $0x1c,%esp
  8116a6:	5b                   	pop    %ebx
  8116a7:	5e                   	pop    %esi
  8116a8:	5f                   	pop    %edi
  8116a9:	5d                   	pop    %ebp
  8116aa:	c3                   	ret    

008116ab <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  8116ab:	55                   	push   %ebp
  8116ac:	89 e5                	mov    %esp,%ebp
  8116ae:	56                   	push   %esi
  8116af:	53                   	push   %ebx
  8116b0:	83 ec 30             	sub    $0x30,%esp
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  8116b3:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8116b6:	89 04 24             	mov    %eax,(%esp)
  8116b9:	e8 b9 ed ff ff       	call   810477 <fd_alloc>
  8116be:	89 c2                	mov    %eax,%edx
  8116c0:	85 d2                	test   %edx,%edx
  8116c2:	0f 88 4d 01 00 00    	js     811815 <pipe+0x16a>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8116c8:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8116cf:	00 
  8116d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8116d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8116d7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8116de:	e8 f0 e4 ff ff       	call   80fbd3 <sys_page_alloc>
  8116e3:	89 c2                	mov    %eax,%edx
  8116e5:	85 d2                	test   %edx,%edx
  8116e7:	0f 88 28 01 00 00    	js     811815 <pipe+0x16a>
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8116ed:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8116f0:	89 04 24             	mov    %eax,(%esp)
  8116f3:	e8 7f ed ff ff       	call   810477 <fd_alloc>
  8116f8:	89 c3                	mov    %eax,%ebx
  8116fa:	85 c0                	test   %eax,%eax
  8116fc:	0f 88 fe 00 00 00    	js     811800 <pipe+0x155>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811702:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  811709:	00 
  81170a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81170d:	89 44 24 04          	mov    %eax,0x4(%esp)
  811711:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811718:	e8 b6 e4 ff ff       	call   80fbd3 <sys_page_alloc>
  81171d:	89 c3                	mov    %eax,%ebx
  81171f:	85 c0                	test   %eax,%eax
  811721:	0f 88 d9 00 00 00    	js     811800 <pipe+0x155>
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  811727:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81172a:	89 04 24             	mov    %eax,(%esp)
  81172d:	e8 2e ed ff ff       	call   810460 <fd2data>
  811732:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811734:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  81173b:	00 
  81173c:	89 44 24 04          	mov    %eax,0x4(%esp)
  811740:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811747:	e8 87 e4 ff ff       	call   80fbd3 <sys_page_alloc>
  81174c:	89 c3                	mov    %eax,%ebx
  81174e:	85 c0                	test   %eax,%eax
  811750:	0f 88 97 00 00 00    	js     8117ed <pipe+0x142>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  811756:	8b 45 f0             	mov    -0x10(%ebp),%eax
  811759:	89 04 24             	mov    %eax,(%esp)
  81175c:	e8 ff ec ff ff       	call   810460 <fd2data>
  811761:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  811768:	00 
  811769:	89 44 24 0c          	mov    %eax,0xc(%esp)
  81176d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811774:	00 
  811775:	89 74 24 04          	mov    %esi,0x4(%esp)
  811779:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811780:	e8 a2 e4 ff ff       	call   80fc27 <sys_page_map>
  811785:	89 c3                	mov    %eax,%ebx
  811787:	85 c0                	test   %eax,%eax
  811789:	78 52                	js     8117dd <pipe+0x132>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  81178b:	8b 15 24 53 81 00    	mov    0x815324,%edx
  811791:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811794:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  811796:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811799:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  8117a0:	8b 15 24 53 81 00    	mov    0x815324,%edx
  8117a6:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8117a9:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  8117ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8117ae:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, uvpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  8117b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8117b8:	89 04 24             	mov    %eax,(%esp)
  8117bb:	e8 90 ec ff ff       	call   810450 <fd2num>
  8117c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8117c3:	89 01                	mov    %eax,(%ecx)
	pfd[1] = fd2num(fd1);
  8117c5:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8117c8:	89 04 24             	mov    %eax,(%esp)
  8117cb:	e8 80 ec ff ff       	call   810450 <fd2num>
  8117d0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8117d3:	89 41 04             	mov    %eax,0x4(%ecx)
	return 0;
  8117d6:	b8 00 00 00 00       	mov    $0x0,%eax
  8117db:	eb 38                	jmp    811815 <pipe+0x16a>

    err3:
	sys_page_unmap(0, va);
  8117dd:	89 74 24 04          	mov    %esi,0x4(%esp)
  8117e1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8117e8:	e8 8d e4 ff ff       	call   80fc7a <sys_page_unmap>
    err2:
	sys_page_unmap(0, fd1);
  8117ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8117f0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8117f4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8117fb:	e8 7a e4 ff ff       	call   80fc7a <sys_page_unmap>
    err1:
	sys_page_unmap(0, fd0);
  811800:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811803:	89 44 24 04          	mov    %eax,0x4(%esp)
  811807:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81180e:	e8 67 e4 ff ff       	call   80fc7a <sys_page_unmap>
  811813:	89 d8                	mov    %ebx,%eax
    err:
	return r;
}
  811815:	83 c4 30             	add    $0x30,%esp
  811818:	5b                   	pop    %ebx
  811819:	5e                   	pop    %esi
  81181a:	5d                   	pop    %ebp
  81181b:	c3                   	ret    

0081181c <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  81181c:	55                   	push   %ebp
  81181d:	89 e5                	mov    %esp,%ebp
  81181f:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811822:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811825:	89 44 24 04          	mov    %eax,0x4(%esp)
  811829:	8b 45 08             	mov    0x8(%ebp),%eax
  81182c:	89 04 24             	mov    %eax,(%esp)
  81182f:	e8 92 ec ff ff       	call   8104c6 <fd_lookup>
  811834:	89 c2                	mov    %eax,%edx
  811836:	85 d2                	test   %edx,%edx
  811838:	78 15                	js     81184f <pipeisclosed+0x33>
		return r;
	p = (struct Pipe*) fd2data(fd);
  81183a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81183d:	89 04 24             	mov    %eax,(%esp)
  811840:	e8 1b ec ff ff       	call   810460 <fd2data>
	return _pipeisclosed(fd, p);
  811845:	89 c2                	mov    %eax,%edx
  811847:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81184a:	e8 0b fd ff ff       	call   81155a <_pipeisclosed>
}
  81184f:	c9                   	leave  
  811850:	c3                   	ret    
  811851:	66 90                	xchg   %ax,%ax
  811853:	66 90                	xchg   %ax,%ax
  811855:	66 90                	xchg   %ax,%ax
  811857:	66 90                	xchg   %ax,%ax
  811859:	66 90                	xchg   %ax,%ax
  81185b:	66 90                	xchg   %ax,%ax
  81185d:	66 90                	xchg   %ax,%ax
  81185f:	90                   	nop

00811860 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  811860:	55                   	push   %ebp
  811861:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  811863:	b8 00 00 00 00       	mov    $0x0,%eax
  811868:	5d                   	pop    %ebp
  811869:	c3                   	ret    

0081186a <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  81186a:	55                   	push   %ebp
  81186b:	89 e5                	mov    %esp,%ebp
  81186d:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  811870:	c7 44 24 04 96 49 81 	movl   $0x814996,0x4(%esp)
  811877:	00 
  811878:	8b 45 0c             	mov    0xc(%ebp),%eax
  81187b:	89 04 24             	mov    %eax,(%esp)
  81187e:	e8 34 df ff ff       	call   80f7b7 <strcpy>
	return 0;
}
  811883:	b8 00 00 00 00       	mov    $0x0,%eax
  811888:	c9                   	leave  
  811889:	c3                   	ret    

0081188a <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  81188a:	55                   	push   %ebp
  81188b:	89 e5                	mov    %esp,%ebp
  81188d:	57                   	push   %edi
  81188e:	56                   	push   %esi
  81188f:	53                   	push   %ebx
  811890:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  811896:	bb 00 00 00 00       	mov    $0x0,%ebx
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  81189b:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8118a1:	eb 31                	jmp    8118d4 <devcons_write+0x4a>
		m = n - tot;
  8118a3:	8b 75 10             	mov    0x10(%ebp),%esi
  8118a6:	29 de                	sub    %ebx,%esi
		if (m > sizeof(buf) - 1)
  8118a8:	83 fe 7f             	cmp    $0x7f,%esi
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  8118ab:	ba 7f 00 00 00       	mov    $0x7f,%edx
  8118b0:	0f 47 f2             	cmova  %edx,%esi
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  8118b3:	89 74 24 08          	mov    %esi,0x8(%esp)
  8118b7:	03 45 0c             	add    0xc(%ebp),%eax
  8118ba:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118be:	89 3c 24             	mov    %edi,(%esp)
  8118c1:	e8 8e e0 ff ff       	call   80f954 <memmove>
		sys_cputs(buf, m);
  8118c6:	89 74 24 04          	mov    %esi,0x4(%esp)
  8118ca:	89 3c 24             	mov    %edi,(%esp)
  8118cd:	e8 34 e2 ff ff       	call   80fb06 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8118d2:	01 f3                	add    %esi,%ebx
  8118d4:	89 d8                	mov    %ebx,%eax
  8118d6:	3b 5d 10             	cmp    0x10(%ebp),%ebx
  8118d9:	72 c8                	jb     8118a3 <devcons_write+0x19>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  8118db:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  8118e1:	5b                   	pop    %ebx
  8118e2:	5e                   	pop    %esi
  8118e3:	5f                   	pop    %edi
  8118e4:	5d                   	pop    %ebp
  8118e5:	c3                   	ret    

008118e6 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8118e6:	55                   	push   %ebp
  8118e7:	89 e5                	mov    %esp,%ebp
  8118e9:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
		return 0;
  8118ec:	b8 00 00 00 00       	mov    $0x0,%eax
static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
	int c;

	if (n == 0)
  8118f1:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8118f5:	75 07                	jne    8118fe <devcons_read+0x18>
  8118f7:	eb 2a                	jmp    811923 <devcons_read+0x3d>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8118f9:	e8 b6 e2 ff ff       	call   80fbb4 <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8118fe:	66 90                	xchg   %ax,%ax
  811900:	e8 1f e2 ff ff       	call   80fb24 <sys_cgetc>
  811905:	85 c0                	test   %eax,%eax
  811907:	74 f0                	je     8118f9 <devcons_read+0x13>
		sys_yield();
	if (c < 0)
  811909:	85 c0                	test   %eax,%eax
  81190b:	78 16                	js     811923 <devcons_read+0x3d>
		return c;
	if (c == 0x04)	// ctl-d is eof
  81190d:	83 f8 04             	cmp    $0x4,%eax
  811910:	74 0c                	je     81191e <devcons_read+0x38>
		return 0;
	*(char*)vbuf = c;
  811912:	8b 55 0c             	mov    0xc(%ebp),%edx
  811915:	88 02                	mov    %al,(%edx)
	return 1;
  811917:	b8 01 00 00 00       	mov    $0x1,%eax
  81191c:	eb 05                	jmp    811923 <devcons_read+0x3d>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  81191e:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  811923:	c9                   	leave  
  811924:	c3                   	ret    

00811925 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  811925:	55                   	push   %ebp
  811926:	89 e5                	mov    %esp,%ebp
  811928:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  81192b:	8b 45 08             	mov    0x8(%ebp),%eax
  81192e:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  811931:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  811938:	00 
  811939:	8d 45 f7             	lea    -0x9(%ebp),%eax
  81193c:	89 04 24             	mov    %eax,(%esp)
  81193f:	e8 c2 e1 ff ff       	call   80fb06 <sys_cputs>
}
  811944:	c9                   	leave  
  811945:	c3                   	ret    

00811946 <getchar>:

int
getchar(void)
{
  811946:	55                   	push   %ebp
  811947:	89 e5                	mov    %esp,%ebp
  811949:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  81194c:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  811953:	00 
  811954:	8d 45 f7             	lea    -0x9(%ebp),%eax
  811957:	89 44 24 04          	mov    %eax,0x4(%esp)
  81195b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811962:	e8 f3 ed ff ff       	call   81075a <read>
	if (r < 0)
  811967:	85 c0                	test   %eax,%eax
  811969:	78 0f                	js     81197a <getchar+0x34>
		return r;
	if (r < 1)
  81196b:	85 c0                	test   %eax,%eax
  81196d:	7e 06                	jle    811975 <getchar+0x2f>
		return -E_EOF;
	return c;
  81196f:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  811973:	eb 05                	jmp    81197a <getchar+0x34>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  811975:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  81197a:	c9                   	leave  
  81197b:	c3                   	ret    

0081197c <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  81197c:	55                   	push   %ebp
  81197d:	89 e5                	mov    %esp,%ebp
  81197f:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  811982:	8d 45 f4             	lea    -0xc(%ebp),%eax
  811985:	89 44 24 04          	mov    %eax,0x4(%esp)
  811989:	8b 45 08             	mov    0x8(%ebp),%eax
  81198c:	89 04 24             	mov    %eax,(%esp)
  81198f:	e8 32 eb ff ff       	call   8104c6 <fd_lookup>
  811994:	85 c0                	test   %eax,%eax
  811996:	78 11                	js     8119a9 <iscons+0x2d>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  811998:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81199b:	8b 15 40 53 81 00    	mov    0x815340,%edx
  8119a1:	39 10                	cmp    %edx,(%eax)
  8119a3:	0f 94 c0             	sete   %al
  8119a6:	0f b6 c0             	movzbl %al,%eax
}
  8119a9:	c9                   	leave  
  8119aa:	c3                   	ret    

008119ab <opencons>:

int
opencons(void)
{
  8119ab:	55                   	push   %ebp
  8119ac:	89 e5                	mov    %esp,%ebp
  8119ae:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  8119b1:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8119b4:	89 04 24             	mov    %eax,(%esp)
  8119b7:	e8 bb ea ff ff       	call   810477 <fd_alloc>
		return r;
  8119bc:	89 c2                	mov    %eax,%edx
opencons(void)
{
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  8119be:	85 c0                	test   %eax,%eax
  8119c0:	78 40                	js     811a02 <opencons+0x57>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8119c2:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8119c9:	00 
  8119ca:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8119cd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119d1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8119d8:	e8 f6 e1 ff ff       	call   80fbd3 <sys_page_alloc>
		return r;
  8119dd:	89 c2                	mov    %eax,%edx
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  8119df:	85 c0                	test   %eax,%eax
  8119e1:	78 1f                	js     811a02 <opencons+0x57>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  8119e3:	8b 15 40 53 81 00    	mov    0x815340,%edx
  8119e9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8119ec:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  8119ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8119f1:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  8119f8:	89 04 24             	mov    %eax,(%esp)
  8119fb:	e8 50 ea ff ff       	call   810450 <fd2num>
  811a00:	89 c2                	mov    %eax,%edx
}
  811a02:	89 d0                	mov    %edx,%eax
  811a04:	c9                   	leave  
  811a05:	c3                   	ret    

00811a06 <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  811a06:	55                   	push   %ebp
  811a07:	89 e5                	mov    %esp,%ebp
  811a09:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  811a0c:	83 3d 00 f0 b3 00 00 	cmpl   $0x0,0xb3f000
  811a13:	75 68                	jne    811a7d <set_pgfault_handler+0x77>
		// First time through!
		// LAB 4: Your code here.
		int ret;
		if ((ret = sys_page_alloc(thisenv->env_id,
  811a15:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  811a1a:	8b 40 48             	mov    0x48(%eax),%eax
  811a1d:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  811a24:	00 
  811a25:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  811a2c:	ee 
  811a2d:	89 04 24             	mov    %eax,(%esp)
  811a30:	e8 9e e1 ff ff       	call   80fbd3 <sys_page_alloc>
  811a35:	85 c0                	test   %eax,%eax
  811a37:	74 2c                	je     811a65 <set_pgfault_handler+0x5f>
				(void *) (UXSTACKTOP - PGSIZE),
				PTE_W | PTE_U | PTE_P)) != 0) {
			cprintf("set_pg_fault_handler: can't allocate new page, %e\n", ret);
  811a39:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a3d:	c7 04 24 a4 49 81 00 	movl   $0x8149a4,(%esp)
  811a44:	e8 4a d7 ff ff       	call   80f193 <cprintf>
			panic("set_pg_fault_handler");
  811a49:	c7 44 24 08 d8 49 81 	movl   $0x8149d8,0x8(%esp)
  811a50:	00 
  811a51:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
  811a58:	00 
  811a59:	c7 04 24 ed 49 81 00 	movl   $0x8149ed,(%esp)
  811a60:	e8 35 d6 ff ff       	call   80f09a <_panic>
		}
		sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall);
  811a65:	a1 7c c2 b3 00       	mov    0xb3c27c,%eax
  811a6a:	8b 40 48             	mov    0x48(%eax),%eax
  811a6d:	c7 44 24 04 87 1a 81 	movl   $0x811a87,0x4(%esp)
  811a74:	00 
  811a75:	89 04 24             	mov    %eax,(%esp)
  811a78:	e8 f6 e2 ff ff       	call   80fd73 <sys_env_set_pgfault_upcall>
		//panic("set_pgfault_handler not implemented");
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  811a7d:	8b 45 08             	mov    0x8(%ebp),%eax
  811a80:	a3 00 f0 b3 00       	mov    %eax,0xb3f000
}
  811a85:	c9                   	leave  
  811a86:	c3                   	ret    

00811a87 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  811a87:	54                   	push   %esp
	movl _pgfault_handler, %eax
  811a88:	a1 00 f0 b3 00       	mov    0xb3f000,%eax
	call *%eax
  811a8d:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  811a8f:	83 c4 04             	add    $0x4,%esp
	// registers are available for intermediate calculations.  You
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	movl 0x28(%esp), %eax
  811a92:	8b 44 24 28          	mov    0x28(%esp),%eax
	movl %esp, %ebp
  811a96:	89 e5                	mov    %esp,%ebp
	movl 0x30(%esp), %esp
  811a98:	8b 64 24 30          	mov    0x30(%esp),%esp
	pushl %eax
  811a9c:	50                   	push   %eax
	movl %esp, 0x30(%ebp)
  811a9d:	89 65 30             	mov    %esp,0x30(%ebp)
	movl %ebp, %esp
  811aa0:	89 ec                	mov    %ebp,%esp

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	popl %eax
  811aa2:	58                   	pop    %eax
	popl %eax
  811aa3:	58                   	pop    %eax
	popal
  811aa4:	61                   	popa   

	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	addl $0x4, %esp
  811aa5:	83 c4 04             	add    $0x4,%esp
	popfl
  811aa8:	9d                   	popf   
	
	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.
	popl %esp
  811aa9:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	ret
  811aaa:	c3                   	ret    

00811aab <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  811aab:	55                   	push   %ebp
  811aac:	89 e5                	mov    %esp,%ebp
  811aae:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811ab1:	89 d0                	mov    %edx,%eax
  811ab3:	c1 e8 16             	shr    $0x16,%eax
  811ab6:	8b 0c 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%ecx
		return 0;
  811abd:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(uvpd[PDX(v)] & PTE_P))
  811ac2:	f6 c1 01             	test   $0x1,%cl
  811ac5:	74 1d                	je     811ae4 <pageref+0x39>
		return 0;
	pte = uvpt[PGNUM(v)];
  811ac7:	c1 ea 0c             	shr    $0xc,%edx
  811aca:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
	if (!(pte & PTE_P))
  811ad1:	f6 c2 01             	test   $0x1,%dl
  811ad4:	74 0e                	je     811ae4 <pageref+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  811ad6:	c1 ea 0c             	shr    $0xc,%edx
  811ad9:	0f b7 04 d5 04 00 00 	movzwl -0x10fffffc(,%edx,8),%eax
  811ae0:	ef 
  811ae1:	0f b7 c0             	movzwl %ax,%eax
}
  811ae4:	5d                   	pop    %ebp
  811ae5:	c3                   	ret    
  811ae6:	66 90                	xchg   %ax,%ax
  811ae8:	66 90                	xchg   %ax,%ax
  811aea:	66 90                	xchg   %ax,%ax
  811aec:	66 90                	xchg   %ax,%ax
  811aee:	66 90                	xchg   %ax,%ax

00811af0 <__udivdi3>:
  811af0:	55                   	push   %ebp
  811af1:	57                   	push   %edi
  811af2:	56                   	push   %esi
  811af3:	83 ec 0c             	sub    $0xc,%esp
  811af6:	8b 44 24 28          	mov    0x28(%esp),%eax
  811afa:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
  811afe:	8b 6c 24 20          	mov    0x20(%esp),%ebp
  811b02:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  811b06:	85 c0                	test   %eax,%eax
  811b08:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811b0c:	89 ea                	mov    %ebp,%edx
  811b0e:	89 0c 24             	mov    %ecx,(%esp)
  811b11:	75 2d                	jne    811b40 <__udivdi3+0x50>
  811b13:	39 e9                	cmp    %ebp,%ecx
  811b15:	77 61                	ja     811b78 <__udivdi3+0x88>
  811b17:	85 c9                	test   %ecx,%ecx
  811b19:	89 ce                	mov    %ecx,%esi
  811b1b:	75 0b                	jne    811b28 <__udivdi3+0x38>
  811b1d:	b8 01 00 00 00       	mov    $0x1,%eax
  811b22:	31 d2                	xor    %edx,%edx
  811b24:	f7 f1                	div    %ecx
  811b26:	89 c6                	mov    %eax,%esi
  811b28:	31 d2                	xor    %edx,%edx
  811b2a:	89 e8                	mov    %ebp,%eax
  811b2c:	f7 f6                	div    %esi
  811b2e:	89 c5                	mov    %eax,%ebp
  811b30:	89 f8                	mov    %edi,%eax
  811b32:	f7 f6                	div    %esi
  811b34:	89 ea                	mov    %ebp,%edx
  811b36:	83 c4 0c             	add    $0xc,%esp
  811b39:	5e                   	pop    %esi
  811b3a:	5f                   	pop    %edi
  811b3b:	5d                   	pop    %ebp
  811b3c:	c3                   	ret    
  811b3d:	8d 76 00             	lea    0x0(%esi),%esi
  811b40:	39 e8                	cmp    %ebp,%eax
  811b42:	77 24                	ja     811b68 <__udivdi3+0x78>
  811b44:	0f bd e8             	bsr    %eax,%ebp
  811b47:	83 f5 1f             	xor    $0x1f,%ebp
  811b4a:	75 3c                	jne    811b88 <__udivdi3+0x98>
  811b4c:	8b 74 24 04          	mov    0x4(%esp),%esi
  811b50:	39 34 24             	cmp    %esi,(%esp)
  811b53:	0f 86 9f 00 00 00    	jbe    811bf8 <__udivdi3+0x108>
  811b59:	39 d0                	cmp    %edx,%eax
  811b5b:	0f 82 97 00 00 00    	jb     811bf8 <__udivdi3+0x108>
  811b61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  811b68:	31 d2                	xor    %edx,%edx
  811b6a:	31 c0                	xor    %eax,%eax
  811b6c:	83 c4 0c             	add    $0xc,%esp
  811b6f:	5e                   	pop    %esi
  811b70:	5f                   	pop    %edi
  811b71:	5d                   	pop    %ebp
  811b72:	c3                   	ret    
  811b73:	90                   	nop
  811b74:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811b78:	89 f8                	mov    %edi,%eax
  811b7a:	f7 f1                	div    %ecx
  811b7c:	31 d2                	xor    %edx,%edx
  811b7e:	83 c4 0c             	add    $0xc,%esp
  811b81:	5e                   	pop    %esi
  811b82:	5f                   	pop    %edi
  811b83:	5d                   	pop    %ebp
  811b84:	c3                   	ret    
  811b85:	8d 76 00             	lea    0x0(%esi),%esi
  811b88:	89 e9                	mov    %ebp,%ecx
  811b8a:	8b 3c 24             	mov    (%esp),%edi
  811b8d:	d3 e0                	shl    %cl,%eax
  811b8f:	89 c6                	mov    %eax,%esi
  811b91:	b8 20 00 00 00       	mov    $0x20,%eax
  811b96:	29 e8                	sub    %ebp,%eax
  811b98:	89 c1                	mov    %eax,%ecx
  811b9a:	d3 ef                	shr    %cl,%edi
  811b9c:	89 e9                	mov    %ebp,%ecx
  811b9e:	89 7c 24 08          	mov    %edi,0x8(%esp)
  811ba2:	8b 3c 24             	mov    (%esp),%edi
  811ba5:	09 74 24 08          	or     %esi,0x8(%esp)
  811ba9:	89 d6                	mov    %edx,%esi
  811bab:	d3 e7                	shl    %cl,%edi
  811bad:	89 c1                	mov    %eax,%ecx
  811baf:	89 3c 24             	mov    %edi,(%esp)
  811bb2:	8b 7c 24 04          	mov    0x4(%esp),%edi
  811bb6:	d3 ee                	shr    %cl,%esi
  811bb8:	89 e9                	mov    %ebp,%ecx
  811bba:	d3 e2                	shl    %cl,%edx
  811bbc:	89 c1                	mov    %eax,%ecx
  811bbe:	d3 ef                	shr    %cl,%edi
  811bc0:	09 d7                	or     %edx,%edi
  811bc2:	89 f2                	mov    %esi,%edx
  811bc4:	89 f8                	mov    %edi,%eax
  811bc6:	f7 74 24 08          	divl   0x8(%esp)
  811bca:	89 d6                	mov    %edx,%esi
  811bcc:	89 c7                	mov    %eax,%edi
  811bce:	f7 24 24             	mull   (%esp)
  811bd1:	39 d6                	cmp    %edx,%esi
  811bd3:	89 14 24             	mov    %edx,(%esp)
  811bd6:	72 30                	jb     811c08 <__udivdi3+0x118>
  811bd8:	8b 54 24 04          	mov    0x4(%esp),%edx
  811bdc:	89 e9                	mov    %ebp,%ecx
  811bde:	d3 e2                	shl    %cl,%edx
  811be0:	39 c2                	cmp    %eax,%edx
  811be2:	73 05                	jae    811be9 <__udivdi3+0xf9>
  811be4:	3b 34 24             	cmp    (%esp),%esi
  811be7:	74 1f                	je     811c08 <__udivdi3+0x118>
  811be9:	89 f8                	mov    %edi,%eax
  811beb:	31 d2                	xor    %edx,%edx
  811bed:	e9 7a ff ff ff       	jmp    811b6c <__udivdi3+0x7c>
  811bf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  811bf8:	31 d2                	xor    %edx,%edx
  811bfa:	b8 01 00 00 00       	mov    $0x1,%eax
  811bff:	e9 68 ff ff ff       	jmp    811b6c <__udivdi3+0x7c>
  811c04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811c08:	8d 47 ff             	lea    -0x1(%edi),%eax
  811c0b:	31 d2                	xor    %edx,%edx
  811c0d:	83 c4 0c             	add    $0xc,%esp
  811c10:	5e                   	pop    %esi
  811c11:	5f                   	pop    %edi
  811c12:	5d                   	pop    %ebp
  811c13:	c3                   	ret    
  811c14:	66 90                	xchg   %ax,%ax
  811c16:	66 90                	xchg   %ax,%ax
  811c18:	66 90                	xchg   %ax,%ax
  811c1a:	66 90                	xchg   %ax,%ax
  811c1c:	66 90                	xchg   %ax,%ax
  811c1e:	66 90                	xchg   %ax,%ax

00811c20 <__umoddi3>:
  811c20:	55                   	push   %ebp
  811c21:	57                   	push   %edi
  811c22:	56                   	push   %esi
  811c23:	83 ec 14             	sub    $0x14,%esp
  811c26:	8b 44 24 28          	mov    0x28(%esp),%eax
  811c2a:	8b 4c 24 24          	mov    0x24(%esp),%ecx
  811c2e:	8b 74 24 2c          	mov    0x2c(%esp),%esi
  811c32:	89 c7                	mov    %eax,%edi
  811c34:	89 44 24 04          	mov    %eax,0x4(%esp)
  811c38:	8b 44 24 30          	mov    0x30(%esp),%eax
  811c3c:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  811c40:	89 34 24             	mov    %esi,(%esp)
  811c43:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811c47:	85 c0                	test   %eax,%eax
  811c49:	89 c2                	mov    %eax,%edx
  811c4b:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811c4f:	75 17                	jne    811c68 <__umoddi3+0x48>
  811c51:	39 fe                	cmp    %edi,%esi
  811c53:	76 4b                	jbe    811ca0 <__umoddi3+0x80>
  811c55:	89 c8                	mov    %ecx,%eax
  811c57:	89 fa                	mov    %edi,%edx
  811c59:	f7 f6                	div    %esi
  811c5b:	89 d0                	mov    %edx,%eax
  811c5d:	31 d2                	xor    %edx,%edx
  811c5f:	83 c4 14             	add    $0x14,%esp
  811c62:	5e                   	pop    %esi
  811c63:	5f                   	pop    %edi
  811c64:	5d                   	pop    %ebp
  811c65:	c3                   	ret    
  811c66:	66 90                	xchg   %ax,%ax
  811c68:	39 f8                	cmp    %edi,%eax
  811c6a:	77 54                	ja     811cc0 <__umoddi3+0xa0>
  811c6c:	0f bd e8             	bsr    %eax,%ebp
  811c6f:	83 f5 1f             	xor    $0x1f,%ebp
  811c72:	75 5c                	jne    811cd0 <__umoddi3+0xb0>
  811c74:	8b 7c 24 08          	mov    0x8(%esp),%edi
  811c78:	39 3c 24             	cmp    %edi,(%esp)
  811c7b:	0f 87 e7 00 00 00    	ja     811d68 <__umoddi3+0x148>
  811c81:	8b 7c 24 04          	mov    0x4(%esp),%edi
  811c85:	29 f1                	sub    %esi,%ecx
  811c87:	19 c7                	sbb    %eax,%edi
  811c89:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811c8d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811c91:	8b 44 24 08          	mov    0x8(%esp),%eax
  811c95:	8b 54 24 0c          	mov    0xc(%esp),%edx
  811c99:	83 c4 14             	add    $0x14,%esp
  811c9c:	5e                   	pop    %esi
  811c9d:	5f                   	pop    %edi
  811c9e:	5d                   	pop    %ebp
  811c9f:	c3                   	ret    
  811ca0:	85 f6                	test   %esi,%esi
  811ca2:	89 f5                	mov    %esi,%ebp
  811ca4:	75 0b                	jne    811cb1 <__umoddi3+0x91>
  811ca6:	b8 01 00 00 00       	mov    $0x1,%eax
  811cab:	31 d2                	xor    %edx,%edx
  811cad:	f7 f6                	div    %esi
  811caf:	89 c5                	mov    %eax,%ebp
  811cb1:	8b 44 24 04          	mov    0x4(%esp),%eax
  811cb5:	31 d2                	xor    %edx,%edx
  811cb7:	f7 f5                	div    %ebp
  811cb9:	89 c8                	mov    %ecx,%eax
  811cbb:	f7 f5                	div    %ebp
  811cbd:	eb 9c                	jmp    811c5b <__umoddi3+0x3b>
  811cbf:	90                   	nop
  811cc0:	89 c8                	mov    %ecx,%eax
  811cc2:	89 fa                	mov    %edi,%edx
  811cc4:	83 c4 14             	add    $0x14,%esp
  811cc7:	5e                   	pop    %esi
  811cc8:	5f                   	pop    %edi
  811cc9:	5d                   	pop    %ebp
  811cca:	c3                   	ret    
  811ccb:	90                   	nop
  811ccc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811cd0:	8b 04 24             	mov    (%esp),%eax
  811cd3:	be 20 00 00 00       	mov    $0x20,%esi
  811cd8:	89 e9                	mov    %ebp,%ecx
  811cda:	29 ee                	sub    %ebp,%esi
  811cdc:	d3 e2                	shl    %cl,%edx
  811cde:	89 f1                	mov    %esi,%ecx
  811ce0:	d3 e8                	shr    %cl,%eax
  811ce2:	89 e9                	mov    %ebp,%ecx
  811ce4:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ce8:	8b 04 24             	mov    (%esp),%eax
  811ceb:	09 54 24 04          	or     %edx,0x4(%esp)
  811cef:	89 fa                	mov    %edi,%edx
  811cf1:	d3 e0                	shl    %cl,%eax
  811cf3:	89 f1                	mov    %esi,%ecx
  811cf5:	89 44 24 08          	mov    %eax,0x8(%esp)
  811cf9:	8b 44 24 10          	mov    0x10(%esp),%eax
  811cfd:	d3 ea                	shr    %cl,%edx
  811cff:	89 e9                	mov    %ebp,%ecx
  811d01:	d3 e7                	shl    %cl,%edi
  811d03:	89 f1                	mov    %esi,%ecx
  811d05:	d3 e8                	shr    %cl,%eax
  811d07:	89 e9                	mov    %ebp,%ecx
  811d09:	09 f8                	or     %edi,%eax
  811d0b:	8b 7c 24 10          	mov    0x10(%esp),%edi
  811d0f:	f7 74 24 04          	divl   0x4(%esp)
  811d13:	d3 e7                	shl    %cl,%edi
  811d15:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811d19:	89 d7                	mov    %edx,%edi
  811d1b:	f7 64 24 08          	mull   0x8(%esp)
  811d1f:	39 d7                	cmp    %edx,%edi
  811d21:	89 c1                	mov    %eax,%ecx
  811d23:	89 14 24             	mov    %edx,(%esp)
  811d26:	72 2c                	jb     811d54 <__umoddi3+0x134>
  811d28:	39 44 24 0c          	cmp    %eax,0xc(%esp)
  811d2c:	72 22                	jb     811d50 <__umoddi3+0x130>
  811d2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
  811d32:	29 c8                	sub    %ecx,%eax
  811d34:	19 d7                	sbb    %edx,%edi
  811d36:	89 e9                	mov    %ebp,%ecx
  811d38:	89 fa                	mov    %edi,%edx
  811d3a:	d3 e8                	shr    %cl,%eax
  811d3c:	89 f1                	mov    %esi,%ecx
  811d3e:	d3 e2                	shl    %cl,%edx
  811d40:	89 e9                	mov    %ebp,%ecx
  811d42:	d3 ef                	shr    %cl,%edi
  811d44:	09 d0                	or     %edx,%eax
  811d46:	89 fa                	mov    %edi,%edx
  811d48:	83 c4 14             	add    $0x14,%esp
  811d4b:	5e                   	pop    %esi
  811d4c:	5f                   	pop    %edi
  811d4d:	5d                   	pop    %ebp
  811d4e:	c3                   	ret    
  811d4f:	90                   	nop
  811d50:	39 d7                	cmp    %edx,%edi
  811d52:	75 da                	jne    811d2e <__umoddi3+0x10e>
  811d54:	8b 14 24             	mov    (%esp),%edx
  811d57:	89 c1                	mov    %eax,%ecx
  811d59:	2b 4c 24 08          	sub    0x8(%esp),%ecx
  811d5d:	1b 54 24 04          	sbb    0x4(%esp),%edx
  811d61:	eb cb                	jmp    811d2e <__umoddi3+0x10e>
  811d63:	90                   	nop
  811d64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811d68:	3b 44 24 0c          	cmp    0xc(%esp),%eax
  811d6c:	0f 82 0f ff ff ff    	jb     811c81 <__umoddi3+0x61>
  811d72:	e9 1a ff ff ff       	jmp    811c91 <__umoddi3+0x71>
